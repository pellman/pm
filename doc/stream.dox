/*! \file include/pm/stream.hpp
 *  \brief Содержит класс потоков разбора pm::Stream.
 */

/*! \class pm::Stream
 *  \brief Класс потоков разбора.
 *  
 *  
 *  *Поток разбора* -  это особый \ref DStream "поток ввода", способный надстраиваться над \ref DSStd "стандартными потоками ввода" (и над всем, что к ним сводится).
 *  
 *  Кластеры
 *  ==
 *  
 *  Все потоки разбора группируются по *кластерам*.
 *  Кластер задаётся:
 *  - ссылкой на *базовый поток* - стандартный поток ввода;
 *  - *текстом* - конечной или бесконечной последовательностью \ref DTypes "символов" (как и \ref DSGeneral "текст потока ввода").
 *  
 *  Кластер (С) *инициализируется* от произвольного стандартного потока ввода (is).
 *  В результате инициализации поток is становится базовым потоком C, а текст потока is в момент инициализации становится текстом кластера.
 *  
 *  Базовый поток и текст кластера не изменяются вплоть до уничтожения кластера.
 *  
 *  Кластер *уничтожается*, когда уничтожается последний поток разбора этого кластера.
 *  
 *  Текст кластера C в документации обозначается так: C[0] C[1] C[2] ... .
 *  
 *  Свободные и связанные потоки
 *  ==
 *  
 *  Стандартный поток ввода в документации называется *связанным*, если он является базовым потоком хотя бы одного кластера, а иначе - *свободным*.
 *  
 *  Взаимодействие со связанным потоком допускается **только** через методы потоков разбора согласно документации.
 *  Иначе результаты выполнения программы могут быть непредсказуемыми.
 *  
 *  Количество символов, фактически читаемых из связанного потока при работе с потоками разбора, не специфицировано:
 *  может читаться больше символов, чем предполагает пользователь.
 *  
 *  Итераторы
 *  ==
 *  
 *  *Итератор* потока - это объект класса pm::Stream::Iterator.
 *  С точки зрения пользователя, итератор - это \ref DTypes "индекс", принадлежащий (как и поток разбора) какому-либо кластеру.
 *  
 *  При работе с итераторами допускаются только некоторые операции, характерные для индексов:
 *  - \ref DObjectModification "Инициализация по умолчанию".
 *   Кластер инициализируемого итератора не специфицирован.
 *  - \ref DObjectModification "Копирование через конструктор и через присваивание".
 *   Принадлежность кластеру также копируется. 
 *  - \ref DObjectModification "Перемещение через конструктор и через присваивание".
 *   Аналогично копированию, но новое значение перемещаемого итератора не специфицировано.
 *  - Сравнение: it1 == it2, it1 != it2.
 *   Разрешено сравнивать только итераторы одного кластера.
 *  - Разность: it1 - it2.
 *   При вычислении разности разрешено использовать только итераторы одного кластера, причём значение it2 должно быть не меньше значения it1.
 *   Результат имеет тип size_t (то есть является индексом).
 *  
 *  Потоки разбора
 *  ==
 *  
 *  *Поток разбора* S задаётся:
 *  - кластером C этого потока;
 *  - *позицией* p - итератором кластера C;
 *  - (опционально) *границей* b - итератором кластера C, не меньшим p.
 *  
 *  Текст указанного потока разбора имеет следующий вид:
 *  - C[p] C[p+1] C[p+2] ..., если границы нет.
 *  - C[p] C[p+1] C[p+2] ... C[b-1], если граница есть.
 *   Если b == p, то текст потока S пуст.
 *  
 *  Обновление текста указанного потока разбора при \ref DSRead "чтении символа" - это увеличение позиции на 1.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref DValidState "Нестандартно-корректен".
 *  
 *  Специальные методы
 *  ==
 *  
 *      Stream()
 *  
 *  Удалён.
 *  
 *  
 *      Stream(const Stream & is)
 *      Stream(Stream && is)
 *  
 *  Инициализировать поток разбора в кластере потока \p is, скопировав/переместив в него позицию и (при наличии) границу потока \p is.
 *  
 *  При перемещении поток \p is удаляется из своего текущего кластера.
 *  
 *  
 *      Stream & operator =(const Stream & is)
 *      Stream & operator =(Stream && is)
 *  
 *  Перезаписать \ref DSelf "self" потоком в кластере потока \p is, скопировав/переместив позицию и (при наличии) границу потока \p is.
 *  
 *  При перемещении поток \p is удаляется из своего текущего кластера.
 *  
 *  \return Self.
 *  
 *  
 *      ~Stream()
 *  
 *  Уничтожить поток (и удалить его из текущего кластера).
 */

/*! \fn bool pm::Stream::try_advance()
 *  \brief Попытаться увеличить позицию на единицу.
 *  
 *  Успех <=> текст потока непуст.
 *  
 *  При успехе из потока читается символ.
 *  
 *  \return true <=> успех.
 */

/*! \fn bool pm::Stream::try_advance(size_t size)
 *  \brief Попытаться увеличить позицию на \p size.
 *  
 *  Успех <=> в тексте потока содержится хотя бы \p size символов.
 *  
 *  При успехе из потока читается \p size символов.
 *  
 *  \return true <=> успех.
 */

/*! \fn size_t pm::Stream::advance(size_t size)
 *  \brief Увеличить позицию не более чем на \p size.
 *  
 *  Определяется индекс k:
 *  - если в тексте потока содержится хотя бы \p size символов, то k == \p size;
 *  - иначе k - то, сколько символов содержится в тексте потока.
 *  
 *  Из потока читается k символов.
 *  
 *  \return k.
 */

/*! \fn std::optional<char> pm::Stream::try_get()
 *  \brief Попытаться прочитать символ из потока.
 *  
 *  Успех <=> текст потока непуст.
 *  
 *  При успехе из потока читается символ.
 *  
 *  \return
 *    При успехе: \ref DTypes "опционал", содержащий символ, равный прочитанному.
 *    Иначе: пустой опционал.
 */

/*! \fn std::optional<std::string> pm::Stream::try_get(size_t size)
 *  \brief Попытаться прочитать \p size символов из потока.
 *  
 *  Успех <=> в тексте потока содержится хотя бы \p size символов.
 *  
 *  При успехе из потока читается \p size символов.
 *  
 *  \return
 *    При успехе: \ref DTypes "опционал", содержащий \ref DTypes "строку", составленную из прочитанных символов (в порядке чтения).
 *    Иначе: пустой опционал.
 */

/*! \fn std::string pm::Stream::get(size_t size)
 *  \brief Прочитать не более \p size символов из потока.
 *  
 *  Определяется индекс k:
 *  - если в тексте потока содержится хотя бы \p size символов, то k == \p size;
 *  - иначе k - то, сколько символов содержится в тексте потока.
 *  
 *  Из потока читается k символов.
 *  
 *  \return
 *    \ref DTypes "Строка", составленная из прочитанных символов (в порядке чтения).
 */

/*! \fn std::string pm::Stream::get(const Iterator & bound)
 *  \brief Прочитать символы потока до итератора \p bound.
 *  
 *  \pre Итератор \p bound принадлежит кластеру потока.
 *  \pre Для позиции p потока верно p <= \p bound.
 *  \pre Если поток содержит границу b, то \p bound <= b.
 *  
 *  Из потока читается столько символов, чтобы позиция стала равна \p bound.
 *  
 *  \return
 *    \ref DTypes "Строка", составленная из прочитанных символов (в порядке чтения).
 */

/*! \fn std::optional<char> pm::Stream::try_peek() const
 *  \brief Попытаться подглядеть следующий символ потока.
 *  
 *  \return
 *    Если поток непуст: \ref DTypes "опционал", содержащий символ \ref DSelf "self"\ref DSGeneral "[0]".
 *    Иначе: пустой опционал.
 */

/*! \fn std::optional<std::string> pm::Stream::try_peek(size_t size) const
 *  \brief Попытаться подглядеть \p size следующих символов потока.
 *  
 *  \return
 *    Если в тексте потока содержится хотя бы \p size символов: \ref DTypes "опционал", содержащий \ref DTypes "строку", составленную из символов \ref DSelf "self"\ref DSGeneral "[0]" self[1] ... self[\p size-1].
 *    Иначе: пустой опционал.
 */

/*! \fn std::string pm::Stream::peek(size_t size) const
 *  \brief Подглядеть не более \p size символов из потока.
 *  
 *  \return
 *    Если в потоке содержится хотя бы \p size символов: \ref DTypes "строка", составленная из символов \ref DSelf "self"\ref DSGeneral "[0]" self[1] ... self[\p size-1].
 *    Иначе: строка, содержащая весь текст потока.
 */

/*! \fn std::string pm::Stream::peek(const Iterator & bound) const
 *  \brief Подглядеть символы потока до итератора \p bound.
 *  
 *  \pre Итератор \p bound принадлежит кластеру потока.
 *  \pre Для позиции p потока верно p <= \p bound.
 *  \pre Если поток содержит границу b, то \p bound <= b.
 *  
 *  \return
 *    \ref DTypes "Строка", составленная из символов \ref DSelf "self"\ref DSGeneral "[0]" self[1] ... self[\p bound - p], где p - позиция потока.
 */

/*! \fn bool pm::Stream::empty() const
 *  \brief Вернуть true <=> текст потока пуст.
 */

/*! \fn Stream pm::Stream::get_prefix(Iterator bound) const
 *  \brief Вернуть префикс потока до границы \p bound.
 *  
 *  \pre Итератор \p bound принадлежит кластеру потока self.
 *  \pre Для позиции p потока self верно p <= \p bound.
 *  \pre Если поток self содержит границу b, то \p bound <= b.
 *  
 *  \return
 *    Новый поток разбора, отличающийся от \ref DSelf "self" только тем, что в него установлена граница \p bound.
 */

/*! \fn Stream pm::Stream::get_prefix(size_t size) const
 *  \brief Вернуть префикс потока длины не более \p size.
 *  
 *  Определяется индекс k:
 *  - если в тексте потока содержится хотя бы \p size символов, то k == \p size;
 *  - иначе k - то, сколько символов содержится в тексте потока.
 *  
 *  \return
 *    Новый поток разбора, текст которого - это первые k символов текста потока \ref DSelf "self".
 */

/*! \fn Iterator pm::Stream::get_position() const
 *  \brief Вернуть позицию потока.
 */

/*! \fn void pm::Stream::set_position(Iterator position)
 *  \brief Присвоить \p position в позицию потока.
 *  
 *  \pre Итератор \p position принадлежит кластеру потока.
 *  \pre Если поток содержит границу b, то \p position <= b.
 */

/*! \fn Stream pm::Stream::wrap(std::istream * is_ptr)
 *  \brief Обернуть потоком разбора поток *\p is_ptr с уничтожением.
 *  
 *  От потока *\p is_ptr инициализируется новый кластер (C).
 *  После уничтожения кластера поток *\p is_ptr уничтожается.
 *  
 *  \return
 *    Поток разбора в кластере C с позицией 0 и без границы.
 *  
 *  \pre Поток *\p is_ptr свободен.
 *  \pre После вызова метода поток *\p is_ptr не используется в коде (в том числе не уничтожается и не изменяется).
 */

/*! \fn Stream pm::Stream::wrap(std::istream & is)
 *  \brief Обернуть потоком разбора поток \p is без уничтожения.
 *  
 *  От потока \p is инициализируется новый кластер (C).
 *  При уничтожении кластера поток \p is не затрагивается (в том числе не уничтожается).
 *  
 *  \return
 *    Поток разбора в кластере C с позицией 0 и без границы.
 *  
 *  \pre Поток \p is свободен.
 *  \pre После вызова метода и до уничтожения кластера поток \p is не используется в коде (в том числе не уничтожается и не изменяется).
 */

/*! \fn Stream pm::Stream::wrap(const std::string & s)
 *  \brief Эквивалентно вызову wrap(new std::istringstream(\p s), \p buffer_chunk_size).
 */

/*! \fn Stream pm::Stream::wrap_file(const std::string & filename)
 *  \brief Эквивалентно вызову wrap(new std::ifstream(\p s), \p buffer_chunk_size).
 */
