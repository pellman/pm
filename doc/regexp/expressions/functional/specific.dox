/*! \file include/pm/regexp/expressions/functional/specific.hpp
 *  \brief Содержит интерфейс создания \ref PRLFnSpecific "готовых специальных функциональных регулярных выражений": текущие и сохранённые данные контекста изменяются заданным простым для понимания способом.
 *  \ingroup ModuleRegexp
 *  
 *  Все выражения, создаваемые при помощи интерфейса, \ref PRSafety "безопасны".
 *  
 *  Особенности \ref pm::regexp::RegexpInterface "метода разбора" \ref pm::stream::Stream "буферизованного потока":
 *  - Символы не читаются из потока и не возвращаются в поток.
 *  - Разбор всегда успешен, \ref GNNParsing "принимается" пустая строка.
 *  
 *  Выражения различаются и полностью определяются \ref PRSafety "способом изменения данных" \ref pm::regexp::Context "контекста".
 *  
 *  В документации интерфейса:
 *  - описывается способ изменения данных выражения, возвращаемого вызовом функции интерфейса;
 *  - используется терминология, введённая для \ref GNNData "данных" в целом и данных, доступных по \ref pm::type_abuse::DPtr "указателю на данные", в частности.
 *  - cd - обозначение текущих данных.
 *  - sd - обозначение сохранённых данных.
 *  
 *  \sa \ref PRList "Список готовых регулярных выражений"
 */

/*! \fn Regexp pm::regexp::cget()
 *  \anchor PRCGet
 *  \brief Копирование сохранённых данных в текущие данные.
 *  
 *  Способ изменения данных: текущие данные перезаписываются сохранёнными данными.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят и сохранённые данные непусты, то тип сохранённых данных \ref GNSLifetime "копируем".
 */

/*! \fn Regexp pm::regexp::sget()
 *  \anchor PRSGet
 *  \brief Копирование текущих данных в сохранённые данные.
 *  
 *  Способ изменения данных: сохранённые данные перезаписываются текущими данными.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят и текущие данные непусты, то тип текущих данных \ref GNSLifetime "копируем".
 */

/*! \fn Regexp pm::regexp::cset(Args && ... args)
 *  \anchor PRCSet
 *  \brief Переустановка текущих данных.
 *  
 *  Содержит объект типа \p T, инициализирующийся от \p args в момент создания выражения.
 *  
 *  Способ изменения данных: текущие данные перезаписываются содержащимся объектом.
 *  
 *  \pre Тип \p T \ref GNSLifetime "инициализируем" от аргументов \p args, \ref GNSLifetime "уничтожаем" и \ref GNSLifetime "копируем".
 */

/*! \fn Regexp pm::regexp::sset(Args && ... args)
 *  \anchor PRSSet
 *  \brief Переустановка сохранённых данных.
 *  
 *  Содержит объект типа \p T, инициализирующийся от \p args при создании выражения.
 *  
 *  Способ изменения данных: сохранённые данные перезаписываются содержащимся объектом.
 *  
 *  \pre Тип \p T \ref GNSLifetime "инициализируем" от аргументов \p args, \ref GNSLifetime "уничтожаем" и \ref GNSLifetime "копируем".
 */

/*! \fn Regexp pm::regexp::swap()
 *  \anchor PRSwap
 *  \brief Обмен текущих и сохранённых данных.
 *  
 *  Способ изменения данных: выполняется обмен текущих и сохранённых данных.
 */

/*! \fn Regexp pm::regexp::cunset()
 *  \anchor PRCUnset
 *  \brief Сброс текущих данных.
 *  
 *  Способ изменения данных: выполняется сброс текущих данных.
 */

/*! \fn Regexp pm::regexp::sunset()
 *  \anchor PRSUnset
 *  \brief Сброс сохранённых данных.
 *  
 *  Способ изменения данных: выполняется сброс сохранённых данных.
 */

/*! \fn Regexp pm::regexp::cadd()
 *  \anchor PRCAdd
 *  \brief Прибавление сохранённых данных к текущим данным.
 *  
 *  Способ изменения данных: выполняется выражение cd += sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p Left, а сохранённые - непусты и имеют тип \p Right.
 *  \pre Присваивание `a += b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cadd(Right && i)
 *  \anchor PRCAddConstant
 *  \brief Прибавление константы \p i к текущим данным.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение cd += o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты имеют тип \p Left.
 *  \pre Присваивание `a += b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cdiv()
 *  \anchor PRCDiv
 *  \brief Деление текущих данных на сохранённые данные.
 *  
 *  Способ изменения данных: выполняется выражение cd /= sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p Left, а сохранённые - непусты и имеют тип \p Right.
 *  \pre Присваивание `a /= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cdiv(Right && i)
 *  \anchor PRCDivConstant
 *  \brief Деление текущих данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение cd /= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты имеют тип \p Left.
 *  \pre Присваивание `a /= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cmod()
 *  \anchor PRCMod
 *  \brief Взятие остатка от деления текущих данных на сохранённые данные.
 *  
 *  Способ изменения данных: выполняется выражение cd %= sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p Left, а сохранённые - непусты и имеют тип \p Right.
 *  \pre Присваивание `a %= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cmod(Right && i)
 *  \anchor PRCModConstant
 *  \brief Взятие остатка от деления текущих данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение cd %= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты имеют тип \p Left.
 *  \pre Присваивание `a %= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cmul()
 *  \anchor PRCMul
 *  \brief Умножение текущих данных на сохранённые данные.
 *  
 *  Способ изменения данных: выполняется выражение cd *= sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p Left, а сохранённые - непусты и имеют тип \p Right.
 *  \pre Присваивание `a *= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cmul(Right && i)
 *  \anchor PRCMulConstant
 *  \brief Умножение текущих данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение cd *= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты имеют тип \p Left.
 *  \pre Присваивание `a *= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::csub()
 *  \anchor PRCSub
 *  \brief Вычитание сохранённых данных из текущих данных.
 *  
 *  Способ изменения данных: выполняется выражение cd -= sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p Left, а сохранённые - непусты и имеют тип \p Right.
 *  \pre Присваивание `a -= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::csub(Right && i)
 *  \anchor PRCSubConstant
 *  \brief Вычитание константы \p i из текущих данных.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение cd -= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты имеют тип \p Left.
 *  \pre Присваивание `a -= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::sadd()
 *  \anchor PRSAdd
 *  \brief Прибавление текущих данных к сохранённым данным.
 *  
 *  Способ изменения данных: выполняется выражение sd += cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left, а текущие - непусты и имеют тип \p Right.
 *  \pre Присваивание `a += b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::sadd(Right && i)
 *  \anchor PRSAddConstant
 *  \brief Прибавление константы \p i к сохранённым данным.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение sd += o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left.
 *  \pre Присваивание `a += b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::sdiv()
 *  \anchor PRSDiv
 *  \brief Деление сохранённых данных на текущие данные.
 *  
 *  Способ изменения данных: выполняется выражение sd /= cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left, а текущие - непусты и имеют тип \p Right.
 *  \pre Присваивание `a /= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::sdiv(Right && i)
 *  \anchor PRSDivConstant
 *  \brief Деление сохранённых данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение sd /= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left.
 *  \pre Присваивание `a /= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::smod()
 *  \anchor PRSMod
 *  \brief Взятие остатка от деления сохранённых данных на текущие данные.
 *  
 *  Способ изменения данных: выполняется выражение sd %= cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left, а текущие - непусты и имеют тип \p Right.
 *  \pre Присваивание `a %= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::smod(Right && i)
 *  \anchor PRSModConstant
 *  \brief Взятие остатка от деления сохранённых данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение sd %= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left.
 *  \pre Присваивание `a %= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::smul()
 *  \anchor PRSMul
 *  \brief Умножение сохранённых данных на текущие данные.
 *  
 *  Способ изменения данных: выполняется выражение sd *= cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left, а текущие - непусты и имеют тип \p Right.
 *  \pre Присваивание `a *= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::smul(Right && i)
 *  \anchor PRSMulConstant
 *  \brief Умножение сохранённых данных на константу \p i.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение sd *= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left.
 *  \pre Присваивание `a *= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::ssub()
 *  \anchor PRSSub
 *  \brief Вычитание текущих данных из сохранённых данных.
 *  
 *  Способ изменения данных: выполняется выражение sd -= cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left, а текущие - непусты и имеют тип \p Right.
 *  \pre Присваивание `a -= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::ssub(Right && i)
 *  \anchor PRSSubConstant
 *  \brief Вычитание константы \p i из сохранённых данных.
 *  
 *  Содержит объект o типа \p Right, инициализирующийся от \p i при создании выражения.
 *  
 *  Способ изменения данных: выполняется выражение sd -= o.
 *  
 *  \pre Тип \p Right \ref GNSLifetime "перемещаем".
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p Left.
 *  \pre Присваивание `a -= b` корректно для объекта `a` типа \p Left и объекта `b` типа \p Right.
 */

/*! \fn Regexp pm::regexp::cchar_to_digit()
 *  \anchor PRCCharToDigit
 *  \brief Преобразование символа цифры в число в текущих данных.
 *  
 *  Способ изменения данных: в текущие данные устанавливается значение типа \p Int от аргумента (cd - '0').
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип `char`.
 *  \pre Тип \p Int \ref GNSLifetime "инициализируем" от значения типа `char` и \ref GNSLifetime "уничтожаем".
 */

/*! \fn Regexp pm::regexp::cchar_to_string()
 *  \anchor PRCCharToString
 *  \brief Преобразование символа в строку в текущих данных.
 *  
 *  Способ изменения данных: в текущие данные устанавливается значение типа `std::string` от аргументов 1, cd.
 *  
 *  std::string(1, c) - это строка длины 1, состоящая из единственного символа c.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип `char`.
 */

/*! \fn Regexp pm::regexp::cconvert()
 *  \anchor PRCConvert
 *  \brief Прямое преобразование типа текущих данных.
 *  
 *  Способ изменения данных: в текущие данные устанавливается значение типа \p To от аргумента cd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то текущие данные непусты и имеют тип \p From.
 *  \pre Тип \p To \ref GNSLifetime "инициализируем" от значения типа \p From и \ref GNSLifetime "уничтожаем".
 */

/*! \fn Regexp pm::regexp::schar_to_digit()
 *  \anchor PRSCharToDigit
 *  \brief Преобразование символа цифры в число в сохранённых данных.
 *  
 *  Способ изменения данных: в сохранённые данные устанавливается значение типа \p Int от аргумента (sd - '0').
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип `char`.
 *  \pre Тип \p Int \ref GNSLifetime "инициализируем" от значения типа `char` и \ref GNSLifetime "уничтожаем".
 */

/*! \fn Regexp pm::regexp::schar_to_string()
 *  \anchor PRSCharToString
 *  \brief Преобразование символа в строку в сохранённых данных.
 *  
 *  Способ изменения данных: в сохранённые данные устанавливается значение типа `std::string` от аргументов 1, sd.
 *  
 *  std::string(1, c) - это строка длины 1, состоящая из единственного символа c.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип `char`.
 */

/*! \fn Regexp pm::regexp::sconvert()
 *  \anchor PRSConvert
 *  \brief Прямое преобразование типа сохранённых данных.
 *  
 *  Способ изменения данных: в сохранённые данные устанавливается значение типа \p To от аргумента sd.
 *  
 *  \pre В начале разбора: если флаг активности данных поднят, то сохранённые данные непусты и имеют тип \p From.
 *  \pre Тип \p To \ref GNSLifetime "инициализируем" от значения типа \p From и \ref GNSLifetime "уничтожаем".
 */
