/*! \file include/pm/regexp/expressions/flow/control.hpp
 *  \brief Содержит интерфейс создания \ref PRLFlControl "готовых регулярных выражений для комбинирования подразборов".
 *  \ingroup ModuleRegexp
 *  
 *  Все \ref pm::regexp::Regexp "регулярные выражения", созданные согласно документации интерфейса, \ref PRSafety "безопасны".
 *  
 *  В выражении содержится упорядоченный набор *подвыражений*, над которым строится выражение.
 *  
 *  Выполнение \ref pm::regexp::RegexpInterface "метода разбора" \ref pm::stream::Stream "буферизованного потока" выражением - это последовательный запуск разборов потока подвыражениями и комбинация результатов этих запусков.
 *  
 *  *Подразбор* - это разбор подвыражением в рамках разбора выражением.
 *  
 *  В документации интерфейса описывается то, как устроен метод разбора регулярным выражением, возвращаемым функцией или оператором интерфейса.
 *  
 *  \sa \ref GNNParsing "Принимаемая строка"
 *  \sa \ref PRSafety "Способ изменения данных"
 *  \sa \ref pm::regexp::Context "Регулярный контекст разбора"
 *  \sa \ref PRList "Список готовых регулярных выражений"
 */

/*! \name Альтернатива
 *  \anchor PRAlternative
 *  Последовательно по порядку запускаются разборы подвыражениями до выполнения одного из двух условий:
 *  - Получен успешный подразбор.
 *  - Все подразборы оказались неуспешными.
 *  
 *  Разбор альтернативой успешен <=> получен успешный подразбор.
 *  
 *  При успешном разборе альтернативой:
 *  - Принятая строка - это строка, принятая успешным подразбором.
 *  - Способ изменения данных: текущие и сохранённые данные контекста изменяются успешным подразбором.
 *  
 *  \pre Все подвыражения альтернативы \ref PRSafety "безопасны"
 *  \pre Выражение, возвращаемое вызовом функции или оператора интерфейса, не используется (прямо или косвенно) в аргументах вызова
 */
//!\{

  /*! \fn Regexp pm::regexp::alt(const std::list<Regexp> & rl)
   *  \brief Подвыражения: содержащиеся в списке \p rl, в том же порядке.
   */

  /*! \fn Regexp pm::regexp::alt(std::list<Regexp> && rl)
   *  \brief Подвыражения: содержащиеся в списке \p rl, в том же порядке.
   */

  /*! \fn Regexp pm::regexp::alt(Args && ... args)
   *  \brief Подвыражения: содержащиеся в списке {\p args ...}, в том же порядке.
   *  Эквивалентно выражению `alt(std::list<Regexp>{std::forward<Args>(args) ...})`.
   *  Позволяет вместо alt({r1, r2, ..., rk}) писать alt(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r1, const Regexp & r2)
   *  \brief Подвыражения: \p r1, \p r2.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r1, Regexp && r2)
   *  \brief Подвыражения: \p r1, \p r2.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r1, const Regexp & r2)
   *  \brief Подвыражения: \p r1, \p r2.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r1, Regexp && r2)
   *  \brief Подвыражения: \p r1, \p r2.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r, char c)
   *  \brief Подвыражения: \p r; \ref PRGivenCharacter "символ" \p c.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r, char c)
   *  \brief Подвыражения: \p r; \ref PRGivenCharacter "символ" \p c.
   */

  /*! \fn Regexp pm::regexp::operator |(char c, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenCharacter "символ" \p c; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(char c, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenCharacter "символ" \p c; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r, const std::set<char> & s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r, std::set<char> && s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r, const std::set<char> & s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r, std::set<char> && s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(const std::set<char> & s, const Regexp & r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(const std::set<char> & s, Regexp && r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(std::set<char> && s, const Regexp & r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(std::set<char> && s, Regexp && r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r, const std::string & s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(const Regexp & r, std::string && s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r, const std::string & s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(Regexp && r, std::string && s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator |(const std::string & s, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(const std::string & s, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(std::string && s, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator |(std::string && s, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

//!\}

/*! \name Конкатенация
 *  \anchor PRConcatenation
 *  Последовательно по порядку запускаются разборы подвыражениями до выполнения одного из двух условий:
 *  - Получен неуспешный подразбор.
 *  - Все подразборы оказались успешными.
 *  
 *  Разбор конкатенацией успешен <=> все подразборы успешны.
 *  
 *  При успешном разборе конкатенацией:
 *  - Принятая строка - это конкатенация всех строк, принятых по итогам подразборов: строка \f$ s_1 s_2 \dots s_k \f$, где
 *   - \f$ s_i \f$ - строка, принятая при разборе \f$ i \f$-м подвыражением, и
 *   - \f$ k \f$ - количество содержащихся подвыражений.
 *  - Способ изменения данных: текущие и сохранённые данные контекста последовательно изменяются подразборами (данные в начале следующего подразбора - это данные в конце предыдущего подразбора).
 *  
 *  \pre Если текущие данные контекста непусты в начале разбора конкатенацией, то тип этих данных \ref GNSLifetime "копируем".
 *  \pre Если сохранённые данные контекста непусты в начале разбора конкатенацией, то тип этих данных \ref GNSLifetime "копируем".
 *  \pre Все подвыражения конкатенации \ref PRSafety "безопасны"
 *  \pre Выражение, возвращаемое вызовом функции или оператора интерфейса, не используется (прямо или косвенно) в аргументах вызова
 */
//!\{

  /*! \fn Regexp pm::regexp::concat(const std::list<Regexp> & rl)
   *  \brief Подвыражения: содержащиеся в \p rl, в том же порядке.
   */

  /*! \fn Regexp pm::regexp::concat(std::list<Regexp> && rl)
   *  \brief Подвыражения: содержащиеся в \p rl, в том же порядке.
   */

  /*! \fn Regexp pm::regexp::concat(Args && ... args)
   *  \brief Подвыражения: содержащиеся в {\p args ...}, в том же порядке.
   *  Эквивалентно выражению `concat(std::list<Regexp>{std::forward<Args>(args) ...})`.
   *  Позволяет вместо concat({r1, r2, ..., rk}) писать concat(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r1, const Regexp & r2)
   *  \brief Подвыражения: \p r1; \p r2.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r1, Regexp && r2)
   *  \brief Подвыражения: \p r1; \p r2.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r1, const Regexp & r2)
   *  \brief Подвыражения: \p r1; \p r2.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r1, Regexp && r2)
   *  \brief Подвыражения: \p r1; \p r2.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r, char c)
   *  \brief Подвыражения: \p r; \ref PRGivenCharacter "символ" \p c.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r, char c)
   *  \brief Подвыражения: \p r; \ref PRGivenCharacter "символ" \p c.
   */

  /*! \fn Regexp pm::regexp::operator &(char c, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenCharacter "символ" \p c; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(char c, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenCharacter "символ" \p c; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r, const std::set<char> & s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r, std::set<char> && s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r, const std::set<char> & s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r, std::set<char> && s)
   *  \brief Подвыражения: \p r; \ref PRCharacterOfGivenSet "символ множества" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(const std::set<char> & s, const Regexp & r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(const std::set<char> & s, Regexp && r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(std::set<char> && s, const Regexp & r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(std::set<char> && s, Regexp && r)
   *  \brief Подвыражения: \ref PRCharacterOfGivenSet "символ множества" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r, const std::string & s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(const Regexp & r, std::string && s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r, const std::string & s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(Regexp && r, std::string && s)
   *  \brief Подвыражения: \p r; \ref PRGivenString "строка" \p s.
   */

  /*! \fn Regexp pm::regexp::operator &(const std::string & s, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(const std::string & s, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(std::string && s, const Regexp & r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

  /*! \fn Regexp pm::regexp::operator &(std::string && s, Regexp && r)
   *  \brief Подвыражения: \ref PRGivenString "строка" \p s; \p r.
   */

//!\}

/*! \name Разность
 *  \anchor PRDifference
 *  Содержит два подвыражения: *положительное* и *отрицательное*.
 *  
 *  Запускается разбор положительным подвыражением.
 *  В случае успеха запускается метод разбора отрицательного подвыражения для строки, принятой положительным подвыражением, и \ref pm::regexp::default_context "контекста по умолчанию".
 *  
 *  Разбор разностью успешен <=> разбор положительным подвыражением успешен, и разбор отрицательным подвыражением
 *  - либо неуспешен,
 *  - либо успешен, но им принята не вся разбираемая строка.
 *  
 *  При успешном разборе разностью:
 *  - Принятая строка - это строка, принятая положительным подвыражением
 *  - Способ изменения данных: текущие и сохранённые данные контекста изменяются положительным подвыражением.
 *  
 *  \pre Если текущие данные контекста непусты в начале разбора разностью, то тип этих данных \ref GNSLifetime "копируем".
 *  \pre Если сохранённые данные контекста непусты в начале разбора разностью, то тип этих данных \ref GNSLifetime "копируем".
 *  \pre Оба подвыражения разности \ref PRSafety "безопасны".
 *  \pre Выражение, возвращаемое вызовом функции или оператора интерфейса, не используется (прямо или косвенно) в аргументах вызова
 */
//!\{

/*! \fn Regexp pm::regexp::but(const Regexp & positive, const Regexp & negative)
 *  \brief Положительное подвыражение: \p positive. Отрицательное подвыражение: \p negative.
 */

/*! \fn Regexp pm::regexp::but(const Regexp & positive, Regexp && negative)
 *  \brief Положительное подвыражение: \p positive. Отрицательное подвыражение: \p negative.
 */

/*! \fn Regexp pm::regexp::but(Regexp && positive, const Regexp & negative)
 *  \brief Положительное подвыражение: \p positive. Отрицательное подвыражение: \p negative.
 */

/*! \fn Regexp pm::regexp::but(Regexp && positive, Regexp && negative)
 *  \brief Положительное подвыражение: \p positive. Отрицательное подвыражение: \p negative.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r1, const Regexp & r2)
 *  \brief Положительное подвыражение: \p r1. Отрицательное подвыражение: \p r2.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r1, Regexp && r2)
 *  \brief Положительное подвыражение: \p r1. Отрицательное подвыражение: \p r2.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r1, const Regexp & r2)
 *  \brief Положительное подвыражение: \p r1. Отрицательное подвыражение: \p r2.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r1, Regexp && r2)
 *  \brief Положительное подвыражение: \p r1. Отрицательное подвыражение: \p r2.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, char c)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenCharacter "символ" \p c.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, char c)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenCharacter "символ" \p c.
 */

/*! \fn Regexp pm::regexp::operator -(char c, const Regexp & r)
 *  \brief Положительное подвыражение: \ref PRGivenCharacter "символ" \p c. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(char c, Regexp && r)
 *  \brief Положительное подвыражение: \ref PRGivenCharacter "символ" \p c. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, const std::set<char> & s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, std::set<char> && s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, const std::set<char> & s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, std::set<char> && s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(const std::set<char> & s, const Regexp & r)
 *  \brief Положительное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(const std::set<char> & s, Regexp && r)
 *  \brief Положительное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(std::set<char> && s, const Regexp & r)
 *  \brief Положительное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(std::set<char> && s, Regexp && r)
 *  \brief Положительное подвыражение: \ref PRCharacterOfGivenSet "символ множества" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, const std::string & s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenString "строка" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, std::string && s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenString "строка" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, const std::string & s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenString "строка" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, std::string && s)
 *  \brief Положительное подвыражение: \p r. Отрицательное подвыражение: \ref PRGivenString "строка" \p s.
 */

/*! \fn Regexp pm::regexp::operator -(const std::string & s, const Regexp & r)
 *  \brief Положительное подвыражение: \ref PRGivenString "строка" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(const std::string & s, Regexp && r)
 *  \brief Положительное подвыражение: \ref PRGivenString "строка" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(std::string && s, const Regexp & r)
 *  \brief Положительное подвыражение: \ref PRGivenString "строка" \p s. Отрицательное подвыражение: \p r.
 */

/*! \fn Regexp pm::regexp::operator -(std::string && s, Regexp && r)
 *  \brief Положительное подвыражение: \ref PRGivenString "строка" \p s. Отрицательное подвыражение: \p r.
 */

//!\}

/*! \name Звезда Клини
 *  \anchor PRKleeneStar
 *  Содержит одно подвыражение \p r.
 *  
 *  Многократно до первого неуспеха запускается разбор подвыражением.
 *  
 *  Разбор звездой Клини всегда успешен.
 *  
 *  Принятая строка - это конкатенация строк, принятых успешными подразборами в порядке выполнения: строка \f$ s_1 s_2 \dots s_k \f$, где
 *  - \f$ s_i \f$ - строка, принятая \f$ i \f$-м успешным подразбором;
 *  - \f$ k \f$ - общее число успешных подразборов.
 *  
 *  Способ изменения данных: текущие и сохранённые данные контекста последовательно изменяются успешными подразборами (данные в начале следующего подразбора - это данные в конце предыдущего подразбора).
 *  
 *  \pre Подвыражение звезды Клини \ref PRSafety "безопасно".
 *  \pre Выражение, возвращаемое вызовом функции или оператора интерфейса, не используется (прямо или косвенно) в аргументе вызова
 */
//!\{

  /*! \fn Regexp pm::regexp::star(const Regexp & r)
   */
  /*! \fn Regexp pm::regexp::star(Regexp && r)
   */
  /*! \fn Regexp pm::regexp::operator *(const Regexp & r)
   */
  /*! \fn Regexp pm::regexp::operator *(Regexp && r)
   */

//!\}

/*! \name Опционал
 *  \anchor PROptional
 *  Содержит одно подвыражение \p r.
 *  
 *  Один раз запускается разбор подвыражением.
 *  
 *  Разбор опционалом всегда успешен.
 *  
 *  Принятая строка - это:
 *  - Строка, принятая подразбором, если подразбор успешен.
 *  - Пустая строка, если подразбор неуспешен.
 *  
 *  Способ изменения данных:
 *  - Если подразбор успешен, то текущие и сохранённые данные контекста изменяются подвыражением.
 *  - Если подразбор неуспешен, то текущие и сохранённые данные контекста не изменяются.
 *  
 *  \pre Подвыражение опционала \ref PRSafety "безопасно".
 *  \pre Выражение, возвращаемое вызовом функции или оператора интерфейса, не используется (прямо или косвенно) в аргументе вызова
 */
//!\{

  /*! \fn Regexp pm::regexp::opt(const Regexp & r)
   */
  /*! \fn Regexp pm::regexp::opt(Regexp && r)
   */
  /*! \fn Regexp pm::regexp::operator !(const Regexp & r)
   */
  /*! \fn Regexp pm::regexp::operator !(Regexp && r)
   */

//!\}
