/*! \file include/pm/data.hpp
 *  \brief Содержит класс данных pm::Data.
 */

/*! \class pm::Data
 *  \brief Класс данных.
 *  
 *  
 *  *Данные* - это контейнер, в целом аналогичный стандартному контейнеру std::any.
 *  
 *  В контейнере данных во время выполнения программы *хранится* не более одного объекта произвольного \ref DObjectModification "уничтожимого" типа, и при этом наличие, тип и значение объекта могут произвольно изменяться во время выполнения.
 *  
 *  Данные *непусты*, если в этом контейнере хранится какой-либо объект, и *пусты* иначе.
 *  
 *  *Опциональным объектом* в документации называется объект в обычном понимании, а также специальный *пустой объект*, обозначающий отсутствие объекта в данных.
 *  Эта терминология используется для краткости:
 *  в данных d всегда хранится ровно один опциональный объект \<d\>.
 *  
 *  *Копия* пустого объекта - это пустой объект (по аналогии с \ref DObjectModification "копией" обычного объекта).
 *  
 *  В числе прочих, над данными d можно производить следующие операции:
 *  - *Вставка* опционального объекта o: после вставки данные d хранят опциональный объект o.
 *  - *Перенаполнение* опциональным объектом o:
 *   - если данные d непусты, то объект \<d\> \ref DObjectModification "уничтожается";
 *   - в данные d вставляется опциональный объект o.
 *  - *Опустошение*: перенаполнение пустым объектом.
 *  - *Обмен* с данными d': объект \<d\> вставляется в данные d', и одновременно с этим объект \<d'\> вставляется в данные d.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref DValidState "Стандартно-корректен".
 *  
 *  Специальные методы
 *  ==
 *  
 *      Data()
 *  
 *  Инициализировать пустые данные.
 *  
 *  
 *      Data(const Data & d)
 *  
 *  \pre Если данные \p d непусты, то тип объекта \<\p d\> \ref DObjectModification "копируем".
 *  
 *  Инициализировать данные, хранящие новую \ref DObjectModification "копию" опционального объекта \<\p d\>.
 *  
 *  
 *      Data(Data && d)
 *  
 *  Инициализировать данные, хранящие объект \<\p d\>.
 *  
 *  Данные \<\p d\> становятся пустыми. 
 *  
 *  
 *      Data & operator =(const Data & d)
 *  
 *  \pre Если данные \p d непусты, то тип объекта \<\p d\> \ref DObjectModification "копируем".
 *  
 *  Перенаполнить \ref DSelf "self" новой \ref DObjectModification "копией" опционального объекта \<\p d\>.
 *  
 *  \return Self.
 *  
 *  
 *      Data & operator =(Data && d)
 *  
 *  Перенаполнить \ref DObjectModification "self" опциональным объектом \<\p d\>
 *  
 *  Данные \p d становятся пустыми.
 *  
 *  \return Self.
 *  
 *  
 *      ~Data()
 *  
 *  Уничтожить данные.
 *  Если данные непусты, то объект \<\ref DSelf "self"\> уничтожается.
 */

/*! \fn void pm::Data::emplace(Args && ... args)
 *  \brief Перенаполнить данные новым объектом типа \p T, \ref DObjectModification "инициализированным" от \p args \ref DPerfectForwarding "идеальной пересылкой".
 *  
 *  \pre Тип \p T \ref DObjectModification "инициализируем" от идеально пересланных аргументов \p args и \ref DObjectModification "уничтожим".
 */

/*! \fn void pm::Data::swap(Data & d)
 *  \brief Обменять данные \ref DSelf "self" с данными \p d.
 */

/*! \fn void pm::Data::reset()
 *  \brief Опустошить данные.
 */

/*! \fn bool pm::Data::has_value() const
 *  \brief Вернуть true <=> данные непусты.
 */

/*! \fn T & pm::Data::value()
 *  \brief Вернуть ссылку на объект \<\ref DSelf "self"\>.
 *  
 *  \pre Данные D непусты.
 *  \pre Тип объекта \<self\> - в точности \p T.
 */

/*! \fn const T & pm::Data::value() const
 *  \brief Вернуть ссылку на объект \<\ref DSelf "self"\>.
 *  
 *  \pre Данные D непусты.
 *  \pre Тип объекта \<self\> - в точности \p T.
 */

/*! \fn Data pm::Data::make(Args && ... args)
 *  \brief Вернуть новые непустые данные, хранящие новый объект типа \p T, \ref DObjectModification "инициализированный" от \p args \ref DPerfectForwarding "идеальной пересылкой".
 *  
 *  \pre Тип \p T \ref DObjectModification "инициализируем" от идеально пересланных аргументов \p args и \ref DObjectModification "уничтожим".
 */

/*! \fn void pm::swap(Data & d1, Data & d2)
 *  \brief Обменять данные \p d1 с данными \p d2.
 */
