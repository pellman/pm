/*! \file include/pm/regex/regex.hpp
 *  \brief Содержит класс регулярных выражений pm::regex::Regex.
 *  \ingroup ModuleRegex
 */

/*! \class pm::regex::Regex
 *  \brief Класс регулярных выражений.
 *  \ingroup ModuleRegex
 *  
 *  
 *  Перед изучением этого класса полезно прочитать \ref PIRegex "общие слова о регулярных выражениях".
 *  
 *  *Процедура регулярного разбора* - это \ref ParseProcedure "процедура разбора", в качестве контекста разбора принимающая на вход \ref pm::regex::Context "регулярный контекст данных".
 *  Устройство документированных методов регулярного выражения полностью определяется этой процедурой.
 *  Процедуры регулярного разбора (и способы комбинирования таких процедур) документированы для \ref MRSpec "реализованных регулярных выражений".
 *  
 *  Остальные детали устройства класса, кроме упомянутых на этой странице, в целом неважны для работы с регулярными выражениями.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref DValidState "Нестандартно-корректен".
 *  
 *  Копирование, перемещение и присваивание регулярных выражений настолько же "легковесно", насколько и соответствующие операции над умными указателями std::shared_ptr.
 *  
 *  Неявные методы
 *  ==
 *  
 *      Regex(const Regex & r)
 *      Regex(Regex && r)
 *  
 *  Инициализировать копию/перемещение текущего значения выражения \p r.
 *  
 *  
 *      Regex & operator =(const Regex & r)
 *      Regex & operator =(Regex && r)
 *  
 *  Присвоить выражению \ref DSelf "self" текущее значение выражения \p r.
 *  
 *  \return Self.
 *  
 *  
 *      ~Regex()
 *  
 *  Уничтожить выражение.
 */

/*! \fn pm::regex::Regex::Regex()
 *  \brief Инициализировать регулярное выражение \ref MRFalse "Неуспех".
 */

/*! \fn bool pm::regex::Regex::match(std::istream & is) const
 *  \brief Метод разбора \ref DTypes "стандартного потока ввода" \p is.
 *  
 *  \pre Поток \p is \ref BusyStream "свободен".
 *  
 *  Создаются новый \ref pm::stream::Stream "поток разбора" S, инициализированный от \p is, и новый \ref pm::regex::DataContext "регулярный контекст данных" C по умолчанию.
 *  
 *  Выполняется *подразбор*: процедура разбора потока S в контексте C.
 *  
 *  Поток S и контекст C уничтожаются.
 *  
 *  \return Итог подразбора.
 *  
 *  **Замечание:** по итогам разбора из потока is может быть прочитано больше символов, чем из инициализированного потока S (см. \ref pm::stream::Stream "документацию потоков разбора").
 */

/*! \fn bool pm::regex::Regex::match(std::istream & is, Context & context) const
 *  \brief Метод разбора \ref DTypes "стандартного потока ввода" \p is в \ref pm::regex::Context "регулярном контексте" \p context.
 *  
 *  \pre Поток \p is \ref BusyStream "свободен".
 *  
 *  Создаётся новый \ref pm::stream::Stream "поток разбора" S, инициализированный от \p is.
 *  
 *  Выполняется *подразбор*: процедура разбора потока S в подконтексте данных контекста \p context.
 *  
 *  Содержимое контекста \p context изменяется согласно \ref pm::regex::Context "смыслу контекста".
 *  
 *  Поток S уничтожается.
 *  
 *  \return Итог подразбора.
 *  
 *  **Замечание:** по итогам разбора из потока is может быть прочитано больше символов, чем из инициализированного потока S (см. \ref pm::stream::Stream "документацию потоков разбора").
 */

/*! \fn bool pm::regex::Regex::match(stream::Stream & is) const
 *  \brief Метод разбора \ref pm::stream::Stream "потока разбора" \p is.
 *  
 *  Создаётся новый \ref pm::regex::DataContext "регулярный контекст данных" C по умолчанию.
 *  
 *  Выполняется *подразбор*: процедура разбора потока \p is в контексте C.
 *  
 *  Контекст C уничтожается.
 *  
 *  \return Итог подразбора.
 */

/*! \fn bool pm::regex::Regex::match(stream::Stream & is, Context & context) const
 *  \brief Метод разбора \ref pm::stream::Stream "потока разбора" \p is в \ref pm::regex::Context "регулярном контексте" \p context.
 *  
 *  Выполняется *подразбор*: процедура разбора потока \p is в подконтексте данных контекста \p context.
 *  
 *  Содержимое контекста \p context изменяется согласно \ref pm::regex::Context "смыслу контекста".
 *  
 *  \return Итог подразбора.
 */

/*! \fn bool pm::regex::Regex::match(stream::Stream & is, DataContext & context) const
 *  \brief Процедура разбора \ref pm::stream::Stream "потока разбора" \p is в \ref pm::regex::DataContext "регулярном контексте данных" \p context.
 *  
 *  \return Итог разбора.
 */
