/*! \file include/pm/stream/stream.hpp
 *  \brief Содержит класс потоков разбора pm::stream::Stream.
 *  \ingroup ModuleStream
 */

/*! \class pm::stream::Stream
 *  \brief Класс потоков разбора.
 *  \ingroup ModuleStream
 *  
 *  
 *  *Поток разбора* - это неформатированный поток ввода, надстраивающийся над произвольным \ref DTypes "стандартным потоком ввода" и предоставляющий возможность многократного чтения \ref DTypes "символов" и \ref DTypes "строк" из is.
 *  Неформатированность потока разбора означает то же, что и неформатированность методов std::istream::get и std::istream::read.
 *  
 *  Обозначения для потоков
 *  ==
 *  
 *  Каждому стандартному потоку ввода S и каждому потоку разбора S в документации сопоставляется (конечная или бесконечная) последовательность символов S[0] S[1] S[2] ... (*символов потока*):
 *  - Содержательно, это последовательность символов, успешно читаемых из потока, в порядке их чтения.
 *  - Для стандартного потока ввода это последовательность символов, \ref DTypes "успешно читаемых" из потока методами std::istream::get и std::istream::read.
 *   При этом полагается, что успешность чтения следующего символа и значение этого символа зависят только от количества ранее прочитанных символов - в противном случае сопоставленная последовательность символов определяется неоднозначно.
 *  - В частности:
 *   - последовательность символов строкового потока ввода (std::stringstream) - это все символы строки, от которой инициализирован поток, в порядке следования;
 *   - последовательность символов файлового потока ввода (std::ifstream), открытого для текстового файла, доступного и неизменного во время работы с потоком, - это символы файла в порядке следования.
 *  
 *  Для потока S и \ref DTypes "индексов" i, j записью S[i:j] обозначается строка, состоящая из символов S[i], S[i+1], ..., S[j] в том же порядке (пустая строка, если j < i).
 *  
 *  \anchor StreamCluster
 *  Кластеры разбора
 *  ==
 *  
 *  Каждый поток разбора принадлежит ровно одному *кластеру разбора* стандартного потока ввода is.
 *  Кластер создаётся особыми методами потоков разбора.
 *  Кластеру может принадлежать несколько потоков разбора.
 *  Кластер уничтожается, когда в нём не остаётся ни одного потока разбора.
 *  
 *  \anchor BusyStream
 *  Поток is *связан*, если для него существует кластер разбора, и *свободен* иначе.
 *  
 *  **Запрещено** какое бы то ни было взаимодействовие со связанным потоком is, кроме взаимодействия через методы потоков разбора согласно документации - в противном случае результат работы с is может быть непредсказуемым.
 *  В том числе запрещено чтение символов is сторонними методами и уничтожение is.
 *  Точное количество символов, фактически прочитанных из is после уничтожения кластера, не специфицировано:
 *  из is может быть прочитано больше символов, чем предполагает пользователь библиотеки.
 *  
 *  Для каждого кластера C (потока is) определена *базовая последовательность* символов C[0] C[1] C[2] ... .
 *  Эта последовательность неизменна от создания до уничтожения кластера и совпадает с последовательностью символов потока is в момент создания кластера.
 *  
 *  Потоки разбора
 *  ==
 *  
 *  *Поток разбора* определяется:
 *  - кластером C, которому принадлежит поток;
 *  - *позицией потока*: \ref pm::stream::Position "позицией", принадлежащей кластеру C;
 *  - (опционально) *границей потока*: позицией, принадлежащей кластеру C и не меньшей позиции потока.
 *  
 *  Последовательность символов потока S с позицией i и (опционально) границей j, принадлежащего кластеру C, имеет следующий вид:
 *  - C[i] C[i+1] C[i+2] ... , если граница отсутствует
 *   - (пустая последовательность, если количество символов базовой последовательности кластера не превосходит i);
 *  - C[i] C[i+1] C[i+2] ... C[j-1], если граница присутствует
 *   - (пустая последовательность, если i == j).
 *  
 *  Поток разбора S *пуст*, если последовательность символов потока пуста, и *непуст* иначе.
 *  
 *  \anchor ParseProcedure
 *  Процедура разбора
 *  ==
 *  
 *  *Процедурой разбора* в документации называется процедура, принимающая на вход поток разбора и другие объекты (*контекст разбора*), изменяющая поток и контекст и возвращающая *итог разбора*: \ref DTypes "флаг", поднятый при *успешном разборе* и опущенный при *неуспешном разборе*.
 *  *Разбором* называется выполнение процедуры разбора.
 *  
 *  Содержательный смысл контекста разбора:
 *  им определяется вид "полезной информации", генерируемой при разборе строки, и сгенерированная информация по завершении разбора записывается в него же.
 *  
 *  В документации обсуждаются только процедуры разбора, обладающие следующими свойствами *корректности*:
 *  - Если разбор неуспешен, то поток не изменяется процедурой.
 *  - После разбора поток имеет произвольную позицию, не меньшую позиции до разбора, и это единственное различие значений потока до и после разбора.
 *  
 *  По завершении успешного корректного разбора определяется *принятая строка*.
 *  Содержательно, это строка, суммарно прочитанная из потока при разборе.
 *  Более строго, если в начале такого разбора последовательность символов потока имеет вид S[0] S[1] S[2] ... и разность позиций в начале и в конце разбора равна k, то принятая строка равна S[0:k-1].
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref DValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *      Stream()
 *  
 *  Удалён.
 *  
 *  
 *      Stream(const Stream & is)
 *      Stream(Stream && is)
 *  
 *  Инициализировать поток разбора в кластере потока \p is, записав в него копию/перемещение позиции и границы потока \p is.
 *  
 *  При перемещении поток \p is удаляется из своего текущего кластера.
 *  
 *  
 *      Stream & operator =(const Stream & is)
 *      Stream & operator =(Stream && is)
 *  
 *  Переместить \ref DSelf "self" в кластер потока \p is и перезаписать его содержимое (позицию, границу) копией/перемещением содержимого потока \p is.
 *  
 *  При перемещении поток \p is удаляется из своего текущего кластера.
 *  
 *  \return Self.
 *  
 *  
 *      ~Stream()
 *  
 *  Уничтожить поток (и удалить его из текущего кластера).
 */

/*! \fn pm::stream::Stream::Stream(std::istream & is)
 *  \brief Создать новый кластер потока \p is, добавить \ref DSelf "self" в этот кластер и инициалазировать self позицией 0 и отсутствующей границей.
 *  
 *  \pre Поток \p is свободен.
 *  \pre См. \ref BusyStream "запреты" на взаимодействие с \p is до уничтожения кластера.
 */

/*! \fn pm::stream::Stream::Stream(std::istream & is, size_t buffer_chunk_size)
 *  \brief Этот конструктор следует использовать только в том случае, если работа с потоком разбора, инициализированным без явного указания параметра \p buffer_chunk_size, оказалась крайне неэффективной.
 *  
 *  Создать новый кластер потока \p is, добавить \ref DSelf "self" в этот кластер и инициалазировать self позицией 0 и отсутствующей границей.
 *  
 *  \pre Поток \p is свободен.
 *  \pre См. \ref BusyStream "запреты" на взаимодействие с \p is до уничтожения кластера.
 *  
 *  Краткое пояснение смысла параметра \p buffer_chunk_size:
 *  - (недокументированный) буфер, позволяющий перепрочитывать символы, прочитанные из \p is, сейчас реализован как общий для кластера список *блоков*: непрерывных массивов фиксированного размера;
 *  - параметром \p buffer_chunk_size задаётся размер блока;
 *  - чем больше этот параметр, тем реже будут создаваться новые блоки, но тем крупнее будут выделяемые под буфер непрерывные участки памяти.
 */

/*! \fn bool pm::stream::Stream::advance()
 *  \brief Продвинуться к следующему символу потока.
 *  
 *  Продвижение успешно <=> поток непуст.
 *  
 *  Если продвижение успешно, то позиция потока увеличивается на 1.
 *  
 *  \return Продвижение успешно.
 */

/*! \fn bool pm::stream::Stream::advance(size_t size)
 *  \brief Продвинуться на \p size символов потока.
 *  
 *  Продвижение успешно <=> поток содержит хотя бы \p size символов.
 *  
 *  Если продвижение успешно, то позиция потока увеличивается на \p size.
 *  
 *  \return Продвижение успешно.
 */

/*! \fn size_t pm::stream::Stream::advance_at_most(size_t size)
 *  \brief Продвинуться не более чем на \p size символов потока.
 *  
 *  Позиция потока увеличивается на k, где k - наименьшее из чисел: \p size; число символов потока S.
 *  
 *  \return k.
 */

/*! \fn bool pm::stream::Stream::get(char & c)
 *  \brief Прочитать следующий символ.
 *  
 *  Чтение успешно <=> поток непуст.
 *  
 *  Если чтение успешно, то:
 *  - в \p c записывается символ \ref DSelf "self"[0];
 *  - затем позиция потока увеличивается на 1.
 *  
 *  \return Чтение успешно.
 */

/*! \fn bool pm::stream::Stream::get(std::string & s, size_t size)
 *  \brief Прочитать следующие \p size символов.
 *  
 *  Чтение успешно <=> в потоке содержится хотя бы \p size символов.
 *  
 *  Если чтение успешно, то:
 *  - в \p s записывается строка \ref DSelf "self"[0:\p size-1];
 *  - затем позиция потока увеличивается на \p size.
 *  
 *  \return Чтение успешно.
 */

/*! \fn void pm::stream::Stream::get(std::string & s, const Position & bound)
 *  \brief Прочитать следующие символы потока до позиции \p bound.
 *  
 *  \pre Позиция \p bound принадлежит кластеру потока.
 *  \pre Для позиции p потока верно p <= \p bound.
 *  \pre Если поток содержит границу b, то \p bound <= b.
 *  
 *  В \p s записывается строка \ref DSelf "self"[0:\p bound - p - 1], где p - позиция потока.
 *  
 *  Затем позиция потока перезаписывается значением \p bound.
 */

/*! \fn void pm::stream::Stream::get_at_most(std::string & s, size_t size)
 *  \brief Прочитать не более \p size следующих символов потока.
 *  
 *  В \p s записывается строка \ref DSelf "self"[0:k-1], где k - наименьшее из чисел: \p size; число символов потока S.
 *  
 *  Позиция потока увеличивается на k.
 */

/*! \fn void pm::stream::Stream::reposition(Position pos)
 *  \brief Перезаписать позицию потока значением \p pos.
 *  
 *  \pre Позиция \p pos принадлежит кластеру потока.
 *  \pre Если поток содержит границу b, то \p pos <= b.
 */

/*! \fn bool pm::stream::Stream::empty() const
 *  \brief Вернуть true <=> поток пуст.
 */

/*! \fn bool pm::stream::Stream::peek(char & c) const
 *  \brief Подглядеть следующий символ потока.
 *  
 *  Подглядывание успешно <=> поток непуст.
 *  
 *  Если подглядывание успешно, то в \p c записывается символ \ref DSelf "self"[0].
 *  
 *  \return Подглядывание успешно.
 */

/*! \fn bool pm::stream::Stream::peek(std::string & s, size_t size) const
 *  \brief Подглядеть следующие \p size символов потока.
 *  
 *  Подглядывание успешно <=> в потоке содержится хотя бы \p size символов.
 *  
 *  Если подглядывание успешно, то в \p s записывается строка \ref DSelf "self"[0:\p size-1].
 *  
 *  \return Подглядывание успешно.
 */

/*! \fn void pm::stream::Stream::peek(std::string & s, const Position & bound) const
 *  \brief Подглядеть следующие символы потока до позиции \p bound.
 *  
 *  \pre Позиция \p bound принадлежит кластеру потока.
 *  \pre Для позиции p потока верно p <= \p bound.
 *  \pre Если поток содержит границу b, то \p bound <= b.
 *  
 *  В \p s записывается строка \ref DSelf "self"[0:\p bound - p - 1], где p - позиция потока S.
 */

/*! \fn void pm::stream::Stream::peek_at_most(std::string & s, size_t size) const
 *  \brief Подглядеть не более \p size следующих символов потока.
 *  
 *  В \p s записывается строка S[0:k-1], где k - наименьшее из чисел: \p size; число символов потока S.
 */

/*! \fn Stream pm::stream::Stream::prefix(Position bound) const
 *  \brief Вернуть новый поток разбора в кластере потока \ref DSelf "self" с позицией, равной позиции self, и границей \p bound.
 *  
 *  \pre Позиция \p bound принадлежит кластеру потока self.
 *  \pre Для позиции p потока self верно p <= \p bound.
 *  \pre Если поток self содержит границу b, то \p bound <= b.
 */

/*! \fn Position pm::stream::Stream::pos() const
 *  \brief Вернуть ссылку на текущую позицию потока.
 */
