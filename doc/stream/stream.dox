/*! \file include/pm/stream/stream.hpp
 *  \brief Содержит класс буферизованного потока pm::stream::Stream.
 *  \ingroup ModuleStream
 */

/*! \class pm::stream::Stream
 *  \brief Класс буферизованного потока pm::stream::Stream.
 *  \ingroup ModuleStream
 *  
 *  Буферизованный поток \f$ S \f$ - это \ref GNNUngettableStream "возвратный поток", состоящий из:
 *  - \ref GNSTypes "стандартного потока ввода" \f$ S.is \f$ (точнее, ссылки на него);
 *  - буфера \f$ S.b \f$, в каждый момент времени содержащего конечную последовательность \ref GNSTypes "символов".
 *  
 *  Для единообразия обозначений буфер далее будет расцениваться как \ref GNNStream "стабильный" \ref GNNUngettableStream "возвратный поток".
 *  \f$ |B| \f$ - это то, сколько символов содержится в буфере \f$ B \f$.
 *  
 *  Буферизованный поток инициализируется пустым буфером.
 *  
 *  Последовательность символов буферизованного потока \f$ S \f$ выглядит так: \f$ S.b[0] \; S.b[1] \dots S.b[|S.b|-1] \; S.is[0] \; S.is[1] \dots \f$ - то есть при чтении символа из буферизованного потока
 *  - если буфер непуст, то читается первый символ буфера \f$ S.b \f$;
 *  - если буфер пуст, то читается символ потока \f$ S.is \f$.
 *  
 *  Буферизованный поток \f$ S \f$ стабилен <=> поток \f$ S.is \f$ стабилен.
 *  
 *  *Чтение символа* из буферизованного потока \f$ S \f$ устроено так:
 *  - Если буфер \f$ S.b \f$ непуст, то символ читается из этого буфера
 *   - и чтение успешно.
 *  - Если буфер \f$ S.b \f$ пуст, то символ читается из потока \f$ S.is \f$
 *   - и успешность чтения из \f$ S \f$ равносильна успешности чтения из \f$ S.is \f$.
 *  
 *  *Чтение строки длины не более N* из буферизованного потока \f$ S \f$ устроено так:
 *  - Производится многократное чтение символа из \f$ S \f$:
 *   - N раз, если в буфере \f$ S.b \f$ и потоке \f$ S.is \f$ суммарно содержится не менее N символов;
 *   - до первого неуспешного чтения символа иначе.
 *  - *Прочитанная строка* состоит из всех успешно прочитанных символов в порядке их чтения.
 *  - Чтение строки длины не более N всегда успешно.
 *  
 *  *Возврат символа* \f$ c \f$ в буферизованный поток \f$ S \f$ устроен так:
 *  - Поток \f$ S.is \f$ не изменяется.
 *  - Символ \f$ c \f$ добавляется в начало буфера \f$ S.b \f$:
 *   - после возврата буфер имеет вид \f$ c \; S.b[0] \; S.b[1] \dots S.b[|S.b|-1] \f$.
 *  
 *  *Возврат строки* \f$ s \f$ в буферизованный поток \f$ S \f$ устроен так:
 *  - Поток \f$ S.is \f$ не изменяется.
 *  - Строка \f$ s \f$ добавляется в начало буфера \f$ S.b \f$:
 *   - после возврата буфер имеет вид \f$ s[0] \; s[1] \; \dots \; s[|s|-1] \; S.b[0] \; S.b[1] \dots S.b[|S.b|-1] \f$.
 *  
 *  *Чтение строки длины N* из буферизованного потока \f$ S \f$ устроено так:
 *  - Из потока читается строка \f$ s \f$ длины не более N.
 *  - Если строка \f$ s \f$ имеет длину N, то:
 *   - чтение успешно;
 *   - \f$ s \f$ объявляется *прочитанной строкой*.
 *  - Если длина строки \f$ s \f$ строго меньше N, то
 *   - чтение неуспешно;
 *   - строка \f$ s \f$ возвращается в поток \f$ S \f$.
 *  
 *  \ref GNSTypes "Строка"
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref GNNValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: удалён.
 *  --
 *  
 *  Конструктор копирования: удалён.
 *  --
 *  
 *  Конструктор перемещения: удалён.
 *  --
 *  
 *  Копирующее присваивание: удалено.
 *  --
 *  
 *  Перемещающее присваивание: удалено.
 *  --
 *  
 *  Деструктор: `~Stream()`
 *  --
 *  
 *  Стандартное значение.
 *  
 */

/*! \fn pm::stream::Stream::Stream(std::istream & s)
 *  \brief Инициализировать буферизованный поток, содержащий ссылку на стандартный поток ввода \p s и пустой буфер.
 */

/*! \fn pm::stream::Stream::Stream(std::istream & s, size_t buffer_size)
 *  \brief Инициализировать буферизованный поток, содержащий ссылку на стандартный поток ввода \p s и пустой буфер, настроенный согласно техническому параметру \p buffer_size.
 *  
 *  В текущей реализации буфер - это список строк фиксированной длины \p buffer_size, и при возврате символов и строк элементы списка подходящим образом наполняются и по необходимости добавляются.
 *  Можно "играться" со значением параметра \p buffer_size для получения большей эффективности.
 */

/*! \fn bool pm::stream::Stream::get(char & c)
 *  \brief Чтение символа в переменную \p c.
 *  
 *  Производится чтение символа.
 *  
 *  При успехе прочитанный символ записывается в переменную \p c, при неуспехе переменная \p c не изменяется.
 *  
 *  \return Чтение успешно
 */

/*! \fn size_t pm::stream::Stream::get(std::string & s, size_t size)
 *  \brief Чтение строки длины не более \p size в переменную \p s.
 *  
 *  Производится чтение строки длины не более \p size.
 *  
 *  Прочитанная строка записывается в переменную \p s.
 *  
 *  \return Длина прочитанной строки
 */

/*! \fn bool pm::stream::Stream::get_strict(std::string & s, size_t size)
 *  \brief Чтение строки длины \p size в переменную \p s.
 *  
 *  Производится чтение строки длины \p size.
 *  
 *  При успехе прочитанная строка записывается в переменную \p s, при неуспехе переменная \p s не изменяется.
 *  
 *  \return Чтение успешно
 */

/*! \fn bool pm::stream::Stream::skip()
 *  \brief Чтение символа.
 *  
 *  Производится чтение символа.
 *  
 *  Прочитанный символ не сохраняется.
 *  
 *  \return Чтение успешно
 */

/*! \fn size_t pm::stream::Stream::skip(size_t size)
 *  \brief Чтение строки длины не более \p size.
 *  
 *  Производится чтение строки не более \p size.
 *  
 *  Прочитанная строка не сохраняется.
 *  
 *  \return Длина прочитанной строки
 */

/*! \fn bool pm::stream::Stream::skip_strict(size_t size)
 *  \brief Чтение строки длины \p size.
 *  
 *  Производится чтение строки длины \p size.
 *  
 *  Прочитанная строка не сохраняется.
 *  
 *  \return Чтение успешно
 */

/*! \fn void pm::stream::Stream::unget(char c)
 *  \brief Возврат символа \p c.
 */

/*! \fn void pm::stream::Stream::unget(const std::string & s)
 *  \brief Возврат строки \p s.
 */

/*! \fn bool pm::stream::Stream::empty() const
 *  \brief Вернуть `true` <=> буферизованный поток пуст (не содержит ни одного символа).
 *  
 *  Если буфер пуст, то из содержащегося стандартного потока ввода читается один символ, и в случае успешного чтения прочитанный символ возвращается (в буфер).
 */
