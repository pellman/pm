/*! \file include/pm/type_abuse/dptr.hpp
 *  \brief Содержит класс указателя на данные pm::type_abuse::DPtr - одного из видов \ref GNNTrickyPointer "хитрых указателей".
 *  \ingroup ModuleTypeAbuse
 */

/*! \class pm::type_abuse::DPtr
 *  \brief Класс указателя на данные - одного из видов \ref GNNTrickyPointer "хитрых указателей".
 *  \ingroup ModuleTypeAbuse
 *  
 *  Тип \ref GNNData "данных" по указателю
 *  - может меняться почти произвольно при выполнении программы (в том числе становиться пустым и непустым) и
 *  - всегда совпадает с фактическим типом этих данных.
 *  
 *  *Разыменование указателя* допускается только в том случае, если этот указатель непуст, и только согласно фактическому типу данных по этому указателю (без наследования).
 *  
 *  Доопределение понятия данных
 *  ==
 *  
 *  *Значение данных по умолчанию* - это значение пустых данных.
 *  
 *  *Установка значения* T от аргументов args в данные d устроена так:
 *  - если данные d непусты, то они уничтожаются вызовом деструктора;
 *  - данные d становятся объектом типа T, инициализированным от args.
 *  
 *  *Сброс данных* - это установка значения пустых данных.
 *  
 *  *Перезапись* данных d1 данными d2 устроена так:
 *  - если данные d1 непусты, то они уничтожаются вызовом деструктора;
 *  - данные d1 становятся копией данных d2.
 *  
 *  В результате *обмена* данных `d1`, `d2` данные `d1` приобретают тип, значение и размещение в памяти данных `d2`, а данные `d2` - тип, значение и размещение в памяти данных `d1`.
 *  При этом никаких действий над непустыми данными как объектами (уничтожение, копирование, перемещение, ...) не производится.
 *  
 *  Особенности документации
 *  ==
 *  
 *  `*this` - это указатель, документируемый метод которого вызывается.
 *  
 *  Пометка "инициирует сборку мусора" означает, что непустые данные `d`, на которые направлен указатель `*this` в начале выполнения документируемого метода, уничтожаются вызовом деструктора, если верно следующее:
 *  - `*this` - единственный указатель на данные, направленный на `d` в начале выполнения метода;
 *  - по завершении выполнения метода указатель `*this` не направлен на `d`.
 *  
 *  Пометка "исходные данные уничтожаются" означает, что непустые данные, на которые направлен указатель `*this` в начале выполнения документируемого метода, уничтожаются вызовом деструктора в обязательном порядке.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref GNNValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `DPtr(const DPtr & ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на данные \<\p ptr\>.
 *  
 *  Конструктор перемещения: `DPtr(DPtr && ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на данные \<\p ptr\>.
 *  
 *  Копирующее присваивание: `DPtr & operator =(const DPtr & ptr)`
 *  --
 *  
 *  Перенаправить `*this` на данные \<\p ptr\>.
 *  Инициирует сборку мусора.
 *  
 *  Перемещающее присваивание: `DPtr & operator =(DPtr && ptr)`
 *  --
 *  
 *  Перенаправить `*this` на данные \<\p ptr\>.
 *  Инициирует сборку мусора.
 *  
 *  Деструктор: `~DPtr()`
 *  --
 *  
 *  Стандартное значение.
 *  Инициирует сборку мусора.
 */

/*! \fn pm::type_abuse::DPtr::DPtr()
 *  \brief Инициализировать указатель, направленный на новые пустые данные.
 */

/*! \fn pm::type_abuse::DPtr::operator bool() const
 *  \brief Вернуть `true` \<=\> данные `<*this>` непусты.
 */

/*! \fn void pm::type_abuse::DPtr::detach()
 *  \brief Перенаправить `*this` на новую копию данных `<*this>`.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Если данные `<*this>` в момент вызова непусты, то их тип \ref GNSLifetime "копируем".
 */

/*! \fn void pm::type_abuse::DPtr::detach_receive(const DPtr & ptr)
 *  \brief Перенаправить `*this` на новую копию данных \<\p ptr\>.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Если данные \<\p ptr\> в момент вызова непусты, то их тип \ref GNSLifetime "копируем".
 */

/*! \fn void pm::type_abuse::DPtr::detach_set(Args && ... args)
 *  \brief Перенаправить `*this` на новый объект типа \p T, инициализированный от \p args.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p T \ref GNSLifetime "инициализируем" от аргументов \p args и \ref GNSLifetime "уничтожаем".
 */

/*! \fn void pm::type_abuse::DPtr::detach_unset()
 *  \brief Перенаправить `*this` на новые пустые данные.
 *  
 *  Инициирует сборку мусора.
 */

/*! \fn void pm::type_abuse::DPtr::receive(const DPtr & ptr) const
 *  \brief Перезаписать `<*this>` данными \<\p ptr\>.
 *  
 *  Исходные данные уничтожаются.
 *  
 *  \pre Если данные \<\p ptr\> в момент вызова непусты, то их тип \ref GNSLifetime "копируем".
 */

/*! \fn void pm::type_abuse::DPtr::set(Args && ... args) const
 *  \brief Установить значение типа \p T от аргументов \p args в данные `<*this>`.
 *  
 *  Исходные данные уничтожаются.
 *  
 *  \pre Тип \p T \ref GNSLifetime "инициализируем" от аргументов \p args и \ref GNSLifetime "уничтожаем".
 */

/*! \fn void pm::type_abuse::DPtr::swap(const DPtr & ptr) const
 *  \brief Обменять `<*this>` и \<\p ptr\>.
 */

/*! \fn void pm::type_abuse::DPtr::unset() const
 *  \brief Сбросить `<*this>`.
 *  
 *  Исходные данные уничтожаются.
 */

/*! \fn DPtr pm::type_abuse::DPtr::clone() const
 *  \brief Вернуть указатель, направленный на новую копию данных `<*this>`.
 *  
 *  \pre Если данные `<*this>` в момент вызова непусты, то их тип \ref GNSLifetime "копируем".
 */

/*! \fn void pm::type_abuse::DPtr::send(const DPtr & ptr) const
 *  \brief Перезаписать данные \<\p ptr\> данными `<*this>`.
 *  
 *  Если данные \<\p ptr\> в момент вызова непусты, то эти данные уничтожаются.
 *  
 *  \pre Если данные `<*this>` в момент вызова непусты, то их тип \ref GNSLifetime "копируем".
 */

/*! \fn bool pm::type_abuse::DPtr::empty() const
 *  \brief Вернуть `true` \<=\> данные `<*this>` пусты.
 */

/*! \fn bool pm::type_abuse::DPtr::nonempty() const
 *  \brief Вернуть `true` \<=\> данные `<*this>` непусты.
 */

/*! \fn T & pm::type_abuse::DPtr::val() const
 *  \brief Вернуть ссылку на `<*this>`.
 *  
 *  \pre Данные `<*this>` в момент вызова непусты, и их тип совпадает с \p T.
 */

/*! \fn DPtr pm::type_abuse::make_dptr(Args && ... args)
 *  \brief Создать объект типа \p T, инициализированный от \p args, и вернуть указатель, направленный на этот объект.
 *  
 *  Создание объекта - это выполнение выражения `new T(std::forward<Args>(args) ...)`.
 *  Возвращаемый указатель - единственный указатель, направленный на созданный объект.
 *  
 *  \pre Тип \p T \ref GNSLifetime "инициализируем" от аргументов \p args и \ref GNSLifetime "уничтожаем".
 */

/*! \fn T & pm::type_abuse::val(const DPtr & ptr)
 *  \brief Вернуть ссылку на данные \<\p ptr\>.
 *  
 *  \pre Данные \<\p ptr\> в момент вызова непусты, и их тип совпадает с \p T.
 */
