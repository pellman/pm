/*! \file include/pm/type_abuse/sptr.hpp
 *  \brief Содержит шаблонный класс стабильного указателя pm::type_abuse::SPtr - одного из видов \ref GNNTrickyPointer "хитрых указателей".
 *  \ingroup ModuleTypeAbuse
 */

/*! \class pm::type_abuse::SPtr
 *  \brief Класс стабильного указателя - одного из видов \ref GNNTrickyPointer "хитрых указателей".
 *  \ingroup ModuleTypeAbuse
 *  
 *  \tparam Base Базовый тип указателя.
 *  \pre Тип \p Base уничтожаем.
 *  
 *  \ref GNNData "Данные" по указателю всегда непусты (являются объектом в обычном понимании).
 *  То есть указатель всегда связан ровно с одним объектом и всегда разыменовываем.
 *  
 *  Указатель может быть направлен только на объекты типов, производных от \p Base.
 *  При применении большинства методов интерфейса взаимодействия тип объекта по указателю должен в точности совпадать с \p Base - это ограничение явно указано в документации таких методов.
 *  
 *  При *разыменовании указателя* возвращается ссылка на объект по этому указателю, обычным образом преобразованная в ссылку на объект базового типа.
 *  
 *  Доопределение понятия данных
 *  ==
 *  
 *  *Значение данных по умолчанию*: \p Base().
 *  
 *  *Установка значения* от аргументов args в данные d - это выполнение \ref GNSLifetime "перемещающего присваивания" d = Base(args ...).
 *  При выполнении этого присваивания тип данных d должен совпадать с \p Base.
 *  Допускается только установка в тип \p Base.
 *  
 *  *Сброс данных* - это установка значения \p Base().
 *  
 *  *Перезапись* данных d1 данными d2 - это выполнение \ref GNSLifetime "копирующего присваивания" d1 = d2.
 *  При выполнении этого присваивания тип данных d1 должен совпадать с \p Base.
 *  
 *  *Обмен* данных d1 и d2 - это выполнение вызова std::swap(d1, d2).
 *  При выполнении обмена типы данных d1 и d2 должны совпадать с \p Base.
 *  
 *  Особенности документации
 *  ==
 *  
 *  `*this` - это указатель, документируемый метод которого вызывается.
 *  
 *  Пометка "инициирует сборку мусора" означает, что объект `o`, на который направлен указатель `*this` в начале выполнения документируемого метода, уничтожается вызовом деструктора разыменования указателя, если верно следующее:
 *  - `*this` - единственный стабильный указатель, направленный на `o` в начале выполнения метода;
 *  - по завершении выполнения метода указатель `*this` не направлен на `o`.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref GNNValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `SPtr(const SPtr<Base> & ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на объект \<\p ptr\>.
 *  
 *  Конструктор перемещения: `SPtr(SPtr<Base> && ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на объект \<\p ptr\>.
 *  
 *  Копирующее присваивание: `SPtr<Base> & operator =(const SPtr<Base> & ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на объект \<\p ptr\>.
 *  Инициирует сборку мусора.
 *  
 *  Перемещающее присваивание: `SPtr<Base> & operator =(SPtr<Base> && ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на объект \<\p ptr\>.
 *  Инициирует сборку мусора.
 *  
 *  Деструктор: `~SPtr()`
 *  --
 *  
 *  Стандартное значение.
 *  Инициирует сборку мусора.
 */

/*! \fn pm::type_abuse::SPtr::SPtr()
 *  \brief Инициализировать указатель, направленный на новый объект \p Base().
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем по умолчанию".
 */

/*! \fn pm::type_abuse::SPtr::SPtr(Base * ptr)
 *  \brief Если `ptr == nullptr`, то инициализировать указатель, направленный на новый объект \p Base(); иначе инициализировать указатель, направленный на объект, располагающийся по адресу \p ptr.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем по умолчанию".
 *  \pre Если `ptr != nullptr`, то указатель \p ptr разыменовываем, и объект, располагающийся по адресу \p ptr, корректно уничтожается вызовом деструктора разыменования указателя \p ptr.
 *  \pre На объект по адресу \p ptr не направлены указатели, имеющие сборку мусора.
 */

/*! \fn pm::type_abuse::SPtr::SPtr(const Base & obj)
 *  \brief Инициализировать указатель, направленный на новую копию объекта \p obj.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем".
 */

/*! \fn pm::type_abuse::SPtr::SPtr(Base && obj)
 *  \brief Инициализировать указатель, направленный на новое перемещение объекта \p obj.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "перемещаем".
 */

/*! \fn Base * pm::type_abuse::SPtr::operator ->() const
 *  \brief Оператор доступа к членам разыменования `*this`.
 */

/*! \fn Base & pm::type_abuse::SPtr::operator *() const
 *  \brief Вернуть разыменование `*this`.
 */

/*! \fn void pm::type_abuse::SPtr::detach()
 *  \brief Перенаправить `*this` на новую копию объекта `<*this>`.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::detach_own(Base * ptr)
 *  \brief Если `ptr == nullptr`, то перенаправить `*this` на новый объект \p Base(), а иначе перенаправить `*this` на объект, располагающийся по адресу \p ptr.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем по умолчанию".
 *  \pre Если `ptr != nullptr`, то указатель \p ptr разыменовываем, и объект, располагающийся по адресу \p ptr, корректно уничтожается вызовом деструктора разыменования указателя \p ptr.
 *  \pre На объект по адресу \p ptr не направлены указатели, имеющие сборку мусора.
 */

/*! \fn void pm::type_abuse::SPtr::detach_receive(const SPtr<Base> & ptr)
 *  \brief Перенаправить `*this` на новую копию объекта \<\p ptr\>.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем".
 *  \pre Тип объекта \<\p ptr\> в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::detach_set(Args && ... args)
 *  \brief Перенаправить `*this` на новый объект типа \p Base, инициализированный от \p args.
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем" от аргументов \p args.
 */

/*! \fn void pm::type_abuse::SPtr::detach_unset()
 *  \brief Перенаправить `*this` на новый объект \p Base().
 *  
 *  Инициирует сборку мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем по умолчанию".
 */

/*! \fn void pm::type_abuse::SPtr::receive(const SPtr<Base> & ptr) const
 *  \brief Перезаписать объект `<*this>` объектом \<\p ptr\>.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем через присваивание".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::set(Args && ... args) const
 *  \brief Установить в `<*this>` значение от аргументов \p args.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем" от аргументов \p args и \ref GNSLifetime "перемещаем через присваивание".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::swap(Base & obj) const
 *  \brief Обменять `<*this>` и \p obj.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "перемещаем" и \ref GNSLifetime "перемещаем через присваивание".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::swap(const SPtr<Base> & ptr) const
 *  \brief Обменять `<*this>` и \<\p ptr\>.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "перемещаем" и \ref GNSLifetime "перемещаем через присваивание".
 *  \pre Типы объектов `<*this>` и \<\p ptr\> в момент вызова совпадают с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::unset() const
 *  \brief Сбросить `<*this>`.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем по умолчанию" и \ref GNSLifetime "перемещаем через присваивание".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn SPtr<Base> pm::type_abuse::SPtr::clone() const
 *  \brief Вернуть указатель, направленный на новую копию объекта `<*this>`.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::send(const SPtr<Base> & ptr) const
 *  \brief Перезаписать объект \<\p ptr\> объектом `<*this>`.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем через присваивание".
 *  \pre Тип объекта \<\p ptr\> в момент вызова совпадает с \p Base.
 */

/*! \fn Base * pm::type_abuse::SPtr::get() const
 *  \brief Вернуть адрес, по которому располагается объект `<*this>`.
 */

/*! \fn Base * pm::type_abuse::SPtr::get_copy() const
 *  \brief Создать новую копию объекта `<*this>` и вернуть адрес, по которому расположена эта копия.
 *  
 *  Созданный объект, располагающийся по возвращаемому адресу, не участвует в сборке мусора.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "копируем".
 *  \pre Тип объекта `<*this>` в момент вызова совпадает с \p Base.
 */

/*! \fn Base & pm::type_abuse::SPtr::val() const
 *  \brief Вернуть разыменование `*this`.
 */

/*! \fn SPtr<Base> pm::type_abuse::make_sptr(Args && ... args)
 *  \brief Создать новый объект типа \p Base, инициализированный от \p args, и вернуть указатель, направленный на этот объект.
 *  
 *  Создание объекта - это выполнение выражения `new Base(std::forward<Args>(args) ...)`.
 *  
 *  \pre Тип \p Base \ref GNSLifetime "инициализируем" от аргументов \p args.
 */
