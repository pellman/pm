/*! \file include/pm/grammar/grammar.hpp
 *  \brief Содержит класс грамматики pm::grammar::Grammar.
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::Grammar
 *  \brief Класс грамматики.
 *  \ingroup ModuleGrammar
 *  
 *  Грамматика содержит в себе:
 *  - конечную совокупность \ref pm::grammar::Action "грамматических действий", \ref GNSTypes "индексированных" целыми неотрицательными числами;
 *   - g[i], где g - грамматика и i - индекс, - это i-е грамматическое действие, содержащееся в g;
 *  - *индекс главного действия*.
 *  
 *  *Главное действие* грамматики - это действие совокупности по индексу главного действия.
 *  С главного действия начинается разбор \ref pm::stream::Stream "буферизованного потока", \ref GNSTypes "стандартного потока ввода" и \ref GNSTypes "строки" грамматикой.
 *  
 *  Кроме того, грамматика может содержать (или не содержать) *пробельное выражение*: \ref pm::regexp::Regexp "регулярное выражение", которым описываются \ref GNSTypes "символы" и \ref GNSTypes "строки", служащие разделителями между "осмысленными" конструкциями разбираемого текста и игнорируемые при разборе.
 *  
 *  *По умолчанию* грамматика инициализируется:
 *  - совокупностью действий, состоящей из одного действия: \ref PGFail "неуспех", с индексом 0;
 *  - индексом главного действия 0;
 *  - индексом главных данных 0;
 *  - отсутствующим пробельным выражением.
 *  
 *  Грамматика как регулярное выражение
 *  ==
 *  
 *  Помимо совокупности действий и индекса главного действия, грамматика также содержит:
 *  - *индекс главных данных* - эти данные \ref pm::dataset::Set "совокупности данных" \ref pm::grammar::Context "грамматического контекста разбора" отождествляются с текущими данными \ref pm::regexp::Context регулярного контекста разбора" при использовании грамматики как \ref pm::regexp::Regexp "регулярного выражения" для разбора потоков и строк \ref pm::regexp::RegexpInterface "соответствующими методами разбора".
 *  
 *  Точный способ отождествления данных описан ниже.
 *  
 *  *По умолчанию* индекс гланых данных - 0.
 *  
 *  Грамматикой наследуется \ref pm::regexp::RegexpInterface "интерфейс разбора регулярным выражением".
 *  
 *  Если главное действие грамматики \ref PGSafety "слабо-безопасно", то грамматика удовлетворяет свойствам \ref PRSafety "безопасного регулярного выражения".
 *  
 *  \ref pm::regexp::RegexpInterface "Метод разбора" \ref pm::stream::Stream "возвратного потока" s в \ref pm::regexp::Context "регулярном контексте" c грамматикой устроен так:
 *  - создаётся новый \ref pm::grammar::Context "грамматический контекст" gc по умолчанию;
 *  - указатели контекста gc на флаги активности строки и данных и на принятую строку направляются на соответствующие данные контекста c;
 *  - указатель на главные данные совокупности ds контекста gc (то есть указатель по индексу главных данных) направляется на новую копию текущих данных контекста c;
 *  - выполняется *подразбор*: грамматический разбор потока s в контексте gc;
 *  - если подразбор успешен и флаг активности данных поднят, то указатель на текущие данные контекста c перенаправляется на главные данные совокупности ds.
 *  - возвращается итог подразбора.
 *  
 *  Особенности документации
 *  ==
 *  
 *  `*this` - это грамматика, вызов метода которой документируется.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref GNNValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: Grammar()
 *  --
 *  
 *  Инициализировать грамматику по умолчанию.
 *  
 *  Конструктор копирования: `Grammar(const Grammar & g)`
 *  --
 *  
 *  Инициализировать грамматику, содержащую копию всего, что содержится в \p g.
 *  
 *  Конструктор перемещения: `Grammar(Grammar && g)`
 *  --
 *  
 *  Инициализировать грамматику, содержащую перемещение всего, что содержится в \p g.
 *  
 *  Копирующее присваивание: `Grammar & operator =(const Grammar & g)`
 *  --
 *  
 *  Перенаполнить грамматику `*this` копией всего, что содержится в \p g.
 *  
 *  Перемещающее присваивание: `Grammar & operator =(Grammar && g)`
 *  --
 *  
 *  Перенаполнить грамматику `*this` перемещением всего, что содержится в \p g.
 *  
 *  Деструктор: `Grammar()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn size_t pm::grammar::Grammar::add()
 *  \brief Добавить в грамматику действие \ref PGFail "неуспех" и вернуть его индекс.
 *  
 *  Возвращаемый индекс отличен от индексов всех действий, содержащихся в грамматике.
 */

/*! \fn size_t pm::grammar::Grammar::add(const Action & a)
 *  \brief Добавить в грамматику действие \p a и вернуть его индекс.
 *  
 *  Возвращаемый индекс отличен от индексов всех действий, содержащихся в грамматике.
 *  
 *  \sa \ref PGList "Список готовых грамматических действий и их определений"
 */

/*! \fn size_t pm::grammar::Grammar::add(Action && a)
 *  \brief Добавить в грамматику действие \p a и вернуть его индекс.
 *  
 *  Возвращаемый индекс отличен от индексов всех действий, содержащихся в грамматике.
 *  
 *  \sa \ref PGList "Список готовых грамматических действий и их определений"
 */

/*! \fn size_t pm::grammar::Grammar::add(Args && ... args)
 *  \brief Добавить в грамматику действие ac(\p args ...) и вернуть его индекс.
 *  
 *  Возвращаемый индекс отличен от индексов всех действий, содержащихся в грамматике.
 *  
 *  Эквивалентно вызову add(ac(std::forward<Args>(args) ...))
 *  
 *  Позволяет не вместо add(ac(x, y, ...)) писать add(x, y, ...): на несколько символов меньше.
 *  
 *  ac - полиморфная функция, позволяющая создавать большинство \ref PGrammar "готовых грамматических действий".
 *  
 *  \sa \ref PGList "Список готовых грамматических действий и их определений"
 */

/*! \fn void pm::grammar::Grammar::set_main(size_t i)
 *  \brief Объявить i-е действие главным.
 *  
 *  \pre В грамматике содержится действие с индексом \p i.
 */

/*! \fn void pm::grammar::Grammar::set_main_data(size_t i)
 *  \brief Объявить i-е данные совокупности главными.
 */

/*! \fn void pm::grammar::Grammar::set_skip(const regexp::Regexp & re)
 *  \brief Установить \p re пробельным выражением.
 *  
 *  \sa \ref PRList "Список готовых регулярных выражений"
 */

/*! \fn void pm::grammar::Grammar::set_skip(regexp::Regexp && re)
 *  \brief Установить \p re пробельным выражением.
 *  
 *  \sa \ref PRList "Список готовых регулярных выражений"
 */

/*! \fn void pm::grammar::Grammar::unset_main()
 *  \brief Объявить \ref PGFail "неуспех" главным грамматическим действием.
 */

/*! \fn void pm::grammar::Grammar::unset_main_data()
 *  \brief Объявить 0-е данные совокупности главными.
 */

/*! \fn void pm::grammar::Grammar::unset_skip()
 *  \brief Удалить пробельное регулярное выражение из грамматики.
 */

/*! \fn bool pm::grammar::Grammar::gmatch(stream::Stream & s, const Context & gcontext = default_context) const
 *  \brief Метод грамматического разбора буферизованного потока \p s в контексте \p gcontext.
 *  
 *  Выполняется разбор потока \p s на грамматике `*this` в контексте \p gcontext главным действием грамматики.
 *  
 *  Возвращается итог разбора действием.
 */

/*! \fn bool pm::grammar::Grammar::gmatch(std::istream & s, const Context & gcontext = default_context) const
 *  \brief Метод грамматического разбора стандартного потока ввода \p s в контексте \p gcontext.
 *  
 *  Создаётся буферизованный поток S, содержащий стандартный поток ввода \p s и пустой буфер.
 *  
 *  Выполняется метод грамматического разбора потока S в контексте \p gcontext.
 *  
 *  Возвращается итог выполненного метода.
 */

/*! \fn bool pm::grammar::Grammar::gmatch(const std::string & s, const Context & gcontext = default_context) const
 *  \brief Метод грамматического разбора строки \p s в контексте \p gcontext.
 *  
 *  Создаётся строковый поток ввода S, содержащий копию строки \p s.
 *  
 *  Выполняется метод грамматического разбора потока S (как стандартного потока ввода) в контексте \p gcontext.
 *  
 *  Возвращается итог выполненного метода.
 */

/*! \fn Action & pm::grammar::Grammar::action(size_t i)
 *  \brief Вернуть i-е действие грамматики.
 *  
 *  \pre Индекс \p i был получен ранее при добавлении действия в грамматику.
 */

/*! \fn const Action & pm::grammar::Grammar::action(size_t i) const
 *  \brief Вернуть i-е действие грамматики.
 *  
 *  \pre Индекс \p i был получен ранее при добавлении действия в грамматику.
 */

/*! \fn bool pm::grammar::Grammar::has_skip() const
 *  \brief Вернуть `true` <=> в грамматике содержится пробельное выражение.
 */

/*! \fn Action & pm::grammar::Grammar::main_action()
 *  \brief Вернуть главное грамматическое действие.
 */

/*! \fn const Action & pm::grammar::Grammar::main_action() const
 *  \brief Вернуть главное грамматическое действие.
 */

/*! \fn size_t pm::grammar::Grammar::main_data() const
 *  \brief Вернуть индекс главных данных.
 */

/*! \fn size_t pm::grammar::Grammar::main_index() const
 *  \brief Вернуть индекс главного грамматического действия.
 */

/*! \fn regexp::Regexp & pm::grammar::Grammar::skip()
 *  \brief Вернуть пробельное выражение.
 *  
 *  \pre Грамматика содержит пробельное выражение.
 */

/*! \fn const regexp::Regexp & pm::grammar::Grammar::skip() const
 *  \brief Вернуть пробельное выражение.
 *  
 *  \pre Грамматика содержит пробельное выражение.
 */
