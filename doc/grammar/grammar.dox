/*! \file include/pm/grammar/grammar.hpp
 *  \brief Содержит класс грамматик pm::grammar::Grammar.
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::Grammar
 *  \brief Класс грамматик.
 *  \ingroup ModuleGrammar
 *  
 *  В грамматике содержатся две части:
 *  1. *Синтаксическая*:
 *  - Набор \ref pm::grammar::Definition "нетерминальных описаний", каждому из которых присвоено *имя* (\ref DTypes "строка").
 *  - (опционально) Пробельное \ref pm::regex::Regex "регулярное выражение".
 *  2. *Семантическая*:
 *  - \ref pm::set::Domain "Домен" данных.
 *  - Набор \ref pm::grammar::Nonterminal "нетерминалов", каждому из которых присвоено имя.
 *  
 *  При изменении синтаксической части семантическая часть не изменяется.
 *  При выполнении *синхронизации* семантическая часть обновляется согласно текущему значению синтаксической части:
 *  - Домен данных опустошается, и в него добавляются все \ref pm::grammar::Definition "имена данных", содержащиеся в нетерминальных описаний, с произвольной нумерацией этих имён.
 *  - Набор нетерминалов опустошается, и в него добавляются нетерминалы, особым образом \ref pm::grammar::Definition "соответствующие" всем нетерминальным описаниям на текущей синтаксической части и обновлённом домене данных.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref DValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *      Grammar()
 *  
 *  Инициализировать описание грамматики с пустым доменом данных и не содержащее нетерминальные описания, нетерминалы и пробельное выражение.
 *  
 *      Grammar(const Grammar &)
 *      Grammar(Grammar &&)
 *      Grammar & operator =(const Grammar &)
 *      Grammar & operator =(Grammar &&)
 *      ~Grammar()
 *  
 *  Обычные копирование, перемещение, копирующее присваивание, перемещающее присваивание и деструктор.
 */

/*! \fn void pm::grammar::Grammar::set_skip(regex::Regex r)
 *  \brief Добавить пробельное выражение \p r (заменив имеющееся пробельное выражение, если оно есть).
 *  
 *  \pre Выражение \p r \ref SafeRParse "безопасно".
 */

/*! \fn void pm::grammar::Grammar::synchronize()
 *  \brief Выполнить \ref pm::grammar::Grammar "синхронизацию".
 */

/*! \fn void pm::grammar::Grammar::unset_skip()
 *  \brief Удалить пробельное выражение (если имеется).
 */

/*! \fn bool pm::grammar::Grammar::has_data(const std::string & data_name) const
 *  \brief Вернуть true <=> в домене данных содержится имя \p data_name.
 */

/*! \fn bool pm::grammar::Grammar::has_nt(const std::string & nt_name) const
 *  \brief Вернуть true <=> в грамматике содержится нетерминал с именем \p nt_name.
 */

/*! \fn bool pm::grammar::Grammar::has_skip() const
 *  \brief Вернуть true <=> в грамматике содержится пробельное выражение.
 */

/*! \fn set::Domain pm::grammar::Grammar::data_domain() const
 *  \brief Вернуть домен данных.
 */

/*! \fn size_t pm::grammar::Grammar::data_index(const std::string & data_name) const
 *  \brief Вернуть номер имени \p data_name в домене данных.
 *  
 *  \pre В домене данных содержится имя \p data_name.
 */

/*! \fn Nonterminal pm::grammar::Grammar::nt(const std::string & nt_name) const
 *  \brief Вернуть нетерминал с именем \p nt_name.
 *  
 *  Если в семантической части отсутствует нетерминал с именем \p nt_name, то возвращается нетерминал, соответствующий \ref MGFalse "описанию неуспеха".
 */

/*! \fn std::map<std::string, Nonterminal> pm::grammar::Grammar::nt_map() const
 *  \brief Вернуть \ref DMap "отображение" всех имён нетерминалов в соответствующие нетерминалы.
 */

/*! \fn regex::Regex pm::grammar::Grammar::re(const std::string & nt_name) const
 *  \brief Вернуть регулярное выражение, производное от нетерминала с именем \p nt_name без учёта данных.
 *  \anchor GtoRNodata
 *  
 *  Если в грамматике отсутствует нетерминал с именем \p nt_name, то возвращается выражение \ref MRFalse "Неуспех".
 *  Иначе верно следующее.
 *  
 *  \ref pm::regex::Regex "Процедура регулярного разбора" \ref pm::stream::Stream "потока разбора" S в \ref pm::regex::DataContext "регулярном контексте данных" C для возвращаемого выражения r определяется \ref pm::grammar::Nonterminal "процедурой грамматического разбора" нетерминала N с именем \p nt_name и устроена так:
 *  - Создаётся новая \ref pm::set::Set "совокупность данных" DS по умолчанию.
 *  - Выполняется *подразбор*: грамматический разбор потока S на совокупности DS нетерминалом N.
 *  - Совокупность данных DS уничтожается.
 *  - Итог разбора совпадает с итогом подразбора.
 *  
 *  Если процедура разбора нетерминала N \ref ParseProcedure "корректна", то выражение r удовлетворяет всем свойствам \ref MRTerminal "терминальных регулярных выражений", и его процедура разбора не изменяет данные контекста.
 */

/*! \fn regex::Regex pm::grammar::Grammar::re(const std::string & nt_name, const std::string & data_name) const
 *  \brief Вернуть регулярное выражение, производное от нетерминала с именем \p nt_name с учётом данных.
 *  
 *  Если в домене данных отсутствует имя \p data_name, то возвращается регулярное выражение, \ref GtoRNodata "производное" от нетерминала с именем \p nt_name без учёта данных.
 *  Иначе верно следующее.
 *  
 *  \ref pm::regex::Regex "Процедура регулярного разбора" \ref pm::stream::Stream "потока разбора" S в \ref pm::regex::DataContext "регулярном контексте данных" C для возвращаемого выражения r определяется \ref pm::grammar::Nonterminal "процедурой грамматического разбора" нетерминала N с именем \p nt_name и устроена так:
 *  - Создаётся новая \ref pm::set::Set "совокупность данных" DS по умолчанию.
 *  - \ref pm::data::Data "Данные" DS[i] перенаполняются копией опционального объекта, хранящегося в текущих данных контекста C.
 *  - Выполняется *подразбор*: грамматический разбор потока S на совокупности DS нетерминалом N.
 *  - Если подразбор успешен и флаг контекста C поднят, то выполняется обмен текущих данных контекста C с данными DS[i].
 *  - Совокупность данных DS уничтожается (вместе с объектом, хранившемся в текущих данных C перед выполнением разбора).
 *  - Итог разбора совпадает с итогом подразбора.
 *  
 *  Если процедура разбора нетерминала N \ref SafeGParse "безопасна", то выраажение r удовлетворяет всем свойствам \ref MRTerminal "терминальных регулярных выражений".
 *  
 *  Если процедура разбора нетерминала N \ref ParseProcedure "корректна", но не безопасна, то свойства r отличаются от свойств терминальных регулярных выражений только тем, что успешность разбора и принимаемая строка могут зависеть от значения текущих данных контекста C в начале разбора.
 */

/*! \var std::map<std::string, Definition> pm::grammar::Grammar::definitions
 *  \brief \ref DMap "Отображение" всех имён нетерминальных описаний в соответствующие описания.
 */
