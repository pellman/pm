/*! \file include/pm/grammar/syntax/grammar.hpp
 *  \brief Содержит класс определения грамматики pm::grammar::syntax::Grammar.
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::syntax::Grammar
 *  \brief Класс определения грамматики.
 *  \ingroup ModuleGrammar
 *  
 *  В определении грамматики содержится отображение конечного \ref GNSSet "множества" \ref GNSTypes "строк" (*пространства имён*) в \ref pm::grammar::syntax::Action "определения грамматических действий".
 *  
 *  Определения грамматических действий, *содержащиеся* в определении грамматики - это определения, сопоставленные именам, а также подопределения этих определений, подопределения их подопределений и т.д. - т.е. все определения грамматических действий, так или иначе (прямо или косвенно) присутствующие в определении грамматики.
 *  
 *  Кроме описанного отображения, в определении грамматики могут как содержаться, так и не содержаться:
 *  - Имя главного действия: \ref GNSTypes "строка". С \ref pm::grammar::Action "грамматического действия", определению которого соответствует это имя, начинается \ref pm::grammar::Grammar "разбор грамматикой".
 *  - Имя главных данных: \ref GNSTypes "строка". При использовании грамматики в качестве \ref pm::regexp::Regexp "регулярного выражения" текущие данные \ref pm::regexp::Context "регулярного контекста разбора" отождествляются с данными в совокупности \ref pm::grammar::Context "грамматического контекста разбора", обозначенными этим именем.
 *  - Пробельное \ref pm::regexp::Regexp "регулярное выражение". Этим выражением описываются \ref GNSTypes "символы и строки", служащие разделителями между "существенными" конструкциями текста и игнорируемые при разборе грамматикой.
 *  
 *  Методы интерфейса взаимодействия с грамматикой делятся на:
 *  - методы наполнения;
 *  - методы интерпретации.
 *  
 *  Методами наполнения изменяются составные части определения грамматики.
 *  
 *  Методами интерпретации возвращается одно из двух:
 *  - *интерпретированная грамматика*: \ref pm::grammar::Grammar "грамматика", соответствующая текущему наполнению определения грамматики;
 *  - *интерпретированное регулярное выражение*: \ref pm::regexp::Regexp "регулярное выражение" с устройством \ref pm::regexp::RegexpInterface "методов разбора" согласно \ref pm::grammar::Grammar "трактовке" интерпретированной грамматики как регулярного выражения.
 *  
 *  Интерпретация определения грамматики
 *  ==
 *  
 *  Отображения имён в индексы
 *  --
 *  
 *  В процессе интерпретации определения грамматики строятся следующие отображения.
 *  
 *  \f$ \varphi_i \f$ - произвольное отображение, ставящее в соответствие каждому определению грамматического действия \f$ D \f$, содержащемуся в определении грамматики, \ref GNSTypes "индекс" \f$ \varphi_i(D) \f$ \ref pm::grammar::Action "грамматического действия" в интерпретированной грамматике.
 *  При этом различные определения грамматических действий отображаются в различные индексы.
 *  
 *  \f$ \varphi_n \f$ - отображение, отображающее каждое имя \f$ name \f$ из пространства имён в индекс \f$ \varphi_i(D) \f$, где \f$ D \f$ - определение грамматического действия, сопоставленное имени \f$ name \f$.
 *  
 *  \f$ \varphi_d \f$ - произвольное \ref pm::dataset::syntax::Set "определение совокупности данных", содержащее все имена данных, встречающиеся в определении грамматики.
 *  В текущей реализации это имя главных данных и имена в определениях \ref PGFunction "функций над данными" и \ref PGReData "регулярных выражений с данными".
 *  
 *  Интерпретация определений грамматических действий
 *  --
 *  
 *  \f$ \varphi_i(D) \f$-е грамматическое действие интерпретированной грамматики - это *результат интерпретации* определения грамматического действия \f$ D \f$ для построенных отображений \f$ \varphi_i \f$, \f$ \varphi_n \f$, \f$ \varphi_d \f$, явно описанный в документации каждого \ref PGList "определения готового грамматического действия".
 *  
 *  Интерпретация имени главного действия
 *  --
 *  
 *  Индекс главного действия интерпретированной грамматики - это индекс \f$ \varphi_n(main\_name) \f$, где \f$ main\_name \f$ - имя главного действия.
 *  
 *  Если имя главного действия не содержится в определении грамматики или не отображается в определение какого-либо грамматического действия, то индекс главного действия интерпретированной грамматики - 0 (главное действие - \ref PGFail "неуспех").
 *  
 *  Интерпретация имени главных данных
 *  --
 *  
 *  Индекс главных данных интерпретированной грамматики - это индекс \f$ \varphi_d(data\_name) \f$, где \f$ data\_name \f$ - имя главных данных.
 *  
 *  Если имя главных данных не содержится в определении грамматики, то индекс главных данных интерпретированной грамматики - 0.
 *  
 *  Интерпретация пробельного выражения
 *  --
 *  
 *  Наличие и устройство пробельного выражения в интерпретированной грамматике совпадают с наличием и устройством пробельного выражения в определении грамматики.
 *  
 *  \sa \ref PGList "Список готовых грамматических действий и их определений"
 *  \sa \ref PRList "Список готовых регулярных выражений"
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref GNNValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: Grammar()
 *  --
 *  
 *  Инициализировать определение грамматики с пустым пространством имён и не содержащее имени главного действия, имени главных данных и пробельного выражения.
 *  
 *  Конструктор копирования: `Grammar(const Grammar & g)`
 *  --
 *  
 *  Инициализировать определение грамматики, содержащее копию всего, что содержится в \p g.
 *  
 *  Конструктор перемещения: `Grammar(Grammar && g)`
 *  --
 *  
 *  Инициализировать определение грамматики, содержащее перемещение всего, что содержится в \p g.
 *  
 *  Копирующее присваивание: `Grammar & operator =(const Grammar & g)`
 *  --
 *  
 *  Перенаполнить определение грамматики копией всего, что содержится в \p g.
 *  
 *  Перемещающее присваивание: `Grammar & operator =(Grammar && g)`
 *  --
 *  
 *  Перенаполнить определение грамматики перемещением всего, что содержится в \p g.
 *  
 *  Деструктор: `Grammar()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn Action & pm::grammar::syntax::Grammar::operator [](const std::string & name)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие \ref PGFail "определение неуспеха". В любом случае вернуть определение, соответствующее имени \p name.
 */

/*! \fn Action & pm::grammar::syntax::Grammar::operator [](std::string && name)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие \ref PGFail "определение неуспеха". В любом случае вернуть определение, соответствующее имени \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, const Action & a)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение \p a. Иначе заменить определение, сопоставленное \p name, на \p a.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, Action && a)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение \p a. Иначе заменить определение, сопоставленное \p name, на \p a.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, const Action & a)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение \p a. Иначе заменить определение, сопоставленное \p name, на \p a.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, Action && a)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение \p a. Иначе заменить определение, сопоставленное \p name, на \p a.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, Args && ... args)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение ac(\p a). Иначе заменить определение, сопоставленное \p name, на ac(\p a).
 *  
 *  Эквивалентно вызову add(name, ac(std::forward<Args>(args) ...)).
 *  
 *  Позволяет писать add(name, args ...) вместо add(name, ac(args ...)): на несколько букв меньше.
 *  
 *  ac - полиморфная функция, позволяющая создавать большинство определений \ref PGrammar "готовых грамматических действий".
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, Args && ... args)
 *  \brief Если \p name не входит в пространство имён, то добавить это имя и поставить ему в соответствие определение ac(\p a). Иначе заменить определение, сопоставленное \p name, на ac(\p a).
 *  
 *  Эквивалентно вызову add(name, ac(std::forward<Args>(args) ...)).
 *  
 *  Позволяет писать add(name, args ...) вместо add(name, ac(args ...)): на несколько букв меньше.
 *  
 *  ac - полиморфная функция, позволяющая создавать большинство определений \ref PGrammar "готовых грамматических действий".
 */

/*! \fn void pm::grammar::syntax::Grammar::erase(const std::string & action_name)
 *  \brief Если \p action_name входит в пространство имён, то удалить имя и соответствующее определение из определения грамматики. Иначе ничего не делать.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main(const std::string & name)
 *  \brief Если в определении грамматики содержится имя главного действия, то заменить его на \p name. Иначе добавить имя главного действия \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main(std::string && name)
 *  \brief Если в определении грамматики содержится имя главного действия, то заменить его на \p name. Иначе добавить имя главного действия \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main_data(const std::string & name)
 *  \brief Если в определении грамматики содержится имя главных данных, то заменить его на \p name. Иначе добавить имя главных данных \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main_data(std::string && name)
 *  \brief Если в определении грамматики содержится имя главных данных, то заменить его на \p name. Иначе добавить имя главных данных \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_skip(const regexp::Regexp & re)
 *  \brief Если в определении грамматики содержится пробельное выражение, то заменить его на \p re. Иначе добавить пробельное выражение \p re.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_skip(regexp::Regexp && re)
 *  \brief Если в определении грамматики содержится пробельное выражение, то заменить его на \p re. Иначе добавить пробельное выражение \p re.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_main()
 *  \brief Если в определении грамматики содержится имя главного действия, то удалить его. Иначе ничего не делать.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_main_data()
 *  \brief Если в определении грамматики содержится имя главных данных, то удалить его. Иначе ничего не делать.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_skip()
 *  \brief Если в определении грамматики содержится пробельное выражение, то удалить его. Иначе ничего не делать.
 */

/*! \fn grammar::Grammar pm::grammar::syntax::Grammar::interpret() const
 *  \brief Метод интерпретации. Вернуть интерпретированную грамматику.
 */

/*! \fn grammar::Grammar pm::grammar::syntax::Grammar::interpret(InterpretInfo & ii) const
 *  \brief Метод интерпретации. Вернуть интерпретированную грамматику и записать отображения \f$ \varphi_n \f$, \f$ \varphi_d \f$ в структуру данных \p ii.
 */

/*! \fn regexp::Regexp pm::grammar::syntax::Grammar::interpret_as_regexp() const
 *  \brief Метод интерпретации. Вернуть интерпретированное регулярное выражение.
 */
