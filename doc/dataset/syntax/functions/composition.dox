/*! \file include/pm/dataset/syntax/functions/composition.hpp
 *  \brief Содержит интерфейс создания определения \ref PDComposition "композиции функций над совокупностью данных".
 *  \ingroup ModuleDataset
 *  \anchor PDDComposition
 *  
 *  Определение композиции функций над совокупностью данных - это \ref pm::dataset::syntax::Function "определение функции над совокупностью данных" следующего вида:
 *  - Она содержит упорядоченный набор *подопределений*: определений функции над совокупностью данных.
 *  - Она \ref pm::dataset::syntax::FunctionInterface "содержит все имена", содержащиеся в подопределениях.
 *  - \ref pm::dataset::syntax::FunctionInterface "Результат интерпретации": \ref PDComposition "композиция функций над совокупностью данных" над набором результатов интерпретации подопределений в том же порядке.
 *  
 *  В документации функций и операторов интерфейса описывается набор подопределений в определении композиции, возвращаемом вызовом.
 *  
 *  \pre Определение композиции, возвращаемое вызовом, не используется (прямо или косвенно) в аргументах вызова.
 *  
 *  \sa \ref PDatasetFunction "Список готовых функций над совокупностью данных и их определений"
 */

/*! \fn Function pm::dataset::syntax::comp(const std::list<Function> & fl)
 *  \brief Подопределения: содержащиеся в списке \p fl, в том же порядке.
 */

/*! \fn Function pm::dataset::syntax::comp(std::list<Function> && fl)
 *  \brief Подопределения: содержащиеся в списке \p fl, в том же порядке.
 */

/*! \fn Function pm::dataset::syntax::comp(Args && ... args)
 *  \brief Подопределения: содержащиеся в списке {\p args ...}, в том же порядке.
 *  Эквивалентно вызову `comp(std::list<Function>{std::forward<Args>(args) ...})`.
 *  Позволяет при создании определения вместо `comp({f1, ..., fk})` писать `comp(f1, ..., fk)`: на одну пару скобок меньше.
 */

/*! \fn Function pm::dataset::syntax::operator *(const Function & f1, const Function & f2)
 *  \brief Подопределения: \p f1; \p f2.
 */

/*! \fn Function pm::dataset::syntax::operator *(const Function & f1, Function && f2)
 *  \brief Подопределения: \p f1; \p f2.
 */

/*! \fn Function pm::dataset::syntax::operator *(Function && f1, const Function & f2)
 *  \brief Подопределения: \p f1; \p f2.
 */

/*! \fn Function pm::dataset::syntax::operator *(Function && f1, Function && f2)
 *  \brief Подопределения: \p f1; \p f2.
 */
