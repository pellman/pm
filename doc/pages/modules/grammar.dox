/*! \page MGrammar Грамматики
 *  
 *  
 *  \tableofcontents
 *  
 *  Перед изучением этой страницы полезно прочитать \ref PIGrammar "общие слова о грамматиках".
 *  
 *  С помощью \ref pm::grammar::Grammar "грамматик" в библиотеке можно получать \ref pm::grammar::Nonterminal "нетерминалы", в которых реализованы методы, позволяющие, прочитывая \ref DTypes "символы" из \ref DTypes "стандартных потоков ввода" и \ref pm::stream::Stream "потоков разбора",
 *  - проверять, начинается ли поток с последовательности символов, подходящей под общий вид, задаваемый грамматикой, и
 *  - извлекать "полезную информацию", определяемую этой последовательностью, записывая её в \ref pm::grammar::Context "грамматический контекст разбора" или \ref pm::set::Set "совокупность данных".
 *  
 *  Нетерминал полностью определяется его \ref pm::grammar::Nonterminal "процедурой грамматического разбора" потока разбора на совокупности данных.
 *  
 *  \anchor SafeGParse
 *  Процедура грамматического разбора *безопасна*, если она обладает следующими свойствами:
 *  - Процедура \ref ParseProcedure "корректна".
 *  - Успешность разбора и принимаемая строка не зависят от содержимого совокупности данных в начале разбора.
 *  
 *  Предполагаемый способ работы с грамматикой устроен так:
 *  - Произвольно определяется \ref pm::grammar::Grammar "синтаксическая часть" грамматики, содержащая набор \ref pm::grammar::Definition "нетерминальных описаний" с присвоенными им именами (\ref DTypes "строками") и особого \ref pm::regex::Regex "регулярного выражения", описывающего общий вид конструкций, игнорируемых при исследовании текста (например, пробельные символы).
 *  - По синтаксической части грамматики вычисляется её \ref pm::grammar::Grammar "семантическая часть", содержащая набор нетерминалов с присвоенными им именами, выполняющих разбор согласно текущей синтаксической части.
 *  - Из семантической части извлекаются нетерминалы и информация о \ref pm::set::Domain "домене" данных, требуемая для извлечения желаемых элементов совокупности данных после разбора.
 *  
 *  Далее документируется устройство всех нетерминальных описаний, которые можно получить средствами библиотеки.
 *  
 *  \section MGSpec Особенности документации
 *  
 *  \anchor MGSpecInterface
 *  Документируемые \ref pm::grammar::Definition "нетерминальные описания" возвращаются вызовами функций и операторов *интерфейса создания*.
 *  Все эти функции находятся в пространстве имён pm::grammar .
 *  
 *  В документации нетерминального описания описывается устройство \ref pm::grammar::Nonterminal "процедуры грамматического разбора" \ref pm::grammar::Nonterminal "нетерминала", *соответствующего* описанию на заданных \ref pm::grammar::Grammar "синтаксической части грамматики" и \ref pm::set::Domain "домене данных".
 *  Все эти процедуры \ref ParseProcedure "корректны" при создании нетерминальных описаний согласно документации.
 *  
 *  Каждое нетерминальное описание помечено одним из трёх способов:
 *  - \anchor MGSpecTypeCF *Контекстно-свободное*.
 *    Процедура разбора соответствующего нетерминала \ref SafeGParse "безопасна".
 *  - \anchor MGSpecTypeCD *Контекстно-зависимое*.
 *    Процедура разбора соответствующего нетерминала \ref ParseProcedure "корректна", но не является безопасной.
 *  - \anchor MGSpecTypeD *Производное* от некоторого множества (под)описаний.
 *    Процедура разбора соответствующего нетерминала корректна.
 *    Если из документации явно и однозначно следует небезопасность процедуры разбора нетерминала, соответствующего хотя бы одному из подописаний, то процедура разбора небезопасна, а иначе безопасна.
 *  
 *  Используемые обозначения:
 *  - \anchor MGSpecDesc Desc: \ref DMap "отображение" всех имён нетерминальных описаний синтаксиса грамматики в соответствующие описания;
 *  - \anchor MGSpecSkip (опционально) skip: пробельное \ref pm::regex::Regex "регулярное выражение" синтаксиса грамматики;
 *  - \anchor MGSpecDom Dom: домен данных;
 *  - \anchor MGSpecS S: \ref pm::stream::Stream "поток разбора", посылаемый на вход процедуре разбора соответствующего нетерминала;
 *  - \anchor MGSpecDS DS: \ref pm::set::Set "совокупность данных", посылаемая на вход процедуре разбора соответствующего нетерминала.
 *  
 *  Пункты документации нетерминального описания:
 *  - \anchor MGSpecParameters *Параметры*: составные части описания, значения которых фиксируются при создании и влияют на процедуру разбора соответствующего нетерминала.
 *  - \anchor MGSpecFlag *Критерий успешности*: необходимые и достаточные условия успешности разбора соответствующим нетерминалом.
 *  - \anchor MGSpecStr *Принимаемая строка*: зависимость вида строки, принимаемой по итогам разбора соответствующим нетерминалом, от значений S и DS.
 *  - \anchor MGSpecData *Изменение данных*: описание изменения данных совокупности DS разбором соответствующим нетерминалом.
 *  - \anchor MGSpecConditions *Условия разбора*: ограничения на момент начала разбора соответствующим нетерминалом, при которых разбор корректен.
 *  - \anchor MGSpecParse *Устройство разбора*: особенности разбора соответствующим нетерминалом, не обозначенные в остальных пунктах.
 *  
 *  \section MGDefinitions Реализованные нетерминальные описания
 *  
 *  \subsection MGTrue Описание успеха
 *  
 *  Описание \ref MGSpecTypeCF "контекстно-свободно".
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор всегда успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка" всегда пуста.
 *  
 *  \ref MGSpecData "Изменение данных": данные не изменяются.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td>Подключающие заголовочные файлы
 *  <tr>
 *    <td>dtrue()
 *    <td>
 *      include/pm/grammar/definitions/constants.hpp
 *      
 *      include/pm/grammar/definitions.hpp
 *  </table>
 *  
 *  \subsection MGFalse Описание неуспеха
 *  
 *  Описание \ref MGSpecTypeCF "контекстно-свободно".
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор всегда неуспешен.
 *  
 *  \ref MGSpecData "Изменение данных": данные не изменяются.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td>Подключающие заголовочные файлы
 *  <tr>
 *    <td>dfalse()
 *    <td>
 *      include/pm/grammar/definitions/constants.hpp
 *      
 *      include/pm/grammar/definitions.hpp
 *  </table>
 *  
 *  \subsection MGNext Описание перенаправления
 *  
 *  \ref MGSpecParameters "Параметр": \ref DTypes "строка" name (имя нетерминала).
 *  
 *  Описание \ref MGSpecTypeCF "производно" от описания \ref MGSpecDesc "Desc"[name].
 *  
 *  \ref MGSpecParse "Устройство разбора".
 *  Выполняется *подразбор*: разбор потока d нетерминалом, соответствующим описанию Desc[name].
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> подразбор успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка": равна строке, принятой подразбором.
 *  
 *  \ref MGSpecData "Изменение данных": данные изменяются подразбором.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td>Подключающие заголовочные файлы
 *  <tr>
 *    <td>next(name)
 *    <td>std::string name
 *    <td>
 *      include/pm/grammar/definitions/next.hpp
 *      
 *      include/pm/grammar/definitions.hpp
 *  </table>
 *  
 *  \subsection MGRegex Описание регулярного нетерминала
 *  
 *  \ref MGSpecParameters "Параметры":
 *  - \ref pm::regex::Regex "регулярное выражение" r;
 *  - \ref DTypes "флаг" пробельного выражения flag;
 *  - (опционально) \ref pm::grammar::Definition "имя данных" data_name.
 *  
 *  Если выражение r \ref SafeRParse "безопасно", то описание \ref MGSpecTypeCF "контекстно-свободно".
 *  Если выражение r \ref SafeRParse "корректно", но не безопасно, то описание \ref MGSpecTypeCD "контекстно-зависимо".
 *  
 *  \ref MGSpecParse "Устройство разбора":
 *  - Если флаг flag поднят и выражение \ref MGSpecSkip "skip" имеется, то многократно, до первого неуспеха, выполняется *пробельный подразбор*: \ref pm::regex::Regex "регулярный разбор" потока \ref MGSpecS "S" выражением skip. (Если все такие регулярные разборы успешны, то разбор нетерминала не завершается.)
 *  - Выполняется *основной подразбор*: регулярный разбор потока S выражением r в \ref pm::regex::DataContext "регулярном контексте данных" RC
 *   - по умолчанию, если имя данных отсутствует;
 *   - с поднятым флагом, пустыми аккумулированными данными и данными \ref MGSpecDS "DS"[\ref MGSpecDom "Dom"[data_name]] в качестве текущих, если имя данных имеется.
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> основной подразбор успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка": конкатенация строк, принятых всеми успешными подразборами: s1 s2 ... sk s, где si - строка, принятая i-м пробельным подразбором, и s - строка, принятая основным подразбором.
 *  
 *  \ref MGSpecData "Изменение данных":
 *  - Если имя данных отсутствует, то данные совокупности DS не изменяются.
 *  - Иначе данные DS[Dom[data_name]] изменяются так, как изменяются текущие данные контекста RC основным подразбором.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td colspan="2">Типы аргументов
 *    <td>Пояснения
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td>re(r)
 *    <td rowspan="5">
 *      pm::regex::Regex r
 *    <td>
 *    <td>Флаг пробельного выражения поднят. Имя данных отсутствует.
 *    <td rowspan="2">
 *      include/pm/grammar/definitions/regex.hpp
 *    <td rowspan="5">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>re(r, data_name)
 *    <td rowspan="2">
 *      std::string data_name
 *    <td rowspan="2">Флаг пробельного выражения поднят.
 *  <tr>
 *    <td> r \>\> data_name
 *    <td>
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td>re_noskip(r)
 *    <td>
 *    <td>Флаг пробельного выражения опущен. Имя данных отсутствует.
 *    <td rowspan="2">
 *      include/pm/grammar/definitions/regex.hpp
 *  <tr>
 *    <td>re_noskip(r, data_name)
 *    <td>
 *      std::string data_name
 *    <td>Флаг пробельного выражения опущен.
 *  </table>
 *  
 *  \subsection MGFun Описание функции
 *  
 *  \ref MGSpecParameters "Параметры": \ref pm::set::Definition "функциональное описание" df.
 *  
 *  \ref pm::grammar::Definition "Именами данных" описания являются все \ref pm::set::Definition "имена данных" описания df.
 *  
 *  Описание \ref MGSpecTypeCF "контекстно-свободно".
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор всегда успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка" всегда пуста.
 *  
 *  \ref MGSpecData "Изменение данных": на совокупности \ref MGSpecDS "DS" выполняется \ref pm::set::Definition "процедура преобразования данных", \ref pm::set::Definition "соответсвующая" описанию df на домене \ref MGSpecDom "Dom".
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td>Типы аргументов
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td>fun(df)
 *    <td rowspan="2">pm::set::Definition df
 *    <td>
 *      include/pm/grammar/definitions/function.hpp
 *    <td rowspan="2">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>+df
 *    <td>
 *      include/pm/grammar/definitions/derived.hpp
 *  </table>
 *  
 *  \subsection MGAssert Описание проверки
 *  
 *  \ref MGSpecParameters "Параметр": \ref pm::grammar::Definition "имя данных" data_name.
 *  
 *  Описание \ref MGSpecTypeCD "контекстно-зависимо".
 *  
 *  \ref MGSpecConditions "Условия разбора": \ref pm::data::Data "данные" \ref MGSpecDS "DS"[\ref MGSpecDom "Dom"[data_name]] непусты и хранят объект \<DS[Dom[data_name]]\> типа bool.
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> значение объекта \<DS[Dom[data_name]]\> - true.
 *  
 *  \ref MGSpecStr "Принимаемая строка" всегда пуста.
 *  
 *  \ref MGSpecData "Изменение данных": данные не изменяются.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td>Типы аргументов
 *    <td>Подключающие заголовочные файлы
 *  <tr>
 *    <td>assert(data_name)
 *    <td>std::string data_name
 *    <td>
 *      include/pm/grammar/definitions/assert.hpp
 *      
 *      include/pm/grammar/definitions.hpp
 *  </table>
 *  
 *  \subsection MGAlternative Описание альтернативы
 *  
 *  \ref MGSpecParameters "Параметры" - *подописания*: нетерминальные описания d1, d2, ..., dk для произвольного k.
 *  
 *  \ref pm::grammar::Definition "Именами данных" описания являются все имена данных подописаний.
 *  
 *  Описание \ref MGSpecTypeD "производно" от подописаний d1, d2, ..., dk.
 *  
 *  \ref MGSpecParse "Устройство разбора".
 *  Последовательно по порядку выполняются *подразборы*: разборы потока \ref MGSpecS "S" нетерминалами, соответствующими подописаниям - до первого успеха или до последнего нетерминала.
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> один из подразборов успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка": равна строке, принятой успешным подразбором.
 *  
 *  \ref MGSpecData "Изменение данных": данные последовательно изменяются всеми выполненными подразборами.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td colspan="2">Типы аргументов
 *    <td>Пояснения
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td>alt(dseq)
 *    <td colspan="2">std::vector\<pm::grammar::Definition\> dseq
 *    <td>Подописания - все элементы вектора dseq в том же порядке.
 *    <td>
 *      include/pm/grammar/definitions/alternative.hpp
 *    <td rowspan="13">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>alt(args ...)
 *    <td colspan="2">template\<typename ... Args\> Args ... args
 *    <td>Эквивалентно описанию alt({args ...}) с \ref DPerfectForwarding "идеальной пересылкой".
 *    <td rowspan="12">
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td>d1 || d2
 *    <td>
 *      pm::grammar::Definition d1
 *    <td>
 *      pm::grammar::Definition d2
 *    <td>Подописания: d1, d2.
 *  <tr>
 *    <td>d_name || d
 *    <td rowspan="6">
 *      pm::grammar::Definition d
 *    <td rowspan="2">
 *      std::string d_name
 *    <td>Подописания: \ref MGNext "next"(d_name), d.
 *  <tr>
 *    <td>d || d_name
 *    <td>Подописания: d, \ref MGNext "next"(d_name).
 *  <tr>
 *    <td>r || d
 *    <td rowspan="2">
 *      pm::regex::Regex r
 *    <td>Подописания: \ref MGRegex "re"(r), d.
 *  <tr>
 *    <td>d || r
 *    <td>Подописания: d, \ref MGRegex "re"(r).
 *  <tr>
 *    <td>df || d
 *    <td rowspan="6">
 *      pm::set::Definition df
 *    <td>Подописания: \ref MGFun "fun"(df), d.
 *  <tr>
 *    <td>d || df
 *    <td>Подописания: d, \ref MGFun "fun"(df).
 *  <tr>
 *    <td>d_name || df
 *    <td rowspan="2">
 *      std::string d_name
 *    <td>Подописания: \ref MGNext "next"(d_name), \ref MGFun "fun"(df).
 *  <tr>
 *    <td>df || d_name
 *    <td>Подописания: \ref MGFun "fun"(df), \ref MGNext "next"(d_name).
 *  <tr>
 *    <td>r || df
 *    <td rowspan="2">
 *      pm::regex::Regex r
 *    <td>Подописания: \ref MGRegex "re"(r), \ref MGFun "fun"(df).
 *  <tr>
 *    <td>df || r
 *    <td>Подописания: \ref MGFun "fun"(df), \ref MGRegex "re"(r).
 *  </table>
 *  
 *  \subsection MGRule Описание правила
 *  
 *  \ref MGSpecParameters "Параметры" - *подописания*: нетерминальные описания d1, d2, ..., dk для произвольного k.
 *  
 *  \ref pm::grammar::Definition "Именами данных" описания являются все имена данных подописаний.
 *  
 *  Описание \ref MGSpecTypeD "производно" от подописаний d1, d2, ..., dk.
 *  
 *  \ref MGSpecParse "Устройство разбора".
 *  Последовательно по порядку выполняются *подразборы*: разборы потока \ref MGSpecS "S" нетерминалами, соответствующими подописаниям - до первого неуспеха или до последнего нетерминала.
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> все подразборы успешны.
 *  
 *  \ref MGSpecStr "Принимаемая строка": конкатенация строк, принятых подразборами: s1 s2 ... sk, где si - строка, принятая подразбором, соответствующим описанию di.
 *  
 *  \ref MGSpecData "Изменение данных": данные последовательно изменяются всеми выполненными подразборами.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td colspan="2">Типы аргументов
 *    <td>Пояснения
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td>rule(dseq)
 *    <td colspan="2">std::vector\<pm::grammar::Definition\> dseq
 *    <td>Подописания - все элементы вектора dseq в том же порядке.
 *    <td>
 *      include/pm/grammar/definitions/rule.hpp
 *    <td rowspan="13">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>rule(args ...)
 *    <td colspan="2">template\<typename ... Args\> Args ... args
 *    <td>Эквивалентно описанию rule({args ...}) с \ref DPerfectForwarding "идеальной пересылкой".
 *    <td rowspan="12">
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td>d1 && d2
 *    <td>
 *      pm::grammar::Definition d1
 *    <td>
 *      pm::grammar::Definition d2
 *    <td>Подописания: d1, d2.
 *  <tr>
 *    <td>d_name && d
 *    <td rowspan="6">
 *      pm::grammar::Definition d
 *    <td rowspan="2">
 *      std::string d_name
 *    <td>Подописания: \ref MGNext "next"(d_name), d.
 *  <tr>
 *    <td>d && d_name
 *    <td>Подописания: d, \ref MGNext "next"(d_name).
 *  <tr>
 *    <td>r && d
 *    <td rowspan="2">
 *      pm::regex::Regex r
 *    <td>Подописания: \ref MGRegex "re"(r), d.
 *  <tr>
 *    <td>d && r
 *    <td>Подописания: d, \ref MGRegex "re"(r).
 *  <tr>
 *    <td>df && d
 *    <td rowspan="6">
 *      pm::set::Definition df
 *    <td>Подописания: \ref MGFun "fun"(df), d.
 *  <tr>
 *    <td>d && df
 *    <td>Подописания: d, \ref MGFun "fun"(df).
 *  <tr>
 *    <td>d_name && df
 *    <td rowspan="2">
 *      std::string d_name
 *    <td>Подописания: \ref MGNext "next"(d_name), \ref MGFun "fun"(df).
 *  <tr>
 *    <td>df && d_name
 *    <td>Подописания: \ref MGFun "fun"(df), \ref MGNext "next"(d_name).
 *  <tr>
 *    <td>r && df
 *    <td rowspan="2">
 *      pm::regex::Regex r
 *    <td>Подописания: \ref MGRegex "re"(r), \ref MGFun "fun"(df).
 *  <tr>
 *    <td>df && r
 *    <td>Подописания: \ref MGFun "fun"(df), \ref MGRegex "re"(r).
 *  </table>
 *  
 *  \subsection MGChoose Описание выбора
 *  
 *  \ref MGSpecParameters "Параметры":
 *  - \ref pm::grammar::Definition "имя данных" data_name;
 *  - *подописания*: нетерминальные описания d0, d1, ..., dk для произвольного k.
 *  
 *  Также именами данных описания являются имена данных подописаний.
 *  
 *  Описание \ref MGSpecTypeCD "контекстно-зависимо".
 *  
 *  \ref MGSpecConditions "Условия разбора": \ref pm::data::Data "данные" \ref MGSpecDS "DS"[\ref MGSpecDom "Dom"[data_name]] непусты и хранят объект \<DS[Dom[data_name]]\> типа size_t.
 *  
 *  \ref MGSpecParse "Устройство разбора".
 *  Если значение i объекта \<DS[Dom[data_name]]\> не превосходит k, то выполняется *подразбор*: разбор нетерминалом, соответствующим описанию di.
 *  
 *  \ref MGSpecFlag "Критерий успешности": разбор успешен \<=\> значение i не превосходит k, и подразбор успешен.
 *  
 *  \ref MGSpecStr "Принимаемая строка": равна строке, принятой подразбором.
 *  
 *  \ref MGSpecData "Изменение данных": если выполняется подразбор, то данные изменяются подразбором, а иначе данные не изменяются.
 *  
 *  <table>
 *  <tr>
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td colspan="2">Типы аргументов
 *    <td>Пояснения
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td>choose(data_name, dseq)
 *    <td rowspan="2">
 *      std::string data_name
 *    <td>
 *      std::vector\<pm::grammar::Definition\> dseq
 *    <td>Подописания - все элементы вектора dseq в том же порядке.
 *    <td>
 *      include/pm/grammar/definitions/choose.hpp
 *    <td rowspan="2">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>choose(data_name, args ...)
 *    <td>
 *      template\<typename ... Args\> Args ... args
 *    <td>Эквивалентно описанию choose(data_name, {args ...}) с \ref DPerfectForwarding "идеальной пересылкой".
 *    <td>
 *      include/pm/grammar/definitions/derived.hpp
 *  </table>
 *  
 *  \subsection MGOther Другие нетерминальные описания
 *  
 *  <table>
 *  <tr>
 *    <td>Название
 *    <td>\ref MGSpecInterface "Интерфейс создания"
 *    <td colspan="2">Аргументы
 *    <td>Эквивалентное описание
 *    <td colspan="2">Подключающие заголовочные файлы
 *  <tr>
 *    <td rowspan="2">Описание опционала
 *    <td>opt(d)
 *    <td rowspan="6">
 *      pm::grammar::Definition d
 *    <td rowspan="4">
 *    <td rowspan="2">d \ref MGAlternative "||" \ref MGTrue "dtrue"()
 *    <td>
 *      include/pm/grammar/definitions/optional.hpp
 *    <td rowspan="8">
 *      include/pm/grammar/definitions.hpp
 *  <tr>
 *    <td>!d
 *    <td>
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td rowspan="2">Описание звезды Клини
 *    <td>star(d)
 *    <td rowspan="2">d \ref MGRule "&&" (self \ref MGAlternative "||" \ref MGTrue "dtrue"()), где self - описание самой звезды Клини
 *    <td>
 *      include/pm/grammar/definitions/star.hpp
 *  <tr>
 *    <td>*d
 *    <td>
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td rowspan="4">Описание нетерминала с функцией отката
 *    <td>ffun(d, df)
 *    <td rowspan="4">
 *      pm::set::Definition df
 *    <td rowspan="2">d \ref MGAlternative "||" (\ref MGFun "fun"(df) \ref MGRule "&&" \ref MGFalse "dfalse"())
 *    <td>
 *      include/pm/grammar/definitions/fail_function.hpp
 *  <tr>
 *    <td>d - df
 *    <td rowspan="3">
 *      include/pm/grammar/definitions/derived.hpp
 *  <tr>
 *    <td>d_name - df
 *    <td>std::string d_name
 *    <td>\ref MGNext "next"(d_name) \ref MGOther "-" df
 *  <tr>
 *    <td>r - df
 *    <td>pm::regex::Regex r
 *    <td>\ref MGRegex "re"(r) \ref MGOther "-" df
 *  </table>
 */
