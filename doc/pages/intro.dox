/*! \page Intro Краткое введение
 *  
 *  
 *  Если Вы захотели использовать библиотеку, то, скорее всего, у Вас возникло желание проанализировать какой-нибудь структурированный текст и извлечь из этого текста какие-нибудь полезные данные - проще говоря, *разобрать* какой-нибудь текст.
 *  Здесь коротко поясняется, как элементы библиотеки способствуют выполнению тех или иных частей этого желания.
 *  
 *  \tableofcontents
 *  
 *  \section IParsing Разборы текстов, парсеры
 *  
 *  Разборы текстов бывают разными с точки зрения трудности (во многих смыслах).
 *  Например, лексический разбор - исследование правильности стыковки букв в слове и извлечение этого слова - считается простым и обычно реализуется при помощи регулярных выражений.
 *  А синтаксический разбор - исследование правильности расстановки слов в фразах, предложениях и более широких текстах, и генерация внутренних структур данных, соответствующих этим текстам, - считается сложным и обычно реализуется при помощи грамматик.
 *  
 *  "Регулярное выражение" и "грамматика" - это довольно неоднозначные понятия (более-менее однозначные в математическом смысле, но очень неоднозначные, хотя и сохраняющие "ядро смысла", в программистском).
 *  В документации эти два понятия во всей их ширине не обсуждаются.
 *  
 *  Все виды разборов средствами библиотеки производятся при помощи \ref pm::Parser "класса парсеров" и \ref pm::Parser::parse "метода разбора" этого класса.
 *  Для создания парсеров со сложными методами разбора (таких, в которых возникает что-то похожее на грамматики) рекомендуется использовать \ref pm::ParSystem "класс систем парсеров".
 *  
 *  \section ITexts Тексты и потоки
 *  
 *  Тексты, которые можно анализировать средствами библиотеки, - это \ref DSGeneral "тексты" \ref DSStd "стандартных потоков ввода", а также все тексты, которые так или иначе преобразуются в такие потоки.
 *  Это, в частности, тексты стандартного системного потока ввода (std::cin) и всех \ref DTypes "стандартных строк" (преобразуются в \ref DSStd "строковые потоки ввода") и файлов (преобразуются в \ref DSStd "файловые потоки ввода").
 *  
 *  В методе разбора парсера используется особый (нестандартный) \ref DStream "поток ввода" - \ref pm::Stream "поток разбора".
 *  Для анализа текста стандартного потока ввода следует "обернуть" этот поток потоком разбора, использовав подходящий метод.
 *  
 *  \section IData Извлечение полезных данных
 *  
 *  Способ извлечения полезных данных из текста при разборе везде устраивается как угодно по-своему, и существенно по-разному может пониматься каждое слово в сочетании "извлечение полезных данных". (Что такое данные? Как отделить полезные данные от неполезных? Как данные извлекаются из текста?)
 *  
 *  В методе разбора парсера для извлечения полезных данных используется \ref pm::Context "контекст" - совокупность \ref pm::Data "данных", пронумерованных всевозможными \ref DTypes "индексами".
 *  Данные библиотеки во многом идентичны объекту типа std::any : это контейнер, в котором в каждый момент выполнения программы содержится не более одного объекта практически произвольного типа, и при этом наличие, тип и значение содержимого могут практически произвольно изменяться во время выполнения с помощью вызова подходящих методов.
 *  
 *  При разработке сложных парсеров можно легко запутаться в номерах данных контекста, особенно если эти номера изменяются при доработке парсера.
 *  Для удобства обращения к данным контекста в таких условиях рекомендуется использовать \ref pm::Domain "домен" - множество имён данных (стандартных строк), которое можно пополнять во время выполнения программы, "предсказуемо" и "безопасно" получая номера, соответствующие именам.
 *  Используя домен, можно при взаимодействии с контекстом заменить ненаглядные номера данных на наглядные строковые имена данных.
 *  
 *  \section ICreation Создание парсеров
 *  
 *  Для создания парсеров библиотекой предоставляется (хочется верить, что) довольно удобный \ref CParser "интерфейс", позволяющий пользователю как создавать и комбинировать готовые простые для понимания парсеры (как это обычно делается в реализациях регулярных выражений), так и создавать практически произвольные процедуры взаимодействия с потоками разбора и контекстами, объявляя эти процедуры парсерами.
 */
