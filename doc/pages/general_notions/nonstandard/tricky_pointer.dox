/*! \page GNNTrickyPointer Хитрый указатель
 *  
 *  Что это такое
 *  ==
 *  
 *  Указатель - это общеизвестное понятие, которое кратко может быть описано так:
 *  - Это объект, который может быть *направлен* не более чем на один (другой) объект (т.е. может *указывать* на этот объект).
 *  - Указатель может быть *пуст*: иметь специальное значение, явно и однозначно утверждающее, что указатель не связан ни с одним объектом.
 *  - Несколько указателей могут быть связаны с одним и тем же объектом.
 *  - Если указатель направлен на какой-либо объект, то он *разыменовываем*.
 *  - *Разыменование* указателя - это получение ссылки на объект, на который направлен указатель, а также сам этот объект.
 *  - Непустой неразыменовываемый указатель *некорректен*.
 *  
 *  Общеизвестными (и стандартными) являются два вида указателей:
 *  - чистый указатель (plain pointer) на объект типа `T`: `T *`;
 *  - умный указатель (smart pointer) на объект типа `T`: `std::shared_ptr<T>`, `std::uinque_ptr<T>`, ... .
 *  
 *  Умные указатели - это обёртка над чистыми указателями, предоставляющая удобный интерфейс взаимодействия и автоматическую сборку мусора (уничтожение неиспользуемых объектов).
 *  
 *  В библиотеке активно используется понятие \ref GNNData "данных", схожее с понятием объекта, но концептуально отличающееся в том, как воспринимается "отсутствие объекта": непустые данные - синоним объекта, а пустые данные - нестандартное понятие, имеющее черты объекта и отсутствия объекта.
 *  Аналоги умных указателей для случая, когда требуется работа не с объектами, а с данными, названы в документации *хитрыми указателями*.
 *  
 *  На данный момент в библиотеке реализованы два вида хитрых указателей: \ref pm::type_abuse::SPtr "стабильные указатели" и \ref pm::type_abuse::DPtr "указатели на данные".
 *  
 *  Общая терминология для хитрых указателей
 *  ==
 *  
 *  Связывание с данными
 *  --
 *  
 *  Хитрый указатель в каждый момент времени *указывает* ровно на одними данные (*направлен* на эти данные; *владеет* этими данными).
 *  
 *  *Данные по указателю* - это данные, на которые направлен указатель.
 *  
 *  На одни данные может быть направлено любое число хитрых указателей одинакового типа.
 *  
 *  Хитрый указатель *непуст* (*разыменовываем*), если направлен на непустые данные, и *пуст* (*неразыменовываем*), если направлен на пустые данные.
 *  
 *  Операции над хитрыми указателями
 *  --
 *  
 *  *Разыменование указателя* это:
 *  - (процесс) получение ссылки на непустые данные (т.е. объект) по указателю;
 *  - (объект) объект по описанной ссылке.
 *  
 *  В документации каждого хитрого указателя приводятся дополнительные особенности использования разыменования указателя.
 *  
 *  Запись \<p\>, где p - хитрый указатель, в документации используется для обозначения данных по указателю.
 *  
 *  В результате *перенаправления* указателя `p` на данные `d` этот указатель перестаёт быть направленным на исходные данные и направляется на данные `d` (не изменяется, если исходные данные и данные `d` - одно и то же).
 *  
 *  Сборка мусора
 *  --
 *  
 *  В хитрые указатели встроена автоматическая *сборка мусора*, аналогичная сборке мусора при работе с умными указателями типа `std::shared_ptr` с поправкой на понятие пустых данных:
 *  - Непустые данные уничтожаются вызовом деструктора этих данных как объекта базового типа.
 *  - Когда последний хитрый указатель перестаёт указывать на непустые данные, эти данные уничтожаются.
 *  - Данные по указателю могут уничтожаться и в других явно обозначенных случаях.
 *  - В остальных случаях уничтожение данных не требуется и утечек памяти не возникает.
 *  
 *  Явное или неявное уничтожение объекта, (второй раз) уничтожаемого в рамках сборки мусора хитрых указателей, некорректно.
 *  В том числе некорректны:
 *  - передача объекта во владение одновременно и умными указателями, и хитрыми указателями;
 *  - передача объекта во владение хитрыми указателями дважды по "чистому" адресу (типа `T *`).
 */
