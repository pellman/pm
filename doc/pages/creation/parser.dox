/*! \page CParser Интерфейс создания парсеров
 *  
 *  
 *  \tableofcontents
 *  
 *  \section CPTerminology Особенности документации
 *  
 *  Все функции, документированные в этом разделе, находятся в пространстве имён pm::parser, а все операторы - в пространстве имён ::pm.
 *  
 *  Далее заголовок каждого самого внутреннего раздела - это выражение, возвращающее \ref pm::Parser "парсер", устройство которого документируется в разделе.
 *  В частности, документируются типы аргументов выражения, устройство \ref pm::Parser::parse "(is, con)-разбора", ограничения на создание и использование парсера и подключающие заголовочные файлы.
 *  
 *  В возвращаемом парсере сохраняются значения аргументов в момент его создания.
 *  Если значения использованных аргументов изменяются после создания, то это не влияет на устройство созданного парсера (если иное не оговорено явно).
 *  
 *  (is, con)-разбор в документации называется *безопасным*, если выполнены следующие условия:
 *  - Если разбор неуспешен, то значения is до и после разбора равны.
 *  - Если разбор успешен, то изменение is разбором эквивалентно чтению из is некоторой последовательности символов.
 *    Эта последовательность в документации называется *принятой строкой*.
 *  
 *  При соблюдении требований, обозначенных в документации, <b>(is, con)-разборы всех документированных парсеров безопасны</b>.
 *  
 *  \section CPFunctional Парсеры общего вида
 *  
 *  Подключающие файлы:
 *  - include/pm/creation/parser/functional.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPfparse fparse(f)
 *  
 *  Аргумент: std::function\<bool(\ref pm::Stream &, \ref pm::Context &)\> f.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется вызов f(is, con).
 *  - Итог разбора равен результату вызова.
 *  - Если разбор неуспешен, то в is восстанавливается значение до вызова.
 *  
 *  \pre
 *    Функция f должна быть устроена так, чтобы (is, con)-разбор был \ref CPTerminology "безопасным".
 *  
 *  Подключающие заголовочные файлы: \ref CPFunctional "общие для всех парсеров общего вида".
 *  
 *  \subsection CPfexecute fexecute(f)
 *  
 *  Аргумент: std::function\<void(\ref pm::Stream &, \ref pm::Context &)\> f.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется вызов f(is, con).
 *  - Разбор всегда успешен.
 *  
 *  \pre
 *    Функция f должна быть устроена так, чтобы (is, con)-разбор был \ref CPTerminology "безопасным".
 *  
 *  Подключающие заголовочные файлы: \ref CPFunctional "общие для всех парсеров общего вида".
 *  
 *  \section CPConstant Константные парсеры
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/constant.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPtrue t()
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Разбор всегда успешен.
 *  
 *  Подключающие заголовочные файлы: \ref CPConstant "общие для всех константных парсеров".
 *  
 *  \subsection CPfalse f()
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Разбор всегда неуспешен.
 *  
 *  Подключающие заголовочные файлы: \ref CPConstant "общие для всех константных парсеров".
 *  
 *  \section CPScanner Сканирующие парсеры
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/scanner.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPSend scanner::end()
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is пуст.
 *  - \ref CPTerminology "Принимается" пустая строка.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSmakestring scanner::make(s)
 *  
 *  Аргумент: std::string s.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is начинается с подстроки s.
 *  - \ref CPTerminology "Принимается" строка s.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSmakesize scanner::make(size)
 *  
 *  Аргумент: size_t size.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is содержит хотя бы size символов.
 *  - \ref CPTerminology "Принимается" строка длины size.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSid2 scanner::id(head, tail)
 *  
 *  Аргументы:
 *  - pm::CharSet head.
 *  - pm::CharSet tail.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is непуст и начинается с символа множества head.
 *  - \ref CPTerminology "Принимается" длиннейшая строка, начинающаяся с символа множества head и продолжающаяся символами множества tail.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен и начинается с символа множества head, то в располагающихся далее символах есть хотя бы один символ **не** из множества tail.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSid1 scanner::id(cs)
 *  
 *  Аргумент: pm::CharSet cs.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is непуст и начинается с символа множества cs.
 *  - \ref CPTerminology "Принимается" длиннейшая строка, состоящая из символов множества cs.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен, то в нём есть хотя бы один символ **не** из множества cs.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPScid scanner::c_id()
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is начинается с головного символа идентификатора языка C.
 *  - \ref CPTerminology "Принимается" длиннейшая строка, являющаяся идентификатором языка C.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен и начинается с головного символа идентификатора языка C, то в располагающихся далее символах есть хотя бы один **не** хвостовой символ идентификатора языка C.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSdecimal scanner::decimal()
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is начинается с символа десятичной цифры.
 *  - \ref CPTerminology "Принимается" длиннейшая строка, состоящая из символов десятичных цифр.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен, то в нём есть хотя бы один символ **не** десятичной цифры.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSsuffixstrong scanner::suffix::strong(s)
 *  
 *  Аргумент: std::string s.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> в тексте is содержится подстрока s.
 *  - \ref CPTerminology "Принимается" кратчайшая строка, оканчивающаяся подстрокой s.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен, то в нём содержится подстрока s.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPSsuffixweak scanner::suffix::weak(s)
 *  
 *  Аргумент: std::string s.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор всегда успешен.
 *  - \ref CPTerminology "Принимается" кратчайшая строка, оканчивающаяся подстрокой s.
 *    Если в тексте is не содержится подстроки s, то принимается весь текст is.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен, то в нём содержится подстрока s.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPScommentstrong scanner::comment::strong(open, close)
 *  
 *  Аргументы:
 *  - std::string open.
 *  - std::string close.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор успешен \<=\> текст is начинается со подстроки open и после этого начала содержит подстроку close.
 *  - \ref CPTerminology "Принимается" кратчайшая строка, начинающаяся подстрокой open и после этого начала оканчивающаяся подстрокой close.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен и начинается подстрокой open, то после этого начала в нём содержится подстрока close.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \subsection CPScommentweak scanner::comment::weak(open, close)
 *  
 *  Аргументы:
 *  - std::string open.
 *  - std::string close.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значение con не изменяется.
 *  - Разбор всегда успешен.
 *  - \ref CPTerminology "Принимается" кратчайшая строка, начинающаяся подстрокой open и после этого начала оканчивающаяся подстрокой close.
 *    Если в тексте is не содержится подстроки s, то принимается весь текст потока.
 *  
 *  \pre
 *    Если текст is в начале разбора бесконечен и начинается подстрокой open, то после этого начала в нём содержится подстрока close.
 *  
 *  Подключающие заголовочные файлы: \ref CPScanner "общие для всех сканирующих парсеров".
 *  
 *  \section CPLetter Однобуквенные парсеры
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Парсер *задаётся* \ref DSet "множеством" \ref DTypes "символов".
 *  - Разбор успешен \<=\> текст is непуст и начинается с символа задающего множества.
 *  - Если разбор неуспешен, то значение con не изменяется.
 *  - Если разбор успешен, то \ref CPTerminology "принимается" строка длины 1 (символ задающего множества), и \ref pm::Data "данные" con[0] перенаполняются новым объектом типа char, равным принятому символу.
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/letter.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPLmakechar letter::make(c)
 *  
 *  Аргумент: char c.
 *  
 *  \ref CPLetter "Задающее множество символов": { c }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLmakestdset letter::make(cs)
 *  
 *  Аргумент: std::set\<char\> cs.
 *  
 *  \ref CPLetter "Задающее множество символов": cs.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLmakecharset letter::make(cs)
 *  
 *  Аргумент: pm::CharSet cs.
 *  
 *  \ref CPLetter "Задающее множество символов": cs.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLrange letter::range(bottom, top)
 *  
 *  Аргументы:
 *  - char bottom.
 *  - char top.
 *  
 *  \ref CPLetter "Задающее множество символов": { c | bottom <= c && c <= top }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLtotal letter::total()
 *  
 *  \ref CPLetter "Задающее множество символов": множество всех символов.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLdecimal letter::decimal()
 *  
 *  \ref CPLetter "Задающее множество символов": { '0', '1', ..., '9' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLunderscore letter::underscore()
 *  
 *  \ref CPLetter "Задающее множество символов": { '_' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLlatinlowercase letter::latin::lowercase()
 *  
 *  \ref CPLetter "Задающее множество символов": { 'a', 'b', ..., 'z' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLlatinuppercase letter::latin::uppercase()
 *  
 *  \ref CPLetter "Задающее множество символов": { 'A', 'B', ..., 'Z' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLlatinany letter::latin::any()
 *  
 *  \ref CPLetter "Задающее множество символов": { 'a', 'b', ..., 'z', 'A', 'B', ..., 'Z' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLcidhead letter::c_id::head()
 *  
 *  \ref CPLetter "Задающее множество символов": { 'a', 'b', ..., 'z', 'A', 'B', ..., 'Z', '_' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \subsection CPLcidtail letter::c_id::tail()
 *  
 *  \ref CPLetter "Задающее множество символов": { 'a', 'b', ..., 'z', 'A', 'B', ..., 'Z', '_', '0', '1', ..., '9' }.
 *  
 *  Подключающие заголовочные файлы: \ref CPLetter "общие для всех однобуквенных парсеров".
 *  
 *  \section CPGenerator Генераторы данных
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Разбор всегда успешен.
 *  - \ref CPTerminology "Принимается" пустая строка.
 *  - Значение con изменяется согласно документированному *преобразованию контекста*.
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/generator.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPGArithmetic Арифметические генераторы
 *  
 *  Подключающие заголовочные файлы:
 *  - \ref CPGenerator "Общие для всех генераторов данных".
 *  - include/pm/creation/parser/generator/arithmetic.hpp
 *  
 *  \subsubsection CPGAadd generator::add\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \ref pm::Data "\<con[0]\>" += \<con[1]\>.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно.
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAsub generator::sub\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \ref pm::Data "\<con[0]\>" -= \<con[1]\>.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно.
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAmul generator::mul\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \ref pm::Data "\<con[0]\>" *= \<con[1]\>.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно.
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAdiv generator::div\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \ref pm::Data "\<con[0]\>" /= \<con[1]\>.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно.
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAmod generator::mod\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \ref pm::Data "\<con[0]\>" %= \<con[1]\>.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно.
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAaddc generator::add\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (второй аргумент шаблона, дедуцируется по value).
 *  - T val.
 *  
 *  \pre
 *    Тип T \ref DObjectModification "перемещаем".
 *  \pre
 *    В начале разбора: тип объекта \ref pm::Data "\<con[0]\>" - в точности T0.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \<con[0]\> += v.
 *  
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и value в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAsubc generator::sub\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (второй аргумент шаблона, дедуцируется по value).
 *  - T val.
 *  
 *  \pre
 *    Тип T \ref DObjectModification "перемещаем".
 *  \pre
 *    В начале разбора: тип объекта \ref pm::Data "\<con[0]\>" - в точности T0.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \<con[0]\> -= v.
 *  
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и value в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAmulc generator::mul\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (второй аргумент шаблона, дедуцируется по value).
 *  - T val.
 *  
 *  \pre
 *    Тип T \ref DObjectModification "перемещаем".
 *  \pre
 *    В начале разбора: тип объекта \ref pm::Data "\<con[0]\>" - в точности T0.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \<con[0]\> *= v.
 *  
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и value в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAdivc generator::div\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (второй аргумент шаблона, дедуцируется по value).
 *  - T val.
 *  
 *  \pre
 *    Тип T \ref DObjectModification "перемещаем".
 *  \pre
 *    В начале разбора: тип объекта \ref pm::Data "\<con[0]\>" - в точности T0.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \<con[0]\> /= v.
 *  
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и value в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsubsection CPGAmodc generator::mod\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (второй аргумент шаблона, дедуцируется по value).
 *  - T val.
 *  
 *  \pre
 *    Тип T \ref DObjectModification "перемещаем".
 *  \pre
 *    В начале разбора: тип объекта \ref pm::Data "\<con[0]\>" - в точности T0.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется присваивание \<con[0]\> %= v.
 *  
 *  \pre
 *    Требуемое присваивание корректно для типов и значений \<con[0]\> и value в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGArithmetic "общие для всех арифметических генераторов".
 *  
 *  \subsection CPGConversion Преобразователи типов
 *  
 *  Подключающие заголовочные файлы:
 *  - \ref CPGenerator "Общие для всех генераторов данных".
 *  - include/pm/creation/parser/generator/conversion.hpp
 *  
 *  \subsubsection CPGCchartostring generator::char_to_string()
 *  
 *  \pre
 *    В начале разбора объект \ref pm::Data "\<con[0]\>" имеет тип char.
 *  
 *  \ref CPGenerator "Преобразование контекста": данные con[0] перенаполняются новой \ref DTypes "стандартной строкой", составленной из одного \ref DTypes "символа", равного \<con[0]\> в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGConversion "общие для всех преобразователей типов".
 *  
 *  \subsubsection CPGCstringtodecimal generator::string_to_decimal\<Int\>()
 *  
 *  Аргумент: typename Int.
 *  
 *  \pre
 *    В начале разбора объект \ref pm::Data "\<con[0]\>" имеет тип std::string.
 *  
 *  \ref CPGenerator "Преобразование контекста": данные con[0] перенаполняются новым объектом типа Int, полученным согласно "обычной" схеме извлечения числа из его десятичной записи s = \<con[0]\>:
 *  - Инициализируется значение Int x = 0;
 *  - Последовательно для каждого символа c строки s выполняется преобразование x = x * 10 + ('c' - '0').
 *  - Итоговое значение - это значение x после обработки всех символов s.
 *  
 *  \pre
 *    Тип Int \ref DObjectModification "инициализируем" от константы 0.
 *  \pre
 *    Присваивание во втором пункте схемы извлечения числа корректно.
 *  
 *  Подключающие заголовочные файлы: \ref CPGConversion "общие для всех преобразователей типов".
 *  
 *  \subsubsection CPGCchartodecimal generator::char_to_decimal\<Int\>()
 *  
 *  Аргумент: typename Int.
 *  
 *  \pre
 *    В начале разбора объект \ref pm::Data "\<con[0]\>" имеет тип char.
 *  \pre
 *    Тип Int \ref DObjectModification "инициализируем" от значения типа char.
 *  
 *  \ref CPGenerator "Преобразование контекста": данные con[0] перенаполняются новым объектом типа Int, инициализированным от значения char(\<con[0]\> - '0').
 *  
 *  Подключающие заголовочные файлы: \ref CPGConversion "общие для всех преобразователей типов".
 *  
 *  \subsubsection CPGCconvert generator::convert\<TSource, TTarget\>()
 *  
 *  Аргументы:
 *  - typename TSource.
 *  - typename TTarget.
 *  
 *  \pre
 *    В начале разбора объект \ref pm::Data "\<con[0]\>" имеет тип TSource.
 *  \pre
 *    Тип TTarget \ref DObjectModification "инициализируем" от значения типа TSource.
 *  
 *  \ref CPGenerator "Преобразование контекста": данные con[0] перенаполняются новым объектом типа TTarget, инициализированным от \<con[0]\>.
 *  
 *  Подключающие заголовочные файлы: \ref CPGConversion "общие для всех преобразователей типов".
 *  
 *  \subsection CPGFunctional Общие генераторы типизированных данных
 *  
 *  Подключающие заголовочные файлы:
 *  - \ref CPGenerator "Общие для всех генераторов данных".
 *  - include/pm/creation/parser/generator/functional.hpp
 *  
 *  \subsubsection CPGFuref generator::uref(f)
 *  
 *  Аргумент:
 *  - typename ... Args (аргумент дедуцируется автоматически при точном совпадении типа f).
 *  - std::function\<void(Args ...)\> f.
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется вызов f(\ref pm::Data "\<con[0]\>", \<con[1]\>, \<con[2]\>, ...).
 *  
 *  \pre
 *    Если сигнатура функции f - void(T0, T1, ..., Tk), то тип каждого объекта \<con[i]\>, 0 <= i <= k, совпадает с \ref DQualifiers "основой" типа Ti.
 *  \pre
 *    Выполнение вызова в преобразовании контекста корректно для типов и значений объектов в данных con в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGFunctional "общие для всех общих генераторов типизированных данных".
 *  
 *  \subsubsection CPGFuret generator::uret(f)
 *  
 *  Аргумент:
 *  - typename Ret (аргумент дедуцируется автоматически при точном совпадении типа f).
 *  - typename ... Args (аргумент дедуцируется автоматически при точном совпадении типа f).
 *  - std::function\<Ret(Args ...)\> f.
 *  
 *  \ref CPGenerator "Преобразование контекста": если сигнатура функции f - Ret(T0, T1, ..., Tk), то выполняется вызов f(\ref pm::Data "\<con[0]\>", ..., \<con[k]\>), и данные \<con[k+1]\> перенаполняются новым объектом типа, равного \ref DQualifiers "основе" типа Ret, и \ref DObjectModification "инициализированного" от результата выполнения вызова.
 *  
 *  \pre
 *    Основа типа Ret \ref DObjectModification "перемещаема".
 *  \pre
 *    Если сигнатура функции f - Ret(T0, T1, ..., Tk), то тип каждого объекта \<con[i]\>, 0 <= i <= k, совпадает с основой типа Ti.
 *  \pre
 *    Выполнение вызова преобразования контекста корректно для типов и значений объектов в данных con в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGFunctional "общие для всех общих генераторов типизированных данных".
 *  
 *  \subsubsection CPGFref generator::ref(f)
 *  
 *  Аргумент:
 *  - typename Any (аргумент дедуцируется автоматически).
 *  - typename ... Args (аргумент дедуцируется автоматически).
 *  - Any (*f)(Args ...).
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется вызов f(\ref pm::Data "\<con[0]\>", \<con[1]\>, \<con[2]\>, ...).
 *  
 *  \pre
 *    Если сигнатура функции f - void(T0, T1, ..., Tk), то тип каждого объекта \<con[i]\>, 0 <= i <= k, совпадает с \ref DQualifiers "основой" типа Ti.
 *  \pre
 *    Выполнение вызова в преобразовании контекста корректно для типов и значений объектов в данных con в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGFunctional "общие для всех общих генераторов типизированных данных".
 *  
 *  \subsubsection CPGFret generator::ret(f)
 *  
 *  Аргумент:
 *  - typename Ret (аргумент дедуцируется автоматически).
 *  - typename ... Args (аргумент дедуцируется автоматически).
 *  - Ret (*f)(Args ...).
 *  
 *  \ref CPGenerator "Преобразование контекста": если сигнатура функции f - Ret(T0, T1, ..., Tk), то выполняется вызов f(\ref pm::Data "\<con[0]\>", ..., \<con[k]\>), и данные \<con[k+1]\> перенаполняются новым объектом типа, равного \ref DQualifiers "основе" типа Ret, и \ref DObjectModification "инициализированного" от результата выполнения вызова.
 *  
 *  \pre
 *    Основа типа Ret \ref DObjectModification "перемещаема".
 *  \pre
 *    Если сигнатура функции f - Ret(T0, T1, ..., Tk), то тип каждого объекта \<con[i]\>, 0 <= i <= k, совпадает с основой типа Ti.
 *  \pre
 *    Выполнение вызова преобразования контекста корректно для типов и значений объектов в данных con в начале разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPGFunctional "общие для всех общих генераторов типизированных данных".
 *  
 *  \subsection CPGUntyped Генераторы нетипизированных данных
 *  
 *  Подключающие заголовочные файлы:
 *  - \ref CPGenerator "Общие для всех генераторов данных".
 *  - include/pm/creation/parser/generator/untyped.hpp
 *  
 *  \subsubsection CPGUcopy generator::copy()
 *  
 *  \ref CPGenerator "Преобразование контекста": \ref pm::Data "данные" con[1] перенаполняются новой \ref DObjectModification "копией" объекта con[0].
 *  
 *  \pre
 *    Тип объекта \<con[0]\> \ref DObjectModification "копируем".
 *  
 *  Подключающие заголовочные файлы: \ref CPGUntyped "общие для всех генераторов нетипизированных данных".
 *  
 *  \subsubsection CPGUswap generator::swap()
 *  
 *  \ref CPGenerator "Преобразование контекста": выполняется обмен \ref pm::Data "данных" con[0] и con[1].
 *  
 *  Подключающие заголовочные файлы: \ref CPGUntyped "общие для всех генераторов нетипизированных данных".
 *  
 *  \subsubsection CPGUunset generator::unset()
 *  
 *  \ref CPGenerator "Преобразование контекста": \ref pm::Data "данные" con[0] опустошаются.
 *  
 *  Подключающие заголовочные файлы: \ref CPGUntyped "общие для всех генераторов нетипизированных данных".
 *  
 *  \subsubsection CPGUcreate generator::create(val)
 *  
 *  Аргументы:
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется перемещение v значения val.
 *  
 *  \ref CPGenerator "Преобразование контекста": \ref pm::Data "данные" con[0] перенаполняются новой \ref DObjectModification "копией" значения v.
 *  
 *  \pre
 *    Тип объекта T \ref DObjectModification "копируем, перемещаем и уничтожим".
 *  
 *  Подключающие заголовочные файлы: \ref CPGUntyped "общие для всех генераторов нетипизированных данных".
 *  
 *  \section CPTest Парсеры проверки данных
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/test.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPTeq2 test::eq\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" == \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTeq1 test::eq\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTeq2 "test::eq\<T, T\>()"
 *  
 *  \subsection CPTneq2 test::neq\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" != \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTneq1 test::neq\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTneq2 "test::neq\<T, T\>()"
 *  
 *  \subsection CPTless2 test::less\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \< \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTless1 test::less\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTless2 "test::less\<T, T\>()"
 *  
 *  \subsection CPTlesseq2 test::lesseq\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \<= \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTlesseq1 test::lesseq\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTlesseq2 "test::lesseq\<T, T\>()"
 *  
 *  \subsection CPTgreater2 test::greater\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \> \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTgreater1 test::greater\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTgreater2 "test::greater\<T, T\>()"
 *  
 *  \subsection CPTgreatereq2 test::greatereq\<T0, T1\>()
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T1.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \>= \<con[1]\>
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: типы объектов \<con[0]\> и \<con[1]\> - в точности T0 и T1 соответственно
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и \<con[1]\> в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTgreatereq1 test::greatereq\<T\>()
 *  
 *  Аргумент: typename T.
 *  
 *  Эквивалентно \ref CPTgreatereq2 "test::greatereq\<T, T\>()"
 *  
 *  \subsection CPTeqc test::eq\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" == v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTneqc test::neq\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" != v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTlessc test::less\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \< v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTlesseqc test::lesseq\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \<= v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTgreaterc test::greater\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \> v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \subsection CPTgreatereqc test::greatereq\<T0\>(val)
 *  
 *  Аргументы:
 *  - typename T0.
 *  - typename T (дедуцируется автоматически по значению val).
 *  - T val.
 *  
 *  При создании в парсере сохраняется \ref DObjectModification "перемещение" v значения val.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Значения is и con не изменяются.
 *  - Выполняется сравнение \ref pm::Data "\<con[0]\>" \>= v.
 *  - Итог разбора равен результату выражения.
 *  
 *  \pre
 *    В начале разбора: тип объекта \<con[0]\> - в точности T0
 *  \pre
 *    Требуемое сравнение корректно для типов и значений \<con[0]\> и v в начале разбора
 *  
 *  Подключающие заголовочные файлы: \ref CPTest "общие для всех парсеров проверки данных".
 *  
 *  \section CPComposition Композиция парсеров
 *  
 *  Подключающие заголовочные файлы:
 *  - include/pm/creation/parser/composition.hpp
 *  - include/pm/creation/parser.hpp
 *  - include/pm/creation.hpp
 *  
 *  \subsection CPClor lor(pars)
 *  
 *  Аргумент: std::vector\<pm::Parser\> pars.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Последовательно выполняются *подразборы*: (is, con)-разборы элементами pars.
 *   - В порядке следования в векторе.
 *   - До первого успеха или пока не выполнятся все подразборы.
 *  - Разбор успешен \<=\> выполнен успешный подразбор.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPClorop par_left || par_right
 *  
 *  Аргументы:
 *  - pm::Parser par_left.
 *  - pm::Parser par_right.
 *  
 *  Эквивалентно \ref CPClor "lor({par_left, par_right})".
 *  
 *  \subsection CPCland land(par_left, par_right)
 *  
 *  Аргументы:
 *  - pm::Parser par_main.
 *  - pm::Parser par_second.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется *главный подразбор*: (is, con)-разбор парсером par_main.
 *  - Если главный подразбор успешен, то:
 *   - Создаётся \ref pm::Stream "поток разбора" nis, текст которого равен строке, принятой главным подразбором.
 *   - Выполняется *вспомогательный подразбор*: (nis, con)-разбор парсером par_second.
 *   - Если вспомогательный подразбор неуспешен, то восстанавливается значение is до разбора.
 *  - Разбор успешен \<=\> главный и вспомогательный разборы выполнены и успешны.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPClandop par_left && par_right
 *  
 *  Аргументы:
 *  - pm::Parser par_left.
 *  - pm::Parser par_right.
 *  
 *  Эквивалентно \ref CPCland "land(par_left, par_right)".
 *  
 *  \subsection CPClnot lnot(par)
 *  
 *  Аргументы: pm::Parser par.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется *подразбор*: (is, con)-разбор парсером par.
 *  - Итог разбора противоположен итогу подразбора.
 *  - В любом случае восстанавливается значение is до разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPClnotop !par
 *  
 *  Аргумент: pm::Parser par.
 *  
 *  Эквивалентно \ref CPClnot "lnot(par)".
 *  
 *  \subsection CPCconcat concat(pars)
 *  
 *  Аргумент: std::vector\<pm::Parser\> pars.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Последовательно выполняются *подразборы*: (is, con)-разборы элементами pars.
 *   - В порядке следования в векторе.
 *   - До первого неуспеха или пока не выполнятся все подразборы.
 *  - Разбор успешен \<=\> все подразборы выполнены успешно.
 *  - Если выполнен неуспешный подразбор, то восстанавливается значение is до разбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCconcatop par_left & par_right
 *  
 *  Аргументы:
 *  - pm::Parser par_left.
 *  - pm::Parser par_right.
 *  
 *  Эквивалентно \ref CPCconcat "concat({par_left, par_right})".
 *  
 *  \subsection CPCopt opt(par)
 *  
 *  Аргументы: pm::Parser par.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется *подразбор*: (is, con)-разбор парсером par.
 *  - Разбор успешен.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCoptop ~par
 *  
 *  Аргумент: pm::Parser par.
 *  
 *  Эквивалентно \ref CPCopt "opt(par)".
 *  
 *  \subsection CPCstar star(par)
 *  
 *  Аргументы: pm::Parser par.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Раз за разом до первого неуспеха выполняется *подразбор*: (is, con)-разбор парсером par.
 *  - Разбор успешен.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCstarop *par
 *  
 *  Аргумент: pm::Parser par.
 *  
 *  Эквивалентно \ref CPCstar "star(par)".
 *  
 *  \subsection CPCite ite(par_test, par_positive, par_negative)
 *  
 *  Аргументы:
 *  - pm::Parser par_test.
 *  - pm::Parser par_positive.
 *  - pm::Parser par_negative.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется *подразбор-условие*: (is, con)-разбор парсером par_test.
 *  - Выполняется *подразбор-ветвь*:
 *   - если подразбор-условие успешен, то (is, con)-разбор парсером par_positive,
 *   - иначе - (is, con)-разбор парсером par_negative.
 *  - Итог разбора совпадает с итогом подразбора-ветви.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCchoose2 choose(pars, data_index)
 *  
 *  Аргументы:
 *  - std::vector\<pm::Parser\> pars.
 *  - size_t data_index.
 *  
 *  \pre
 *    Объект \ref pm::Data "\<con[data_index]\>" имеет тип size_t.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Вычисляется значение i = \<con[data_index]\>.
 *  - Если размер вектора pars не превосходит i, то разбор завершается неуспешно.
 *  - Иначе выполняется *подразбор*: (is, con)-разбор парсером pars[i] - и итог разбора равен итогу подразбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCchooseop2 pars / data_index
 *  
 *  Аргументы:
 *  - std::vector\<pm::Parser\> pars.
 *  - size_t data_index.
 *  
 *  Эквивалентно \ref CPCchoose2 "choose(pars, data_index)".
 *  
 *  \subsection CPCchoose1 choose(pars)
 *  
 *  Аргумент: std::vector\<pm::Parser\> pars.
 *  
 *  Эквивалентно \ref CPCchoose2 "choose(pars, 0)".
 *  
 *  \subsection CPCsaveparsed save_parsed(par, data_index)
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - size_t data_index.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Выполняется *подразбор*: (is, con)-разбор парсером par.
 *  - Если подразбор успешен, то \ref pm::Data "данные" con[data_index] перенаполняются \ref DTypes "стандартной строкой", равной строке, \ref CPTerminology "принятой" подразбором.
 *  - Итог разбора равен итогу подразбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCsaveparsedop par \>\> data_index
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - size_t data_index.
 *  
 *  Эквивалентно \ref CPCsaveparsed "save_parsed(par, data_index)".
 *  
 *  \subsection CPCscope scope(par, data_indexes)
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - std::vector\<size_t\> data_indexes.
 *  
 *  \pre
 *    Все элементы вектора data_indexes попарно неравны.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Создаётся новый \ref pm::Context "контекст" ncon.
 *  - Для каждого \ref DTypes "индекса" i = data_indexes[j] в \ref pm::Data "данные" ncon[j] вставляется объект \ref pm::Data "\<con[i]\>".
 *  - Выполняется *подразбор*: (is, ncon)-разбор парсером par.
 *  - Данные, вставленные в ncon перед подразбором, вставляются в con на исходные места.
 *  - Итог разбора равен итогу подразбора.
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCscopeopvector par \<\< data_indexes
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - std::vector\<size_t\> data_indexes.
 *  
 *  Эквивалентно \ref CPCscope "scope(par, data_indexes)".
 *  
 *  \subsection CPCscopeopsizet par \<\< data_index
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - size_t data_index.
 *  
 *  Эквивалентно \ref CPCscope "scope(par, {data_index})".
 *  
 *  \subsection CPCscopeopempty -par
 *  
 *  Аргумент: pm::Parser par.
 *  
 *  Эквивалентно \ref CPCscope "scope(par, {})".
 *  
 *  \subsection CPCfailsafe failsafe(par)
 *  
 *  Аргумент: pm::Parser par.
 *  
 *  \ref pm::Parser::parse "(is, con)-разбор":
 *  - Создаётся \ref DObjectModification "копия" каждых \ref pm::Data "данных" con.
 *  - Выполняется *подразбор*: (is, con)-разбор парсером par.
 *  - Если подразбор неуспешен, то каждые данные con перенаполняются соответствующей копией, созданной перед подразбором.
 *  - Итог разбора равен итогу подразбора.
 *  
 *  \pre
 *    Для кажды данных con[i]: если эти данные непусты, то тип объекта \ref pm::Data "\<con[i]\>" \ref DObjectModification "копируем"
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCact act(par, a)
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - pm::parser::UnaryAction a.
 *   - Это перечисление, значения которого приводятся ниже.
 *  
 *  В зависимости от значения аргумента a выражение act(par, a) эквивалентно одной из других композиций:
 *  - UnaryAction::Not : \ref CPClnot "lnot(par)".
 *  - UnaryAction::Opt : \ref CPCopt "opt(par)".
 *  - UnaryAction::Star : \ref CPCstar "star(par)".
 *  - UnaryAction::ScopeOut : \ref CPCscope "scope(par, {})".
 *  - UnaryAction::Failsafe : \ref CPCfailsafe "failsafe(par)".
 *  
 *  Подключающие заголовочные файлы: \ref CPComposition "общие для композиции парсеров".
 *  
 *  \subsection CPCactop par \<\< a
 *  
 *  Аргументы:
 *  - pm::Parser par.
 *  - pm::parser::UnaryAction a.
 *  
 *  Эквивалентно \ref CPCact "act(par, a)".
 */
