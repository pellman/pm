/*! \file include/pm/regexp/regexp.hpp
 *  \brief Содержит класс \ref ConRegexp "регулярных выражений" pm::regexp::Regexp.
 *  
 *  \ingroup ModuleRegexp
 */

/*! \class pm::regexp::Regexp
 *  \brief Класс \ref ConRegexp "регулярных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Объект этого класса является \ref ConBaseDynamicWrapper "динамической обёрткой" над регулярным выражением в широком смысле.
 *  
 *  *Подвыражение* - это (динамически созданный) объект, на который направлена обёртка.
 *  
 *  В документации готовых регулярных выражений динамическая обёртка отождествляется со своим подвыражением.
 *  
 *  *Это выражение* - это обёртка, документируемый метод которой вызывается.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `Regexp(const Regexp & r)`
 *  --
 *  
 *  Инициализировать регулярное выражение, направленное на подвыражение выражения \p r.
 *  
 *  Конструктор перемещения: `Regexp(Regexp && r)`
 *  --
 *  
 *  Инициализировать регулярное выражение, направленное на подвыражение выражения \p r.
 *  
 *  Копирующее присваивание: `Regexp & operator =(const Regexp & r)`
 *  --
 *  
 *  Перенаправить это выражение на подвыражение выражения \p r.
 *  
 *  Перемещающее присваивание: `Regexp & operator =(Regexp && r)`
 *  --
 *  
 *  Перенаправить это выражение на подвыражение выражения \p r.
 *  
 *  Деструктор: `~Regexp()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn pm::regexp::Regexp::Regexp()
 *  \brief Инициализировать тривиальное выражение "неуспех".
 */

/*! \fn pm::regexp::Regexp::Regexp(RegexpInterface * arg_ptr)
 *  \brief Инициализировать регулярное выражение, направленное на выражение в широком смысле, располагающееся по адресу \p arg_ptr (или эквивалентное тривиальному выражению "неуспех", если `arg_ptr == nullptr`).
 *  
 *  \pre Если `arg_ptr != nullptr`, то указатель \p arg_ptr разыменовываем, и объект, располагающийся по адресу \p arg_ptr, корректно уничтожается вызовом деструктора разыменования.
 *  \pre Если `arg_ptr != nullptr`, то объект, располагающийся по адресу \p arg_ptr, разрешено уничтожать только в рамках сборки мусора \ref ConTrickyPointers "стабильных указателей" согласно документации.
 */

/*! \fn pm::regexp::Regexp::Regexp(const type_abuse::SPtr<RegexpInterface> & arg_ptr)
 *  \brief Инициализировать регулярное выражение, направленное на объект указателя \p arg_ptr.
 */

/*! \fn pm::regexp::Regexp::Regexp(type_abuse::SPtr<RegexpInterface> && arg_ptr)
 *  \brief Инициализировать регулярное выражение, направленное на объект указателя \p arg_ptr.
 */

/*! \fn bool pm::regexp::Regexp::match_full(stream::Stream & s, const Context & context) const
 *  \brief Метод полного разбора потока \p s в контексте \p context. Вызвать метод полного разбора подвыражения и вернуть результат этого вызова.
 */
