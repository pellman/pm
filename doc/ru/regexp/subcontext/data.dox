/*! \file include/pm/regexp/subcontext/data.hpp
 *  \brief Содержит класс \ref ConRegexp "регулярных данных" pm::regexp::subcontext::Data.
 *  
 *  \ingroup ModuleRegexp
 */

/*! \class pm::regexp::subcontext::Data
 *  \brief Класс \ref ConRegexp "регулярных данных".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Содержит два \ref ConTrickyPointers "указателя на данные" типа pm::type_abuse::DPtr:
 *  - указатель на текущие данные: `(*this).current`;
 *  - указатель на сохранённые данные: `(*this).safe`;
 *  
 *  *Эти регулярные данные* - это объект, документируемый метод которого вызывается.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: `Data()`
 *  --
 *  
 *  Инициализировать регулярные данные по умолчанию: новые пустые текущие данные и новые пустые сохранённые данные.
 *  
 *  Конструктор копирования: `Data(const Data & cdata)`
 *  --
 *  
 *  Инициализировать регулярные данные, все указатели которых направлены на соответствующие данные подконтекста \p cdata.
 *  
 *  Конструктор перемещения: `Data(Data && cdata)`
 *  --
 *  
 *  Инициализировать регулярные данные, все указатели которых направлены на соответствующие данные подконтекста \p cdata.
 *  
 *  Копирующее присваивание: `Data & operator =(const Data & cdata)`
 *  --
 *  
 *  Перенаправить все указатели регулярных данных на соответствующие данные подконтекста \p cdata.
 *  
 *  Перемещающее присваивание: `Data & operator =(Data && cdata)`
 *  --
 *  
 *  Перенаправить все указатели регулярных данных на соответствующие данные подконтекста \p cdata.
 *  
 *  Деструктор: `~Data()`
 *  --
 *  
 *  Стандартное значение.
 *  
 *  При уничтожении указателя на данные производится сборка мусора.
 */

/*! \fn void pm::regexp::subcontext::Data::detach()
 *  \brief Открепить все указатели этих регулярных данных.
 *  
 *  \pre Если текущие данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::subcontext::Data::detach_receive(const Data & cdata)
 *  \brief Открепить все указатели этих регулярных данных и затем перезаписать их соответствующими указателями регулярных данных \p cdata, но без фактического копирования данных при откреплении.
 *  
 *  \pre Если текущие данные регулярных данных \p cdata в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные регулярных данных \p cdata в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::subcontext::Data::detach_unset()
 *  \brief Открепить все указатели этих регулярных данных и затем сбросить их, но без фактического копирования данных при откреплении.
 */

/*! \fn void pm::regexp::subcontext::Data::receive(const Data & cdata) const
 *  \brief Перезаписать все указатели этих регулярных данных соответствующими указателями регулярных данных \p cdata.
 *  
 *  \pre Если текущие данные регулярных данных \p cdata в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные регулярных данных \p cdata в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::subcontext::Data::swap(const Data & cdata) const
 *  \brief Обменять содержимое всех указателей этих регулярных данных и соответствующих указателей регулярных данных \p cdata.
 */

/*! \fn void pm::regexp::subcontext::Data::unset() const
 *  \brief Сбросить все указатели этих регулярных данных.
 */

/*! \fn Data pm::regexp::subcontext::Data::clone() const
 *  \brief Вернуть регулярные данные, указатели которых являются клонами соответствующих указателей этих регулярных данных.
 *  
 *  \pre Если текущие данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::subcontext::Data::send(const Data & cdata) const
 *  \brief Перезаписать указатели регулярных данных \p cdata соответствующими указателями этих регулярных данных.
 *  
 *  \pre Если текущие данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этих регулярных данных в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn type_abuse::DPtr & pm::regexp::subcontext::Data::data()
 *  \brief Вернуть указатель на текущие данные этих регулярных данных.
 */

/*! \fn const type_abuse::DPtr & pm::regexp::subcontext::Data::data() const
 *  \brief Вернуть указатель на текущие данные этих регулярных данных.
 */

/*! \fn StoredType & pm::regexp::subcontext::Data::val() const
 *  \brief Вернуть текущие данные этих регулярных данных.
 *  
 *  \pre Текущие данные этих регулярных данных в момент вызова непусты и имеют тип \p StoredType.
 */

/*! \var type_abuse::DPtr pm::regexp::subcontext::Data::current
 *  \brief Указатель на текущие данные.
 */

/*! \var type_abuse::DPtr pm::regexp::subcontext::Data::safe
 *  \brief Указатель на сохранённые данные.
 */
