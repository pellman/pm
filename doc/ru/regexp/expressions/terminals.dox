/*! \file include/pm/regexp/expressions/terminals.hpp
 *  \brief Интерфейс создания \ref ConRegexp "всех тривиальных и основной части терминальных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Описание функции, возвращающей регулярное выражение, содержит
 *  - \ref ConRegexp "вид" возвращаемого выражения;
 *  - \ref ConPredefinedRegexps "название" возвращаемого выражения.
 */

/*! \fn Regexp pm::regexp::enclose(const std::string & opening_string, const std::string & closing_string)
 *  \brief Терминальное выражение: строка, обрамлённая подстроками \p opening_string и \p closing_string.
 */

/*! \fn Regexp pm::regexp::enclose(const std::string & opening_string, std::string && closing_string)
 *  \brief Терминальное выражение: строка, обрамлённая подстроками \p opening_string и \p closing_string.
 */

/*! \fn Regexp pm::regexp::enclose(std::string && opening_string, const std::string & closing_string)
 *  \brief Терминальное выражение: строка, обрамлённая подстроками \p opening_string и \p closing_string.
 */

/*! \fn Regexp pm::regexp::enclose(std::string && opening_string, std::string && closing_string)
 *  \brief Терминальное выражение: строка, обрамлённая подстроками \p opening_string и \p closing_string.
 */

/*! \fn Regexp pm::regexp::end()
 *  \brief Тривиальное выражение: конец потока.
 */

/*! \fn Regexp pm::regexp::let()
 *  \brief Терминальное выражение: любой символ.
 */

/*! \fn Regexp pm::regexp::let(char good_char)
 *  \brief Терминальное выражение: символ \p good_char.
 */

/*! \fn Regexp pm::regexp::let(const std::set<char> & good_chars)
 *  \brief Терминальное выражение: любой символ множества \p good_chars.
 */

/*! \fn Regexp pm::regexp::let(std::set<char> && good_chars)
 *  \brief Терминальное выражение: любой символ множества \p good_chars.
 */

/*! \fn Regexp pm::regexp::let(Args && ... args)
 *  \brief Терминальное выражение: любой символ множества {\p args ...}.
 *  \param[in] args Последовательность символов через запятую.
 *  
 *  Эта функция позволяет вместо pm::regexp::let({r1, r2, ..., rk}) писать pm::regexp::let(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
 *  
 *  Эквивалентно вызову `pm::regexp::let(std::set<char>{std::forward<Args>(args) ...})`.
 */

/*! \fn Regexp pm::regexp::letbut(char bad_char)
 *  \brief Терминальное выражение: любой символ, кроме символа \p bad_char.
 */

/*! \fn Regexp pm::regexp::letbut(const std::set<char> & bad_chars)
 *  \brief Терминальное выражение: любой символ, кроме символов множества \p bad_chars.
 */

/*! \fn Regexp pm::regexp::letbut(std::set<char> && bad_chars)
 *  \brief Терминальное выражение: любой символ, кроме символов множества \p bad_chars.
 */

/*! \fn Regexp pm::regexp::letbut(Args && ... args)
 *  \brief Терминальное выражение: любой символ, кроме символов множества {\p args ...}.
 *  \param[in] args Последовательность символов через запятую.
 *  
 *  Эта функция позволяет вместо pm::regexp::letbut({r1, r2, ..., rk}) писать pm::regexp::letbut(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
 *  
 *  Эквивалентно вызову `pm::regexp::letbut(std::set<char>{std::forward<Args>(args) ...})`.
 */

/*! \fn Regexp pm::regexp::range(char bottom_char, char top_char)
 *  \brief Терминальное выражение: символ от \p bottom_char до \p top_char.
 */

/*! \fn Regexp pm::regexp::re_false()
 *  \brief Тривиальное выражение: неуспех.
 */

/*! \fn Regexp pm::regexp::re_true()
 *  \brief Тривиальное выражение: успех.
 */

/*! \fn Regexp pm::regexp::str(const std::string & good_string)
 *  \brief Терминальное выражение: строка \p good_string.
 */

/*! \fn Regexp pm::regexp::str(std::string && good_string)
 *  \brief Терминальное выражение: строка \p good_string.
 */

/*! \fn Regexp pm::regexp::str(size_t len)
 *  \brief Терминальное выражение: строка длины \p len.
 */
