/*! \file include/pm/regexp/expressions/lazy_composition.hpp
 *  \brief Интерфейс ленивых операторов для создания \ref ConRegexp "основной части композициональных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Описание функции, возвращающей регулярное выражение, содержит
 *  - \ref ConRegexp "вид" возвращаемого выражения;
 *  - \ref ConPredefinedRegexps "название" возвращаемого выражения;
 *  - в некоторых случаях - требования к значениям текущих и сохранённых данных \ref ConRegexp "регулярного контекста разбора" в момент запуска метода полного разбора.
 *  
 *  В описании используются следующие обозначение:
 *  - `let(c)` - терминальное выражение "символ c";
 *  - `let(s)` - терминальное выражение "любой символ множества s";
 *  - `str(s)` - строка `s`.
 *  
 *  Общие рекомендации к использованию этих функций:
 *  - В качестве подвыражений рекомендуется использовать только \ref ConRegexp "безопасные" регулярные выражения, в противном случае процедура разбора может выполняться непредсказуемо и ошибочно.
 *  - Не рекомендуется создавать композициональные выражения, содержащие себя в качестве подвыражения (непосредственно или через цепочку вложенности выражений), так как это может приводить к **утечкам памяти**.
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r, char c)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p c)).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r, char c)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p c)).
 */

/*! \fn Regexp pm::regexp::operator |(char c, const Regexp & r)
 *  \brief Композициональное выражение: альтернатива над (let(\p c), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(char c, Regexp && r)
 *  \brief Композициональное выражение: альтернатива над (let(\p c), \p r).
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, char c)
 *  \brief Композициональное выражение: разность \p r и let(\p c).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, char c)
 *  \brief Композициональное выражение: разность \p r и let(\p c).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(char c, const Regexp & r)
 *  \brief Композициональное выражение: разность let(\p c) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(char c, Regexp && r)
 *  \brief Композициональное выражение: разность let(\p c) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r, char c)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p c)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r, char c)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p c)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(char c, const Regexp & r)
 *  \brief Композициональное выражение: конкатенация над (let(\p c), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(char c, Regexp && r)
 *  \brief Композициональное выражение: конкатенация над (let(\p c), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r, const std::set<char> & s)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r, std::set<char> && s)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r, const std::set<char> & s)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r, std::set<char> && s)
 *  \brief Композициональное выражение: альтернатива над (\p r, let(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(const std::set<char> & s, const Regexp & r)
 *  \brief Композициональное выражение: альтернатива над (let(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(const std::set<char> & s, Regexp && r)
 *  \brief Композициональное выражение: альтернатива над (let(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(std::set<char> && s, const Regexp & r)
 *  \brief Композициональное выражение: альтернатива над (let(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(std::set<char> && s, Regexp && r)
 *  \brief Композициональное выражение: альтернатива над (let(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, const std::set<char> & s)
 *  \brief Композициональное выражение: разность \p r и let(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, std::set<char> && s)
 *  \brief Композициональное выражение: разность \p r и let(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, const std::set<char> & s)
 *  \brief Композициональное выражение: разность \p r и let(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, std::set<char> && s)
 *  \brief Композициональное выражение: разность \p r и let(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const std::set<char> & s, const Regexp & r)
 *  \brief Композициональное выражение: разность let(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const std::set<char> & s, Regexp && r)
 *  \brief Композициональное выражение: разность let(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(std::set<char> && s, const Regexp & r)
 *  \brief Композициональное выражение: разность let(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(std::set<char> && s, Regexp && r)
 *  \brief Композициональное выражение: разность let(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r, const std::set<char> & s)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r, std::set<char> && s)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r, const std::set<char> & s)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r, std::set<char> && s)
 *  \brief Композициональное выражение: конкатенация над (\p r, let(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const std::set<char> & s, const Regexp & r)
 *  \brief Композициональное выражение: конкатенация над (let(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const std::set<char> & s, Regexp && r)
 *  \brief Композициональное выражение: конкатенация над (let(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(std::set<char> && s, const Regexp & r)
 *  \brief Композициональное выражение: конкатенация над (let(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(std::set<char> && s, Regexp && r)
 *  \brief Композициональное выражение: конкатенация над (let(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r, const std::string & s)
 *  \brief Композициональное выражение: альтернатива над (\p r, str(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r, std::string && s)
 *  \brief Композициональное выражение: альтернатива над (\p r, str(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r, const std::string & s)
 *  \brief Композициональное выражение: альтернатива над (\p r, str(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r, std::string && s)
 *  \brief Композициональное выражение: альтернатива над (\p r, str(\p s)).
 */

/*! \fn Regexp pm::regexp::operator |(const std::string & s, const Regexp & r)
 *  \brief Композициональное выражение: альтернатива над (str(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(const std::string & s, Regexp && r)
 *  \brief Композициональное выражение: альтернатива над (str(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(std::string && s, const Regexp & r)
 *  \brief Композициональное выражение: альтернатива над (str(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator |(std::string && s, Regexp && r)
 *  \brief Композициональное выражение: альтернатива над (str(\p s), \p r).
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, const std::string & s)
 *  \brief Композициональное выражение: разность \p r и str(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r, std::string && s)
 *  \brief Композициональное выражение: разность \p r и str(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, const std::string & s)
 *  \brief Композициональное выражение: разность \p r и str(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r, std::string && s)
 *  \brief Композициональное выражение: разность \p r и str(\p s).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const std::string & s, const Regexp & r)
 *  \brief Композициональное выражение: разность str(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const std::string & s, Regexp && r)
 *  \brief Композициональное выражение: разность str(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(std::string && s, const Regexp & r)
 *  \brief Композициональное выражение: разность str(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(std::string && s, Regexp && r)
 *  \brief Композициональное выражение: разность str(\p s) и \p r.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r, const std::string & s)
 *  \brief Композициональное выражение: конкатенация над (\p r, str(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r, std::string && s)
 *  \brief Композициональное выражение: конкатенация над (\p r, str(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r, const std::string & s)
 *  \brief Композициональное выражение: конкатенация над (\p r, str(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r, std::string && s)
 *  \brief Композициональное выражение: конкатенация над (\p r, str(\p s)).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const std::string & s, const Regexp & r)
 *  \brief Композициональное выражение: конкатенация над (str(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const std::string & s, Regexp && r)
 *  \brief Композициональное выражение: конкатенация над (str(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(std::string && s, const Regexp & r)
 *  \brief Композициональное выражение: конкатенация над (str(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(std::string && s, Regexp && r)
 *  \brief Композициональное выражение: конкатенация над (str(\p s), \p r).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */
