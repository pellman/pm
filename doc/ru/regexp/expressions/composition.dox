/*! \file include/pm/regexp/expressions/composition.hpp
 *  \brief Интерфейс создания \ref ConRegexp "основной части композициональных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Описание функции, возвращающей регулярное выражение, содержит
 *  - \ref ConRegexp "вид" возвращаемого выражения;
 *  - \ref ConPredefinedRegexps "название" возвращаемого выражения;
 *  - в некоторых случаях - требования к значениям текущих и сохранённых данных \ref ConRegexp "регулярного контекста разбора" в момент запуска метода полного разбора.
 *  
 *  Общие рекомендации к использованию этих функций:
 *  - В качестве подвыражений рекомендуется использовать только \ref ConRegexp "безопасные" регулярные выражения, в противном случае процедура разбора может выполняться непредсказуемо и ошибочно.
 *  - Не рекомендуется создавать композициональные выражения, содержащие себя в качестве подвыражения (непосредственно или через цепочку вложенности выражений), так как это может приводить к **утечкам памяти**.
 */

/*! \fn Regexp pm::regexp::alt(const std::list<Regexp> & rl)
 *  \brief Композициональное выражение: альтернатива над \p rl.
 */

/*! \fn Regexp pm::regexp::alt(std::list<Regexp> && rl)
 *  \brief Композициональное выражение: альтернатива над \p rl.
 */

/*! \fn Regexp pm::regexp::alt(Args && ... args)
 *  \brief Композициональное выражение: альтернатива над (\p args ...).
 *  
 *  Эта функция позволяет вместо pm::regexp::alt({r1, r2, ..., rk}) писать pm::regexp::alt(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
 *  
 *  Эквивалентно вызову `pm::regexp::alt(std::list<Regexp>{std::forward<Args>(args) ...})`.
 */

/*! \fn Regexp pm::regexp::but(const Regexp & positive, const Regexp & negative)
 *  \brief Композициональное выражение: разность выражений \p positive и \p negative.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::but(const Regexp & positive, Regexp && negative)
 *  \brief Композициональное выражение: разность выражений \p positive и \p negative.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::but(Regexp && positive, const Regexp & negative)
 *  \brief Композициональное выражение: разность выражений \p positive и \p negative.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::but(Regexp && positive, Regexp && negative)
 *  \brief Композициональное выражение: разность выражений \p positive и \p negative.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::concat(const std::list<Regexp> & rl)
 *  \brief Композициональное выражение: конкатенация над \p rl.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::concat(std::list<Regexp> && rl)
 *  \brief Композициональное выражение: конкатенация над \p rl.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::concat(Args && ... args)
 *  \brief Композициональное выражение: конкатенация над (\p args ...).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 *  
 *  Эта функция позволяет вместо pm::regexp::concat({r1, r2, ..., rk}) писать pm::regexp::concat(r1, r2, ..., rk): на одну пару фигурных скобок меньше.
 *  
 *  Эквивалентно вызову `pm::regexp::concat(std::list<Regexp>{std::forward<Args>(args) ...})`.
 */

/*! \fn Regexp pm::regexp::opt(const Regexp & r)
 *  \brief Композициональное выражение: опционал над \p r.
 */

/*! \fn Regexp pm::regexp::opt(Regexp && r)
 *  \brief Композициональное выражение: опционал над \p r.
 */

/*! \fn Regexp pm::regexp::star(const Regexp & r)
 *  \brief Композициональное выражение: звезда Клини над \p r.
 */

/*! \fn Regexp pm::regexp::star(Regexp && r)
 *  \brief Композициональное выражение: звезда Клини над \p r.
 */

/*! \fn Regexp pm::regexp::hide(const Regexp & r)
 *  \brief Композициональное выражение: сокрытие данных над \p r.
 */

/*! \fn Regexp pm::regexp::hide(Regexp && r)
 *  \brief Композициональное выражение: сокрытие данных над \p r.
 */

/*! \fn Regexp pm::regexp::nodata(const Regexp & r)
 *  \brief Композициональное выражение: заглушка данных над \p r.
 */

/*! \fn Regexp pm::regexp::nodata(Regexp && r)
 *  \brief Композициональное выражение: заглушка данных над \p r.
 */

/*! \fn Regexp pm::regexp::save(const Regexp & r)
 *  \brief Композициональное выражение: сохранение данных над \p r.
 *  
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::save(Regexp && r)
 *  \brief Композициональное выражение: сохранение данных над \p r.
 *  
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */
