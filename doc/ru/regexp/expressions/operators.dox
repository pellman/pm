/*! \file include/pm/regexp/expressions/operators.hpp
 *  \brief Операторный интерфейс создания \ref ConRegexp "основной части композициональных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Описание функции, возвращающей регулярное выражение, содержит
 *  - \ref ConRegexp "вид" возвращаемого выражения;
 *  - \ref ConPredefinedRegexps "название" возвращаемого выражения;
 *  - в некоторых случаях - требования к значениям текущих и сохранённых данных \ref ConRegexp "регулярного контекста разбора" в момент запуска метода полного разбора.
 *  
 *  Общие рекомендации к использованию этих функций:
 *  - В качестве подвыражений рекомендуется использовать только \ref ConRegexp "безопасные" регулярные выражения, в противном случае процедура разбора может выполняться непредсказуемо и ошибочно.
 *  - Не рекомендуется создавать композициональные выражения, содержащие себя в качестве подвыражения (непосредственно или через цепочку вложенности выражений), так как это может приводить к **утечкам памяти**.
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r1, const Regexp & r2)
 *  \brief Композициональное выражение: альтернатива над (\p r1, \p r2).
 */

/*! \fn Regexp pm::regexp::operator |(const Regexp & r1, Regexp && r2)
 *  \brief Композициональное выражение: альтернатива над (\p r1, \p r2).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r1, const Regexp & r2)
 *  \brief Композициональное выражение: альтернатива над (\p r1, \p r2).
 */

/*! \fn Regexp pm::regexp::operator |(Regexp && r1, Regexp && r2)
 *  \brief Композициональное выражение: альтернатива над (\p r1, \p r2).
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r1, const Regexp & r2)
 *  \brief Композициональное выражение: разность \p r1 и \p r2.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(const Regexp & r1, Regexp && r2)
 *  \brief Композициональное выражение: разность \p r1 и \p r2.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r1, const Regexp & r2)
 *  \brief Композициональное выражение: разность \p r1 и \p r2.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator -(Regexp && r1, Regexp && r2)
 *  \brief Композициональное выражение: разность \p r1 и \p r2.
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r1, const Regexp & r2)
 *  \brief Композициональное выражение: конкатенация над (\p r1, \p r2).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(const Regexp & r1, Regexp && r2)
 *  \brief Композициональное выражение: конкатенация над (\p r1, \p r2).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r1, const Regexp & r2)
 *  \brief Композициональное выражение: конкатенация над (\p r1, \p r2).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator &(Regexp && r1, Regexp && r2)
 *  \brief Композициональное выражение: конкатенация над (\p r1, \p r2).
 *  
 *  \pre Если текущие данные в начале разбора непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные в начале разбора непусты, то тип этих данных копируем.
 */

/*! \fn Regexp pm::regexp::operator *(const Regexp & r)
 *  \brief Композициональное выражение: звезда Клини над \p r.
 */

/*! \fn Regexp pm::regexp::operator *(Regexp && r)
 *  \brief Композициональное выражение: звезда Клини над \p r.
 */

/*! \fn Regexp pm::regexp::operator !(const Regexp & r)
 *  \brief Композициональное выражение: опционал над \p r.
 */

/*! \fn Regexp pm::regexp::operator !(Regexp && r)
 *  \brief Композициональное выражение: опционал над \p r.
 */

/*! \fn Regexp pm::regexp::operator ~(const Regexp & r)
 *  \brief Композициональное выражение: заглушка данных над \p r.
 */

/*! \fn Regexp pm::regexp::operator ~(Regexp && r)
 *  \brief Композициональное выражение: заглушка данных над \p r.
 */
