/*! \file include/pm/regexp/expressions/typical.hpp
 *  \brief Интерфейс создания \ref ConRegexp "типичных терминальных, функциональных и композициональных выражений".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Описание функции, возвращающей регулярное выражение, содержит
 *  - \ref ConRegexp "вид" возвращаемого выражения;
 *  - \ref ConPredefinedRegexps "название" возвращаемого выражения;
 *  - в некоторых случаях - требования к параметрам шаблонной функции.
 *  
 *  Общее требование по использованию возвращаемых функциональных выражений:
 *  применение содержащейся \ref ConDataFunctions "функции над данными" согласно методу полного разбора выражения корректно.
 *  
 *  Общие рекомендации к использованию функций, возвращающих композициональные выражения:
 *  - В качестве подвыражений рекомендуется использовать только \ref ConRegexp "безопасные" регулярные выражения, в противном случае процедура разбора может выполняться непредсказуемо и ошибочно.
 *  - Не рекомендуется создавать композициональные выражения, содержащие себя в качестве подвыражения (непосредственно или через цепочку вложенности выражений), так как это может приводить к **утечкам памяти**.
 */

/*! \fn Regexp pm::regexp::cget()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::clone() над текущими данными.
 */

/*! \fn Regexp pm::regexp::sget()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::clone() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::cset(Args && ... args)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::set<NewStoredValue>(std::forward<Args>(args) ...) над текущими данными.
 */

/*! \fn Regexp pm::regexp::sset(Args && ... args)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::set<NewStoredValue>(std::forward<Args>(args) ...) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::swap()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::swap() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cunset()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::unset() над текущими данными.
 */

/*! \fn Regexp pm::regexp::sunset()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::unset() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::cadd()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::add<Left, Right>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cadd(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::add<Left>(std::forward<Right>(i)) над текущими данными.
 */

/*! \fn Regexp pm::regexp::cdiv()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::div<Left, Right>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cdiv(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::div<Left>(std::forward<Right>(i)) над текущими данными.
 */

/*! \fn Regexp pm::regexp::cmod()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::mod<Left, Right>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cmod(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::mod<Left>(std::forward<Right>(i)) над текущими данными.
 */

/*! \fn Regexp pm::regexp::cmul()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::mul<Left, Right>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cmul(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::mul<Left>(std::forward<Right>(i)) над текущими данными.
 */

/*! \fn Regexp pm::regexp::csub()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::sub<Left, Right>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::csub(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::sub<Left>(std::forward<Right>(i)) над текущими данными.
 */

/*! \fn Regexp pm::regexp::sadd()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::add<Left, Right>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::sadd(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::add<Left>(std::forward<Right>(i)) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::sdiv()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::div<Left, Right>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::sdiv(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::div<Left>(std::forward<Right>(i)) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::smod()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::mod<Left, Right>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::smod(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::mod<Left>(std::forward<Right>(i)) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::smul()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::mul<Left, Right>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::smul(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::mul<Left>(std::forward<Right>(i)) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::ssub()
 *  \brief Функциональное выражение: двуместная чистая функция pm::type_abuse::funs::sub<Left, Right>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::ssub(Right && i)
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::sub<Left>(std::forward<Right>(i)) над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::cchar_to_digit()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::char_to_digit<Int>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cchar_to_string()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::char_to_string() над текущими данными.
 */

/*! \fn Regexp pm::regexp::cconvert()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::convert<To, From>() над текущими данными.
 */

/*! \fn Regexp pm::regexp::schar_to_digit()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::char_to_digit<Int>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::schar_to_string()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::char_to_string() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::sconvert()
 *  \brief Функциональное выражение: одноместная чистая функция pm::type_abuse::funs::convert<To, From>() над сохранёнными данными.
 */

/*! \fn Regexp pm::regexp::c_id_head_letter()
 *  \brief Терминальное выражение: головной символ идентификатора языка C.
 */

/*! \fn Regexp pm::regexp::c_id_tail_letter()
 *  \brief Терминальное выражение: хвостовой символ идентификатора языка C.
 */

/*! \fn Regexp pm::regexp::digit()
 *  \brief Терминальное выражение: десятичная цифра типа \p Int.
 *  
 *  \pre Тип \p Int инициализируем от значения типа `char`.
 */

/*! \fn Regexp pm::regexp::digit_letter()
 *  \brief Терминальное выражение: символ десятичной цифры.
 */

/*! \fn Regexp pm::regexp::latin_letter()
 *  \brief Терминальное выражение: латинская буква.
 */

/*! \fn Regexp pm::regexp::latin_lowercase_letter()
 *  \brief Терминальное выражение: маленькая латинская буква.
 */

/*! \fn Regexp pm::regexp::latin_uppercase_letter()
 *  \brief Терминальное выражение: большая латинская буква.
 */

/*! \fn Regexp pm::regexp::underscore_letter()
 *  \brief Терминальное выражение: символ нижнего подчёркивания.
 */

/*! \fn Regexp pm::regexp::c_id()
 *  \brief Терминальное выражение: идентификатор языка C.
 */

/*! \fn Regexp pm::regexp::decimal()
 *  \brief Терминальное выражение: десятичное число типа \p Int.
 *  
 *  \pre Тип \p Int инициализируем от значения типа `char`.
 *  \pre Выражение `i *= 10` с левой частью с объектом `i` типа \p Int корректно.
 *  \pre Выражение `i += j` с объектами `i`, `j` типа \p Int корректно.
 */

/*! \fn Regexp pm::regexp::decimal_string()
 *  \brief Терминальное выражение: строковая запись десятичного числа.
 */

/*! \fn Regexp pm::regexp::id(const Regexp & letter)
 *  \brief Терминальное композициональное выражение: идентификатор над головным выражение \p letter и хвостовым выражение \p letter.
 *  
 *  \pre Выражение \p letter удовлетворяет всем свойствам терминального выражения с типом данных `char`.
 */

/*! \fn Regexp pm::regexp::id(const Regexp & head_letter, const Regexp & tail_letter)
 *  \brief Терминальное композициональное выражение: идентификатор над головным выражение \p head_letter и хвостовым выражение \p tail_letter.
 *  
 *  \pre Выражения \p head_letter и \p tail_letter удовлетворяет всем свойствам терминального выражения с типом данных `char`.
 */
