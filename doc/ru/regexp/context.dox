/*! \file include/pm/regexp/context.hpp
 *  \brief Содержит класс \ref ConRegexp "регулярного контекста разбора" pm::regexp::Context и переменную \ref ConRegexp "регулярного контекста по умолчанию" `pm::regexp::default_context`.
 *  
 *  \ingroup ModuleRegexp
 */

/*! \class pm::regexp::Context
 *  \brief Класс \ref ConRegexp "регулярного контекста разбора".
 *  
 *  \ingroup ModuleRegexp
 *  
 *  Непосредственно содержит
 *  - два поля: строковый подконтекст castr и подконтекст данных cadata;
 *  - методы, позволяющие производить схожие операции над обоими подконтекстами сразу;
 *  - методы доступа к строке и данным совокупности контекста.
 *  
 *  С учётом вложенности полей содержит пять \ref ConTrickyPointers "хитрых указателей":
 *  - стабильный указатель типа pm::type_abuse::SPtr<std::string> на строку: `(*this).castr.cstr`;
 *  - стабильный указатель типа pm::regexp::Activator, производного от pm::type_abuse::SPtr<bool>, на флаг активности строки: `(*this).castr.cact`;
 *  - указатель типа pm::type_abuse::DPtr на текущие данные: `(*this).cadata.cdata.current`;
 *  - указатель типа pm::type_abuse::DPtr на сохранённые данные: `(*this).cadata.cdata.safe`;
 *  - стабильный указатель типа pm::regexp::Activator, производного от pm::type_abuse::SPtr<bool>, на флаг активности данных: `(*this).cadata.cact`;
 *  
 *  *Этот контекст* - это объект, документируемый метод которого вызывается.
 *  
 *  **Запрещено** направлять стабильные указатели контекста на объекты, типы которых отличны от базовых типов этих указателей.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: `Context()`
 *  
 *  Инициализировать контекст по умолчанию: новая пустая строка, пара новых пустых данных, пара новых опущенных флагов.
 *  
 *  Конструктор копирования: `Context(const Context & c)`
 *  --
 *  
 *  Инициализировать контекст, указатели которого направлены на соответствующие данные контекста \p c.
 *  
 *  Конструктор перемещения: `Context(Context && c)`
 *  --
 *  
 *  Инициализировать контекст, указатели которого направлены на соответствующие данные контекста \p c.
 *  
 *  Копирующее присваивание: `Context & operator =(const Context & c)`
 *  --
 *  
 *  Перенаправить все указатели этого контекста на соответствующие данные контекста \p c.
 *  
 *  Перемещающее присваивание: `Context & operator =(Context && c)`
 *  --
 *  
 *  Перенаправить все указатели этого контекста на соответствующие данные контекста \p c.
 *  
 *  Деструктор: `~Context()`
 *  --
 *  
 *  Стандартное значение.
 *  При уничтожении указателей этого контекста производится сборка мусора.
 */

/*! \fn void pm::regexp::Context::detach()
 *  \brief Открепить все указатели этого контекста.
 *  
 *  \pre Если текущие данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::Context::detach_receive(const Context & context)
 *  \brief Открепить все указатели этого контекста и затем перезаписать их соответствующими указателями контекста \p context, но без фактического копирования данных при откреплении.
 *  
 *  \pre Если текущие данные контекста \p context в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные контекста \p context в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::Context::activate() const
 *  \brief Активировать оба подконтекста (строковый, данных) этого контекста.
 */

/*! \fn void pm::regexp::Context::deactivate() const
 *  \brief Деактивировать оба подконтекста (строковый, данных) этого контекста.
 */

/*! \fn void pm::regexp::Context::receive(const Context & context) const
 *  \brief Перезаписать все указатели этого контекста соответствующими указателями контекста \p context.
 *  
 *  \pre Если текущие данные контекста \p context в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные контекста \p context в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::Context::swap(const Context & context) const
 *  \brief Обменять содержимое всех указателей этого контекста и соответствующих указателей контекста \p context.
 */

/*! \fn Context pm::regexp::Context::clone() const
 *  \brief Вернуть контекст, все указатели которого являются клонами соответствующих указателей этого контекста.
 *  
 *  \pre Если текущие данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn void pm::regexp::Context::send(const Context & context) const
 *  \brief Перезаписать все указатели контекста \p context соответствующими указателями этого контекста.
 *  
 *  \pre Если текущие данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 *  \pre Если сохранённые данные этого контекста в момент вызова непусты, то тип этих данных копируем.
 */

/*! \fn bool pm::regexp::Context::active() const
 *  \brief Вернуть `true` <=> хотя бы один из подконтекстов (строковый, данных) этого контекста активен.
 */

/*! \fn type_abuse::DPtr & pm::regexp::Context::data()
 *  \brief Вернуть указатель на текущие данные этого контекста.
 */

/*! \fn const type_abuse::DPtr & pm::regexp::Context::data() const
 *  \brief Вернуть указатель на текущие данные этого контекста.
 */

/*! \fn bool pm::regexp::Context::inactive() const
 *  \brief Вернуть `true` <=> оба подконтекста (строковый, данных) этого контекста неактивны.
 */

/*! \fn std::string & pm::regexp::Context::str() const
 *  \brief Вернуть строку этого контекста.
 *  
 *  Возвращается разыменование указателя на строку этого контекста.
 */

/*! \fn StoredType & pm::regexp::Context::val() const
 *  \brief Вернуть текущие данные этого контекста.
 *  
 *  \pre Текущие данные этого контекста в момент вызова непусты и имеют тип \p StoredType.
 */

/*! \var subcontext::AString pm::regexp::Context::castr
 *  \brief Строковый подконтекст.
 */

/*! \var subcontext::AData pm::regexp::Context::cadata
 *  \brief Подконтекст данных.
 */

/*! \var const Context pm::regexp::default_context
 *  \brief Контекст по умолчанию.
 *  
 *  **Не рекомендуется** изменять данные этого контекста, так как это может привести к непредсказуемым и ошибочным результатам.
 */
