/*! \file include/pm/type_abuse/funs.hpp
 *  \brief Содержит тип одноместных \ref ConDataFunctions "чистых функций над данными" pm::type_abuse::UnFun, тип двуместных чистых функций над данными pm::type_abuse::BinFun и глобальные функции, возвращающие полезные функциональные объекты этих двух типов.
 *  
 *  \ingroup ModuleTypeAbuse
 *  
 *  Действия, приводящиеся в описании документируемой глобальной функции - это действия, производимые возвращаемым функциональным объектом при применении его к
 *  - указателю на данные `ptr` для pm::type_abuse::UnFun;
 *  - указателям на данные `ptr1`, `ptr2` для pm::type_abuse::BinFun.
 */

/*! \typedef std::function<void(const DPtr &, const DPtr &)> pm::type_abuse::BinFun
 *  \brief Тип двуместных чистых функций над данными.
 */

/*! \typedef std::function<void(const DPtr &)> pm::type_abuse::UnFun
 *  \brief Тип одноместных чистых функций над данными.
 */

/*! \fn BinFun pm::type_abuse::funs::clone()
 *  \brief Перезаписать указатель `ptr1` указателем `ptr2`.
 *  
 *  \pre Если данные указателя `ptr2` непусты в момент применения, то тип этих данных копируем.
 */

/*! \fn BinFun pm::type_abuse::funs::swap()
 *  \brief Обменять содержимое указателей `ptr1` и `ptr2`.
 */

/*! \fn UnFun pm::type_abuse::funs::unset()
 *  \brief Сбросить указатель `ptr`.
 */

/*! \fn UnFun pm::type_abuse::funs::set(Args && ... args)
 *  \brief Переустановить указатель `ptr` в тип \p Datatype от аргументов \p args.
 *  
 *  \pre Тип \p DataType допускает инициализацию от аргументов \p args.
 */

/*! \fn BinFun pm::type_abuse::funs::add()
 *  \brief Выполнить присваивание `*ptr1 += *ptr2`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип \p Left.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип \p Right.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 */

/*! \fn UnFun pm::type_abuse::funs::add(Right && i)
 *  \brief Выполнить присваивание `*ptr += i`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p Left.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 *  \pre Если в качестве аргумента подаётся lvalue-значение, то тип \p Right копируем, а если rvalue-значение, то перемещаем.
 */

/*! \fn BinFun pm::type_abuse::funs::div()
 *  \brief Выполнить присваивание `*ptr1 /= *ptr2`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип \p Left.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип \p Right.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 */

/*! \fn UnFun pm::type_abuse::funs::div(Right && i)
 *  \brief Выполнить присваивание `*ptr /= i`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p Left.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 *  \pre Если в качестве аргумента подаётся lvalue-значение, то тип \p Right копируем, а если rvalue-значение, то перемещаем.
 */

/*! \fn BinFun pm::type_abuse::funs::mod()
 *  \brief Выполнить присваивание `*ptr1 %= *ptr2`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип \p Left.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип \p Right.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 */

/*! \fn UnFun pm::type_abuse::funs::mod(Right && i)
 *  \brief Выполнить присваивание `*ptr %= i`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p Left.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 *  \pre Если в качестве аргумента подаётся lvalue-значение, то тип \p Right копируем, а если rvalue-значение, то перемещаем.
 */

/*! \fn BinFun pm::type_abuse::funs::mul()
 *  \brief Выполнить присваивание `*ptr1 *= *ptr2`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип \p Left.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип \p Right.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 */

/*! \fn UnFun pm::type_abuse::funs::mul(Right && i)
 *  \brief Выполнить присваивание `*ptr *= i`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p Left.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 *  \pre Если в качестве аргумента подаётся lvalue-значение, то тип \p Right копируем, а если rvalue-значение, то перемещаем.
 */

/*! \fn BinFun pm::type_abuse::funs::sub()
 *  \brief Выполнить присваивание `*ptr1 /= *ptr2`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип \p Left.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип \p Right.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 */

/*! \fn UnFun pm::type_abuse::funs::sub(Right && i)
 *  \brief Выполнить присваивание `*ptr -= i`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p Left.
 *  \pre Выполняемое присваивание корректно для типов \p Left и \p Right.
 *  \pre Если в качестве аргумента подаётся lvalue-значение, то тип \p Right копируем, а если rvalue-значение, то перемещаем.
 */

/*! \fn UnFun pm::type_abuse::funs::convert()
 *  \brief Переустановить указатель `ptr` в тип \p To от значения `*ptr` (как rvalue).
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип \p From.
 *  \pre Тип \p To инициализируем от значения типа \p From.
 */

/*! \fn UnFun pm::type_abuse::funs::char_to_digit()
 *  \brief Переустановить указатель `ptr` в тип \p Int от значения `(*ptr - '0')`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип `char`.
 *  \pre Тип \p Int инициализируем от значения типа `char`.
 */

/*! \fn UnFun pm::type_abuse::funs::char_to_string()
 *  \brief Переустановить указатель `ptr` в тип `std::string` от аргументов `(1, *ptr)`.
 *  
 *  `std::string(1, c)` - это строка длины `1`, содержащая единственный символ `c`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип `char`.
 */

/*! \fn BinFun pm::type_abuse::funs::bref(const std::function<void(Arg1, Arg2)> & f)
 *  \brief Применить ссылочную функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 */

/*! \fn BinFun pm::type_abuse::funs::bref(std::function<void(Arg1, Arg2)> && f)
 *  \brief Применить ссылочную функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 */

/*! \fn BinFun pm::type_abuse::funs::bren(const std::function<Ret(Arg1, Arg2)> & f)
 *  \brief Применить переустанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn BinFun pm::type_abuse::funs::bren(std::function<Ret(Arg1, Arg2)> && f)
 *  \brief Применить переустанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn BinFun pm::type_abuse::funs::bret(const std::function<Ret(Arg)> & f)
 *  \brief Применить устанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn BinFun pm::type_abuse::funs::bret(std::function<Ret(Arg)> && f)
 *  \brief Применить устанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::uref(const std::function<void(Arg)> & f)
 *  \brief Применить ссылочную функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 */

/*! \fn UnFun pm::type_abuse::funs::uref(std::function<void(Arg)> && f)
 *  \brief Применить ссылочную функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 */

/*! \fn UnFun pm::type_abuse::funs::uren(const std::function<Ret(Arg)> & f)
 *  \brief Применить переустанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::uren(std::function<Ret(Arg)> && f)
 *  \brief Применить переустанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::uret(const std::function<Ret()> & f)
 *  \brief Применить устанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::uret(std::function<Ret()> && f)
 *  \brief Применить устанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn BinFun pm::type_abuse::funs::ref(AnyRet (*f)(Arg1, Arg2))
 *  \brief Применить ссылочную функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 */

/*! \fn UnFun pm::type_abuse::funs::ref(AnyRet (*f)(Arg))
 *  \brief Применить ссылочную функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 */

/*! \fn BinFun pm::type_abuse::funs::ren(Ret (*f)(Arg1, Arg2))
 *  \brief Применить переустанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr1` в момент применения непусты и имеют тип, равный основе типа \p Arg1.
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg2.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::ren(Ret (*f)(Arg))
 *  \brief Применить переустанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Данные указателя `ptr` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn BinFun pm::type_abuse::funs::ret(Ret (*f)(Arg))
 *  \brief Применить устанавливающую функцию \p f к указателям `(ptr1, ptr2)`.
 *  
 *  \pre Данные указателя `ptr2` в момент применения непусты и имеют тип, равный основе типа \p Arg.
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */

/*! \fn UnFun pm::type_abuse::funs::ret(Ret (*f)())
 *  \brief Применить устанавливающую функцию \p f к указателю `ptr`.
 *  
 *  \pre Основа типа \p Ret перемещаема и уничтожаема.
 */
