/*! \file include/pm/type_abuse/sptr.hpp
 *  \brief Содержит шаблонный класс \ref ConTrickyPointers "стабильных указателей" pm::type_abuse::SPtr.
 *  
 *  \ingroup ModuleTypeAbuse
 */

/*! \class pm::type_abuse::SPtr
 *  \brief Класс \ref ConTrickyPointers "стабильных указателей".
 *  
 *  \ingroup ModuleTypeAbuse
 *  
 *  \tparam Base Базовый тип указателя.
 *  \pre Тип \p Base уничтожаем.
 *  
 *  *Этот указатель* - это объект, документируемый метод которого вызывается.
 *  
 *  Данные стабильного указателя, используемого согласно документации, всегда непусты.
 *  В связи с этим в документации указателя вместо термина "данные" используется более привычный термин "объект".
 *  
 *  *Метод с потерей связи* - это метод, при вызове которого исчезает связь указателя с объектом до вызова.
 *  Если эта связь не восстанавливается (согласно документации) по завершении вызова, то инициируется сборка мусора для объекта, связь с которым разоравана.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `SPtr(const SPtr<Base> & ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на объект указателя \p ptr.
 *  
 *  Конструктор перемещения: `SPtr(SPtr<Base> && ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на объект указателя \p ptr.
 *  
 *  Копирующее присваивание: `SPtr<Base> & operator =(const SPtr<Base> & ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на объект указателя \p ptr.
 *  
 *  Перемещающее присваивание: `SPtr<Base> & operator =(SPtr<Base> && ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на объект указателя \p ptr.
 *  
 *  Деструктор: `~SPtr()`
 *  --
 *  
 *  Стандартное значение. Метод с потерей связи.
 */

/*! \fn pm::type_abuse::SPtr::SPtr()
 *  \brief Инициализировать указатель по умолчанию.
 *  
 *  \pre Тип \p Base инициализируем по умолчанию.
 */

/*! \fn pm::type_abuse::SPtr::SPtr(Base * ptr)
 *  \brief Если `ptr == nullptr`, то инициализировать указатель по умолчанию, а иначе инициализировать указатель, направленный на объект, располагающийся по адресу `ptr`.
 *  
 *  \pre Тип \p Base инициализируем по умолчанию.
 *  \pre Если `ptr != nullptr`, то указатель \p ptr разыменовываем, и объект, располагающийся по адресу \p ptr, корректно уничтожается вызовом деструктора разыменования указателя \p ptr.
 *  \pre Если `ptr != nullptr`, то объект, располагающийся по адресу \p ptr, разрешено уничтожать только в рамках сборки мусора хитрых указателей, направленных на этот объект методами, не принимающими этот адрес в качестве аргумента.
 */

/*! \fn pm::type_abuse::SPtr::SPtr(const Base & obj)
 *  \brief Инициализировать указатель, направленный на копию объекта \p obj.
 *  
 *  \pre Тип \p Base копируем.
 */

/*! \fn pm::type_abuse::SPtr::SPtr(Base && obj)
 *  \brief Инициализировать указатель, направленный на перемещение объекта \p obj.
 *  
 *  \pre Тип \p Base перемещаем.
 */

/*! \fn Base * pm::type_abuse::SPtr::operator ->() const
 *  \brief Оператор доступа к членам разыменования этого указателя.
 */

/*! \fn Base & pm::type_abuse::SPtr::operator *() const
 *  \brief Вернуть разыменование этого указателя.
 */

/*! \fn void pm::type_abuse::SPtr::detach()
 *  \brief Открепить этот указатель.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p Base копируем.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::detach_own(Base * ptr)
 *  \brief Если `ptr == nullptr`, то перенаправить этот указатель на объект по умолчанию, а иначе перенаправить этот указатель на объект, располагающийся по адресу `ptr`.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p Base инициализируем по умолчанию.
 *  \pre Если `ptr != nullptr`, то указатель \p ptr разыменовываем, и объект, располагающийся по адресу \p ptr, корректно уничтожается вызовом деструктора разыменования указателя \p ptr.
 *  \pre Если `ptr != nullptr`, то объект, располагающийся по адресу \p ptr, разрешено уничтожать только в рамках сборки мусора хитрых указателей, направленных на этот объект методами, не принимающими адрес \p ptr в качестве аргумента.
 */

/*! \fn void pm::type_abuse::SPtr::detach_receive(const SPtr<Base> & ptr)
 *  \brief Открепить этот указатель и затем перезаписать его указателем \p ptr, но без фактического копирования исходного объекта при откреплении.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p Base копируем.
 *  \pre Фактический тип объекта указателя \p ptr в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::detach_set(Args && ... args)
 *  \brief Открепить этот указатель и затем переустановить его от аргументов \p args, но без фактического копирования исходного объекта при откреплении.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p Base инициализируем от аргументов \p args.
 */

/*! \fn void pm::type_abuse::SPtr::detach_unset()
 *  \brief Открепить и затем сбросить этот указатель, но без фактического копирования исходного объекта при откреплении.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p Base инициализируем по умолчанию.
 */

/*! \fn void pm::type_abuse::SPtr::receive(const SPtr<Base> & ptr) const
 *  \brief Перезаписать этот указатель указателем \p ptr.
 *  
 *  \pre Тип \p Base копируем через присваивание.
 *  \pre Фактические типы объектов этого указателя и указателя \p ptr в момент вызова совпадают с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::set(Args && ... args) const
 *  \brief Переустановить указатель от аргументов \p args.
 *  
 *  \pre Тип \p Base инициализируем от аргументов \p args и перемещаем через присваивание.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::swap(Base & obj) const
 *  \brief Выполнить выражение `std::swap(*ptr, obj)`, где `ptr` - этот указатель.
 *  
 *  \pre Тип \p Base перемещаем и перемещаем через присваивание.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::swap(const SPtr<Base> & ptr) const
 *  \brief Обменять содержимое этого указателя и указателя \p ptr.
 *  
 *  \pre Тип \p Base перемещаем и перемещаем через присваивание.
 *  \pre Фактические типы объектов этого указателя и указателя \p ptr в момент вызова совпадают с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::unset() const
 *  \brief Сбросить указатель.
 *  
 *  \pre Тип \p Base инициализируем по умолчанию и перемещаем через присваивание.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn SPtr<Base> pm::type_abuse::SPtr::clone() const
 *  \brief Вернуть клона этого указателя.
 *  
 *  \pre Тип \p Base копируем.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn void pm::type_abuse::SPtr::send(const SPtr<Base> & ptr) const
 *  \brief Перезаписать указатель \p ptr этим указателем.
 *  
 *  \pre Тип \p Base копируем через присваивание.
 *  \pre Фактические типы объектов этого указателя и указателя \p ptr в момент вызова совпадают с \p Base.
 */

/*! \fn Base * pm::type_abuse::SPtr::get() const
 *  \brief Вернуть адрес, по которому располагается объект, связанный с этим указателем.
 *  
 *  \pre Объект, располагающийся по возвращаемому адресу, разрешено уничтожать только в рамках сборки мусора хитрых указателей, направленных на этот объект методами, не принимающими этот адрес в качестве аргумента.
 */

/*! \fn Base * pm::type_abuse::SPtr::get_copy() const
 *  \brief Создать новую копию объекта, связанного с этим указателем, и вернуть адрес, по которому расположилась эта копия.
 *  
 *  Созданный объект, располагающийся по возвращаемому адресу, не участвует в сборке мусора.
 *  
 *  \pre Тип \p Base копируем.
 *  \pre Фактический тип объекта этого указателя в момент вызова совпадает с \p Base.
 */

/*! \fn Base & pm::type_abuse::SPtr::val() const
 *  \brief Вернуть разыменование этого указателя.
 */

/*! \fn SPtr<Base> pm::type_abuse::make_sptr(Args && ... args)
 *  \brief Создать объект типа \p Base, инициализированный от аргументов \p args, и вернуть указатель, связанный с этим объектом.
 *  
 *  Создание объекта - это выполнение выражения `new Base(std::forward<Args>(args) ...)`.
 *  Возвращаемый указатель - единственный связанный с созданным объектом.
 *  
 *  \pre Тип \p Base инициализируем от аргументов \p args.
 */
