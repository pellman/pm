/*! \file include/pm/type_abuse/dptr.hpp
 *  \brief Содержит класс \ref ConTrickyPointers "указателей на данные" pm::type_abuse::DPtr.
 *  
 *  \ingroup ModuleTypeAbuse
 */

/*! \class pm::type_abuse::DPtr
 *  \brief Класс \ref ConTrickyPointers "указателей на данные".
 *  
 *  \ingroup ModuleTypeAbuse
 *  
 *  *Этот указатель* - это объект, документируемый метод которого вызывается.
 *  
 *  *Метод с потерей связи* - это метод, при вызове которого исчезает связь указателя с объектом до вызова.
 *  Если эта связь не восстанавливается (согласно документации) по завершении вызова, то инициируется сборка мусора для объекта, связь с которым разоравана.
 *  
 *  *Уничтожающий метод* - это метод, при вызове которого текущие данные, связанные с указателем, в обязательном порядке уничтожаются в рамках сборки мусора.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `DPtr(const DPtr & ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на данные указателя \p ptr.
 *  
 *  Конструктор перемещения: `DPtr(DPtr && ptr)`
 *  --
 *  
 *  Инициализировать указатель, направленный на данные указателя \p ptr.
 *  
 *  Копирующее присваивание: `DPtr & operator =(const DPtr & ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на данные указателя \p ptr.
 *  
 *  Перемещающее присваивание: `DPtr & operator =(DPtr && ptr)`
 *  --
 *  
 *  Перенаправить этот указатель на данные указателя \p ptr.
 *  
 *  Деструктор: `~DPtr()`
 *  --
 *  
 *  Стандартное значение. Метод с потерей связи.
 */

/*! \fn pm::type_abuse::DPtr::DPtr()
 *  \brief Инициализировать указатель по умолчанию.
 */

/*! \fn pm::type_abuse::DPtr::operator bool() const
 *  \brief Вернуть `true` <=> данные этого указателя непусты.
 */

/*! \fn void pm::type_abuse::DPtr::detach()
 *  \brief Открепить этот указатель.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Если данные этого указателя непусты, то их тип копируем.
 */

/*! \fn void pm::type_abuse::DPtr::detach_receive(const DPtr & ptr)
 *  \brief Открепить этот указатель и затем перезаписать его указателем \p ptr, но без фактического копирования данных при откреплении.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Если данные указателя \p ptr в момент вызова непусты, то их тип копируем.
 */

/*! \fn void pm::type_abuse::DPtr::detach_set(Args && ... args)
 *  \brief Открепить этот указатель и затем переустановить его в тип \p NewStoredType, но без фактического копирования данных при откреплении.
 *  
 *  Метод с потерей связи.
 *  
 *  \pre Тип \p NewStoredType инициализируем от аргументов \p args и уничтожаем.
 */

/*! \fn void pm::type_abuse::DPtr::detach_unset()
 *  \brief Открепить и затем сбросить этот указатель, но без фактического копирования данных при откреплении.
 *  
 *  Метод с потерей связи.
 */

/*! \fn void pm::type_abuse::DPtr::receive(const DPtr & ptr) const
 *  \brief Перезаписать этот указатель указателем \p ptr.
 *  
 *  Уничтожающий метод.
 *  
 *  \pre Если данные указателя \p ptr в момент вызова непусты, то их тип копируем.
 */

/*! \fn void pm::type_abuse::DPtr::set(Args && ... args) const
 *  \brief Переустановить этот указатель в тип \p NewStoredType от аргументов \p args.
 *  
 *  Уничтожающий метод.
 *  
 *  \pre Тип \p NewStoredType инициализируем от аргументов \p args и уничтожаем.
 */

/*! \fn void pm::type_abuse::DPtr::swap(const DPtr & ptr) const
 *  \brief Обменять содержимое этого указателя и указателя \p ptr.
 */

/*! \fn void pm::type_abuse::DPtr::unset() const
 *  \brief Сбросить этот указатель.
 *  
 *  Уничтожающий метод.
 */

/*! \fn DPtr pm::type_abuse::DPtr::clone() const
 *  \brief Вернуть клона этого указателя.
 *  
 *  \pre Если данные этого указателя в момент вызова непусты, то их тип копируем.
 */

/*! \fn void pm::type_abuse::DPtr::send(const DPtr & ptr) const
 *  \brief Перезаписать указатель \p ptr этим указателем.
 *  
 *  Данные, хранившиеся в \p ptr в момент вызова, уничтожаются в обязательном порядке в рамках сборки мусора.
 *  
 *  \pre Если данные этого указателя в момент вызова непусты, то их тип копируем.
 */

/*! \fn bool pm::type_abuse::DPtr::empty() const
 *  \brief Вернуть `true` <=> данные этого указателя пусты.
 */

/*! \fn bool pm::type_abuse::DPtr::nonempty() const
 *  \brief Вернуть `true` <=> данные этого указателя непусты.
 */

/*! \fn StoredType & pm::type_abuse::DPtr::val() const
 *  \brief Вернуть ссылку на данные этого указателя.
 *  
 *  \pre Данные этого указателя в момент вызова непусты, и их тип совпадает с \p StoredType.
 */

/*! \fn DPtr pm::type_abuse::make_dptr(Args && ... args)
 *  \brief Создать объект типа \p StoredType, инициализированный от аргументов \p args, и вернуть указатель, связанный с этим объектом.
 *  
 *  Создание объекта - это выполнение выражения `new StoredType(std::forward<Args>(args) ...)`.
 *  Возвращаемый указатель - единственный связанный с созданным объектом.
 *  
 *  \pre Тип \p StoredType инициализируем от аргументов \p args и уничтожаем.
 */

/*! \fn StoredType & pm::type_abuse::val(const DPtr & ptr)
 *  \brief Вернуть ссылку на данные указателя \p ptr.
 *  
 *  \pre Данные указателя \p ptr в момент вызова непусты, и их тип совпадает с \p StoredType.
 */
