/*! \file include/pm/dataset/syntax/function.hpp
 *  \brief Содержит класс \ref ConDataset "определения функции над совокупностью данных" pm::dataset::Function.
 *  
 *  \ingroup ModuleDataset
 */

/*! \class pm::dataset::syntax::Function
 *  \brief Класс \ref ConDataset "определения функции над совокупностью данных".
 *  
 *  \ingroup ModuleDataset
 *  
 *  Объект этого класса является \ref ConBaseDynamicWrapper "динамической обёрткой" над определением функции над совокупностью данных в широком смысле.
 *  
 *  *Подопределение* - это определение функции над совокупностью данных в широком смысле, на которое направлена обёртка.
 *  
 *  В документации готовых определений функций над совокупностью данных динамическая обёртка отождествляется со своим подопределением.
 *  
 *  *Это выражение* - это обёртка, документируемый метод которой вызывается.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `Function(const Function & f)`
 *  --
 *  
 *  Инициализировать определение, направленное на подопределение определения \p f.
 *  
 *  Конструктор перемещения: `Function(Function && f)`
 *  --
 *  
 *  Инициализировать определение, направленное на подопределение определения \p f.
 *  
 *  Копирующее присваивание: `Function & operator =(const Function & f)`
 *  --
 *  
 *  Перенаправить определение на подопределение опеределения \p f.
 *  
 *  Перемещающее присваивание: `Function & operator =(Function && f)`
 *  --
 *  
 *  Перенаправить определение на подопределение опеределения \p f.
 *  
 *  Деструктор: `~Function()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn pm::dataset::syntax::Function::Function() = default
 *  \brief Инициализировать определение тривиальной функции.
 */

/*! \fn pm::dataset::syntax::Function::Function(FunctionInterface * ptr)
 *  \brief Инициализировать определение, направленное на определение в широком смысле, располагающееся по адресу \p ptr (если `ptr == nullptr`, то на определение тривиальной функции).
 *  
 *  \pre Если `ptr != nullptr`, то указатель \p ptr разыменовываем, и объект, располагающийся по адресу \p ptr, корректно уничтожается вызовом деструктора разыменования.
 *  \pre Если `ptr != nullptr`, то объект, располагающийся по адресу \p ptr, разрешено уничтожать только в рамках сборки мусора \ref ConTrickyPointers "стабильных указателей" согласно документации.
 */

/*! \fn pm::dataset::syntax::Function::Function(const type_abuse::SPtr<FunctionInterface> & ptr)
 *  \brief Инициализировать определение, направленное на объект указателя \p ptr.
 */

/*! \fn pm::dataset::syntax::Function::Function(type_abuse::SPtr<FunctionInterface> && ptr)
 *  \brief Инициализировать определение, направленное на объект указателя \p ptr.
 */

/*! \fn Function pm::dataset::syntax::Function::interpret(Set & s) const
 *  \brief Метод интерпретации. Вызвать метод интерпретации подфункции и вернуть полученный результат.
 */
