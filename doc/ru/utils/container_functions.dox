/*! \file include/pm/utils/container_functions.hpp
 *  \brief Содержит функции, упрощающие работу с stl-контейнерами.
 *  
 *  \ingroup ModuleUtils
 */

/*! \fn void pm::utils::append(Container & to, const Container & from)
 *  \brief Добавить элементы контейнера \p from в конец контейнера \p to.
 *  
 *  Выполнение функции эквивалентно выполнению выражения `to.insert(to.end(), from.begin(), from.end())`.
 *  
 *  \pre Выражение `to.insert(to.end(), from.begin(), from.end())` корректно.
 */

/*! \fn bool pm::utils::disjoint(const Container & X, const Container & Y)
 *  \brief Вернуть `true` <=> контейнеры \p X, \p Y не содержат \ref ConBaseEqualValues "равных" элементов.
 *  
 *  `true` <=> итерированием по контейнерам \p X, \p Y невозможно получить элементы `x`, `y` соответственно, такие что значения этих элементов равны.
 *  
 *  \pre Тип значений элементов, содержащихся в контейнере, \ref ConBaseComparableType "сравним".
 *  \pre \p X должен поддерживает итерацию при помощи range-based for.
 *  \pre Выражение `container.find(element) != container.end()`, где `element` получается итерацией при помощи range-based for по \p X, корректно.
 */

/*! \fn void pm::utils::erase_index(Container & container, size_t ind)
 *  \brief Удалить \p ind -й элемент из контейнера \p container
 *  
 *  Выполнение функции эквивалентно выполнению выражения `container.erase(container.begin() + ind)`.
 *  
 *  \pre Выражение `container.erase(container.begin() + ind)` корректно.
 */

/*! \fn bool pm::utils::intersects(const Container & X, const Container & Y)
 *  \brief Вернуть `true` <=> контейнеры \p X, \p Y содержат \ref ConBaseEqualValues "равные" элементы.
 *  
 *  `true` <=> итерированием по контейнерам \p X, \p Y можно получить элементы `x`, `y` соответственно, такие что значения этих элементов равны.
 *  
 *  \pre Тип значений элементов, содержащихся в контейнере, \ref ConBaseComparableType "сравним".
 *  \pre \p X должен поддерживает итерацию при помощи range-based for.
 *  \pre Выражение `container.find(element) != container.end()`, где `element` получается итерацией при помощи range-based for по \p X, корректно.
 */

/*! \fn bool pm::utils::is_in(const Element & element, const Container & container)
 *  \brief Вернуть `true` <=> в контейнере \p container содержится элемент, \ref ConBaseEqualValues "равный" \p element.
 *  
 *  Возвращаемое значение равно значению выражения `container.find(element) != container.end()`.
 *  
 *  \pre Тип значений элементов, содержащихся в контейнере, \ref ConBaseComparableType "сравним".
 *  \pre Выражение `container.find(element) != container.end()` корректно.
 */

/*! \fn bool pm::utils::isnt_in(const Element & element, const Container & container)
 *  \brief Вернуть `true` <=> контейнер \p container не содержит элементов, \ref ConBaseEqualValues "равных" \p element.
 *  
 *  Возвращаемое значение равно значению выражения `container.find(element) == container.end()`.
 *  
 *  \pre Тип значений элементов, содержащихся в контейнере, \ref ConBaseComparableType "сравним".
 *  \pre Выражение `container.find(element) == container.end()` корректно.
 */

/*! \fn void pm::utils::merge(Container & to, const Container & from)
 *  \brief Добавить элементы упорядоченного контейнера \p from в упорядоченный контейнер \p to.
 *  
 *  Выполнение функции эквивалентно выполнению выражения `to.insert(from.begin(), from.end())`.
 *  
 *  \pre Выражение `to.insert(from.begin(), from.end())` корректно.
 */
