/*! \file include/pm/grammar/syntax/action.hpp
 *  \brief Содержит класс \ref ConGrammar "определения грамматического действия" pm::grammar::syntax::Action.
 *  
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::syntax::Action
 *  \brief Класс \ref ConGrammar "определения грамматического действия".
 *  
 *  \ingroup ModuleGrammar
 *  
 *  Объект этого класса является \ref ConBaseDynamicWrapper "динамической обёрткой" особенным (недокументированным) объектом - определением грамматического действия в широком смысле.
 *  
 *  *Подопределение* - это (динамически созданный) объект, на который направлена обёртка.
 *  
 *  В документации готовых определений грамматических действий динамическая обёртка отождествляется со своим подопределением.
 *  
 *  *Это действие* - это обёртка, документируемый метод которой вызывается.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор копирования: `Action(const Action & a)`
 *  --
 *  
 *  Инициализировать определение, направленное на подопределение определения \p a.
 *  
 *  Конструктор перемещения: `Action(Action && a)`
 *  --
 *  
 *  Инициализировать определение, направленное на подопределение определения \p a.
 *  
 *  Копирующее присваивание: `Action & operator =(const Action & a)`
 *  --
 *  
 *  Перенаправить это определение на подопределение определения \p a.
 *  
 *  Перемещающее присваивание: `Action & operator =(Action && a)`
 *  --
 *  
 *  Перенаправить это определение на подопределение определения \p a.
 *  
 *  Деструктор: `~Action()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn pm::grammar::syntax::Action::Action()
 *  \brief Инициализировать определение действия "неуспех".
 */

/*! \fn pm::grammar::syntax::Action::Action(ActionInterface * arg_ptr)
 *  \brief Инициализировать определение, направленное на определение грамматического действия в широком смысле, располагающееся по адресу \p arg_ptr (или эквивалентное определению действия "неуспех", если `arg_ptr == nullptr`).
 *  
 *  \pre Если `arg_ptr != nullptr`, то указатель \p arg_ptr разыменовываем, и объект, располагающийся по адресу \p arg_ptr, корректно уничтожается вызовом деструктора разыменования.
 *  \pre Если `arg_ptr != nullptr`, то объект, располагающийся по адресу \p arg_ptr, разрешено уничтожать только в рамках сборки мусора \ref ConTrickyPointers "стабильных указателей" согласно документации.
 */

/*! \fn pm::grammar::syntax::Action::Action(const type_abuse::SPtr<ActionInterface> & arg_ptr)
 *  \brief Инициализировать определение, направленное на объект указателя \p arg_ptr.
 */

/*! \fn pm::grammar::syntax::Action::Action(type_abuse::SPtr<ActionInterface> && arg_ptr)
 *  \brief Инициализировать определение, направленное на объект указателя \p arg_ptr.
 */
