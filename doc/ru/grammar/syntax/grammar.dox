/*! \file include/pm/grammar/syntax/grammar.hpp
 *  \brief Содержит класс \ref ConGrammar "определения грамматики" pm::grammar::syntax::Grammar.
 *  
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::syntax::Grammar
 *  \brief Класс \ref ConGrammar "определения грамматики".
 *  
 *  \ingroup ModuleGrammar
 *  
 *  *Эта определение* - это объект, документируемый метод которого вызывается.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: Grammar()
 *  --
 *  
 *  Инициализировать определение, при интерпретации возвращающее грамматику, инициализированную по умолчанию.
 *  
 *  Конструктор копирования: `Grammar(const Grammar & g)`
 *  --
 *  
 *  Инициализировать определение, содержащее копию всего, что содержится в \p g.
 *  
 *  Конструктор перемещения: `Grammar(Grammar && g)`
 *  --
 *  
 *  Инициализировать определение, содержащее перемещение всего, что содержится в \p g.
 *  
 *  Копирующее присваивание: `Grammar & operator =(const Grammar & g)`
 *  --
 *  
 *  Перенаполнить определение копией всего, что содержится в \p g.
 *  
 *  Перемещающее присваивание: `Grammar & operator =(Grammar && g)`
 *  --
 *  
 *  Перенаполнить определение перемещением всего, что содержится в \p g.
 *  
 *  Деструктор: `Grammar()`
 *  --
 *  
 *  Стандартное значение.
 */

/*! \fn Action & pm::grammar::syntax::Grammar::operator [](const std::string & name)
 *  \brief Если это определение не содержит определения действия с именем \p name, то добавить определение неуспеха и присвоить ему имя \p name. В любом случае вернуть определение действия, которому сопоставлено имя \p name.
 */

/*! \fn Action & pm::grammar::syntax::Grammar::operator [](std::string && name)
 *  \brief Если это определение не содержит определения действия с именем \p name, то добавить определение неуспеха и присвоить ему имя \p name. В любом случае вернуть определение действия, которому сопоставлено имя \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, const Action & a)
 *  \brief Добавить в это определение грамматики определение действия \p a и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, Action && a)
 *  \brief Добавить в это определение грамматики определение действия \p a и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, const Action & a)
 *  \brief Добавить в это определение грамматики определение действия \p a и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, Action && a)
 *  \brief Добавить в это определение грамматики определение действия \p a и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 */

/*! \fn void pm::grammar::syntax::Grammar::add(const std::string & name, Args && ... args)
 *  \brief Добавить в это определение грамматики определение действия ac(\p a) и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 *  
 *  Позволяет писать add(name, args ...) вместо add(name, ac(args ...)): на несколько букв меньше.
 *  
 *  Эквивалентно вызову add(name, ac(std::forward<Args>(args) ...)).
 */

/*! \fn void pm::grammar::syntax::Grammar::add(std::string && name, Args && ... args)
 *  \brief Добавить в это определение грамматики определение действия ac(\p a) и все определения, содержащиеся в нём прямо или косвенно. Присвоить добавленному определению действия имя \p name. Если в определении грамматики содержалось определение действия с именем \p name, то это определение действия становится неименованным.
 *  
 *  Позволяет писать add(name, args ...) вместо add(name, ac(args ...)): на несколько букв меньше.
 *  
 *  Эквивалентно вызову add(std::move(name), ac(std::forward<Args>(args) ...)).
 */

/*! \fn void pm::grammar::syntax::Grammar::erase(const std::string & action_name)
 *  \brief Если это определение грамматики содержало определение действия с именем \p action_name, то сделать это определение неименованным. В противном случае ничего не делать.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main(const std::string & name)
 *  \brief Добавить в это определение имя главного действия \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main(std::string && name)
 *  \brief Добавить в это определение имя главного действия \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main_data(const std::string & name)
 *  \brief Добавить в это определение имя главных данных \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_main_data(std::string && name)
 *  \brief Добавить в это определение имя главных данных \p name.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_skip(const regexp::Regexp & re)
 *  \brief Добавить в это определение пробельное регулярное выражение \p re.
 */

/*! \fn void pm::grammar::syntax::Grammar::set_skip(regexp::Regexp && re)
 *  \brief Добавить в это определение пробельное регулярное выражение \p re.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_main()
 *  \brief Удалить из этого определения имя главного действия.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_main_data()
 *  \brief Удалить из этого определения имя главных данных.
 */

/*! \fn void pm::grammar::syntax::Grammar::unset_skip()
 *  \brief Удалить из этого определения пробельное регулярное выражение.
 */

/*! \fn grammar::Grammar pm::grammar::syntax::Grammar::interpret() const
 *  \brief Метод интерпретации без предоставления отображений имён действий и данных, получаемых по итогам интерпретации.
 */

/*! \fn grammar::Grammar pm::grammar::syntax::Grammar::interpret(InterpretInfo & ii) const
 *  \brief Метод интерпретации с предоставлением отображений имён действий и данных, получаемых по итогам интерпретации.
 *  
 *  По завершении работы метода в структуре данных \p ii содержатся:
 *  - отображение \f$ \varphi_n \f$ имён определений грамматических действий в индексы соответствующих действий в возвращаемой грамматике;
 *  - определение совокупности данных, содержащее отображение \f$ \varphi_d \f$ имён данных в индексы совокупности.
 */
