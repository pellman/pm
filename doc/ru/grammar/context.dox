/*! \file include/pm/grammar/context.hpp
 *  \brief Содержит класс \ref ConGrammar "грамматического контекста разбора" pm::grammar::Context и переменную \ref ConGrammar "грамматического контекста по умолчанию" `pm::grammar::default_context`.
 *  
 *  \ingroup ModuleGrammar
 */

/*! \class pm::grammar::Context
 *  \brief Класс \ref ConGrammar "грамматического контекста разбора".
 *  
 *  \ingroup ModuleGrammar
 *  
 *  Непосредственно содержит
 *  - два поля: строковый подконтекст castr и подконтекст грамматических данных cadataset;
 *  - методы, позволяющие производить схожие операции над обоими подконтекстами сразу;
 *  - методы доступа к строке и текущим данным контекста.
 *  
 *  С учётом вложенности полей содержит следующие \ref ConTrickyPointers "хитрые указатели":
 *  - стабильный указатель типа pm::type_abuse::SPtr<std::string> на строку: `(*this).castr.cstr`;
 *  - стабильный указатель типа pm::regexp::Activator, производного от pm::type_abuse::SPtr<bool>, на флаг активности строки: `(*this).castr.cact`;
 *  - указатели типа pm::type_abuse::DPtr совокупности данных: `(*this).cadataset.cds.data(i)` - `i`-й указатель совокупности;
 *  - стабильный указатель типа pm::regexp::Activator, производного от pm::type_abuse::SPtr<bool>, на флаг активности данных: `(*this).cadata.cact`;
 *  
 *  *Этот контекст* - это объект, документируемый метод которого вызывается.
 *  
 *  **Запрещено** направлять стабильные указатели контекста на объекты, типы которых отличны от базовых типов этих указателей.
 *  
 *  Особые свойства класса
 *  ==
 *  
 *  \ref ConBaseValidState "Нестандартно-корректен".
 *  
 *  Неявные методы
 *  ==
 *  
 *  Конструктор по умолчанию: `Context()`
 *  
 *  Инициализировать контекст по умолчанию: новая пустая строка, новая совокупность данных по умолчанию, пара новых опущенных флагов.
 *  
 *  Конструктор копирования: `Context(const Context & c)`
 *  --
 *  
 *  Инициализировать контекст, указатели которого направлены на соответствующие данные контекста \p c.
 *  
 *  Конструктор перемещения: `Context(Context && c)`
 *  --
 *  
 *  Инициализировать контекст, указатели которого направлены на соответствующие данные контекста \p c.
 *  
 *  Копирующее присваивание: `Context & operator =(const Context & c)`
 *  --
 *  
 *  Перенаправить все указатели этого контекста на соответствующие данные контекста \p c.
 *  
 *  Перемещающее присваивание: `Context & operator =(Context && c)`
 *  --
 *  
 *  Перенаправить все указатели этого контекста на соответствующие данные контекста \p c.
 *  
 *  Деструктор: `~Context()`
 *  --
 *  
 *  Стандартное значение.
 *  При уничтожении указателей этого контекста производится сборка мусора.
 */

/*! \fn void pm::grammar::Context::detach()
 *  \brief Открепить все указатели этого контекста.
 *  
 *  \pre Для любого индекса `i` верно: если `i`-е данные совокупности этого контекста непусты, то тип этих данных копируем.
 */

/*! \fn void pm::grammar::Context::detach_receive(const Context & context)
 *  \brief Открепить все указатели этого контекста и затем перезаписать их соответствующими указателями контекста \p context, но без фактического копирования данных при откреплении.
 *  
 *  \pre Для любого индекса `i` верно: если `i`-е данные совокупности контекста \p context непусты, то тип этих данных копируем.
 */

/*! \fn void pm::grammar::Context::activate() const
 *  \brief Активировать оба подконтекста (строковый, данных) этого контекста.
 */

/*! \fn void pm::grammar::Context::deactivate() const
 *  \brief Деактивировать оба подконтекста (строковый, данных) этого контекста.
 */

/*! \fn void pm::grammar::Context::receive(const Context & context) const
 *  \brief Перезаписать все указатели этого контекста соответствующими указателями контекста \p context.
 *  
 *  \pre Для любого индекса `i` верно: если `i`-е данные совокупности контекста \p context непусты, то тип этих данных копируем.
 */

/*! \fn void pm::grammar::Context::swap(const Context & context) const
 *  \brief Обменять содержимое всех указателей этого контекста и соответствующих указателей контекста \p context.
 */

/*! \fn Context pm::grammar::Context::clone() const
 *  \brief Вернуть контекст, все указатели которого являются клонами соответствующих указателей этого контекста.
 *  
 *  \pre Для любого индекса `i` верно: если `i`-е данные совокупности этого контекста непусты, то тип этих данных копируем.
 */

/*! \fn void pm::grammar::Context::send(const Context & context) const
 *  \brief Перезаписать все указатели контекста \p context соответствующими указателями этого контекста.
 *  
 *  \pre Для любого индекса `i` верно: если `i`-е данные совокупности этого контекста непусты, то тип этих данных копируем.
 */

/*! \fn bool pm::grammar::Context::active() const
 *  \brief Вернуть `true` <=> хотя бы один из подконтекстов (строковый, данных) этого контекста активен.
 */

/*! \fn const type_abuse::DPtr & pm::grammar::Context::data(size_t i) const
 *  \brief Вернуть указатель на i-е данные совокупности этого контекста.
 */

/*! \fn bool pm::grammar::Context::inactive() const
 *  \brief Вернуть `true` <=> оба подконтекста (строковый, данных) этого контекста неактивны.
 */

/*! \fn std::string & pm::grammar::Context::str() const
 *  \brief Вернуть строку этого контекста.
 *  
 *  Возвращается разыменование указателя на строку этого контекста.
 */

/*! \fn StoredType & pm::grammar::Context::val(size_t i) const
 *  \brief Вернуть i-е данные совокупности этого контекста.
 *  
 *  \pre i-е данные совокупности этого контекста в момент вызова непусты и имеют тип \p StoredType.
 */

/*! \var subcontext::AString pm::grammar::Context::castr
 *  \brief Строковый подконтекст.
 */

/*! \var subcontext::AData pm::grammar::Context::cadataset
 *  \brief Подконтекст грамматических данных.
 */

/*! \var Context pm::grammar::default_context
 *  \brief Грамматический контекст по умолчанию.
 *  
 *  **Не рекомендуется** изменять данные этого контекста, так как это может привести к непредсказуемым и ошибочным результатам.
 */
