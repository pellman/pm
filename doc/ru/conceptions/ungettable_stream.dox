/*! \page ConUngettableStream Возвратный поток
 * 
 * Введение
 * --
 * 
 * \ref ConBaseStandardTypes "Стандартный поток ввода" содержит методы `std::istream::unget()` и `std::istream::putback(char c)`, которые кладут \ref ConBaseStandardTypes "символ" обратно в поток (`unget` - последний прочитанный, `putback` - поданный в качестве аргумента).
 * Эти методы были бы невероятно полезны при нетривиальной работе с потоками, включающей в себя возврат символов, если бы не один огромный недостаток:
 * они по большому счёту **не предоставляют никаких гарантий**, то есть имеют возможность завершиться неуспехом и не вернуть символ в поток, и если пользователь получает конкретный объект типа `std::istream`, то он не может точно предсказать, завершится ли каждый конкретный вызов метода возврата символа успехом.
 * 
 * Понятие возвратного потока возникло из желания избавиться от этого недостатка и добавить возможность всегда успешно возвращать символы в поток.
 * 
 * Понятийная база
 * --
 * 
 * *Возвратный поток* \f$ S \f$ - это \ref ConStream "поток", содержащий стандартный потока ввода \f$ S.is \f$ и буфер \f$ S.b \f$.
 * Буфер в каждый момент времени хранит конечную последовательность символов произвольной длины (*последовательность буфера*).
 * Возвратный поток инициализируется *пустым* буфером: буфером, не содержащим ни одного символа (последовательность буфера пуста).
 * 
 * *Размер буфера* \f$ B \f$, то есть размер последовательности этого буфера, будет обозначаться так: \f$ |B| \f$.
 * Последовательность буфера \f$ B \f$ будет изображаться так: \f$ B[1], B[2], \dots, B[k] \f$, где \f$ B[i] \f$ - i-й по порядку символ этой последовательности, и \f$ k = |B| \f$.
 * 
 * Возвратный поток стабилен тогда и только тогда, когда его стандартный поток ввода стабилен.
 * Возвратный поток ввода закрыт тогда и только тогда, когда его буфер пуст и его стандартный поток ввода закрыт.
 * 
 * *Чтение символа* из возвратного потока \f$ S \f$ устроено так:
 * - Если буфер \f$ S.b \f$ непуст, то чтение успешно, прочитанный символ - это первый символ последовательности буфера, и этот символ удаляется из этой последовательности.
 * - Если буфер \f$ S.b \f$ пуст, то чтение равносильно чтению из потока \f$ S.is \f$.
 * 
 * *Чтение строки длины не более N* из возвратного потока \f$ S \f$ устроено так.
 * Производится многократное чтение символа из \f$ S \f$:
 * N раз, если в буфере \f$ S.b \f$ и потоке \f$ S.is \f$ суммарно содержится не менее N символов, и до первого неуспешного чтения иначе.
 * В любом случае определена *прочитанная строка* (см. \ref ConBaseStandardTypes), содержащая в точности все успешно прочитанные символы в порядке их чтения от первого к последнему.
 * 
 * *Чтение строки длины N* из возвратного потока \f$ S \f$ устроено так.
 * Из потока читается строка `s` длины не более N.
 * Если строка `s` имеет длину N, то чтение успешно, и `s` объявляется *прочитанной строкой*.
 * Иначе (если строка `s` имеет длину строго меньше N) чтение неуспешно, и строка `s` возвращается в поток \f$ S \f$ (операция возврата в поток описана ниже).
 * 
 * При *возврате символа* `c` в возвратный поток \f$ S \f$ этот символ добавляется в начало последовательности буфера \f$ S.b \f$:
 * если до возврата в \f$ S.b \f$ содержалась последовательность \f$ a_1, a_2, \dots, a_k \f$, то после возврата в \f$ S.b \f$ будет содержаться последовательность \f$ c, a_1, a_2, \dots, a_k \f$.
 * 
 * При *возврате строки* `s` в возвратный поток \f$ S \f$ эта строка добавляется в начало буфера \f$ S.b \f$:
 * если символы строки от первого до последнего равны \f$ c_1, c_2, \dots, c_m \f$ и до возврата в \f$ S.b \f$ содержалась последовательность \f$ a_1, a_2, \dots, a_k \f$, то после возврата в \f$ S.b \f$ будет содержаться последовательность \f$ c_1, с_2, \dots, c_m, a_1, a_2, \dots, a_k \f$.
 * 
 * Реализация
 * --
 * 
 * *Возвратный поток* - это объект класса pm::stream::Stream.
 * 
 * В реализации возвратного потока есть одна тонкость, которую можно смело игнорировать, если в программе не создаются явно объекты типа pm::stream::Stream.
 * Возвратный поток содержит не стандартный поток ввода как таковой, а lvalue-ссылку на него.
 * 
 * Если стандартный поток ввода, на который ссылается возвратный поток, уничтожен, то дальнейшее использование возвратного потока (вызов методов, использование в качестве аргумента функции, ...) может привести к непредсказуемому и ошибочному поведению.
 * 
 * Кроме того, стандартный поток ввода, на который ссылается возвратный поток, остаётся доступным извне возвратного потока.
 * Его можно использовать, но следует иметь в виду, что это (контролируемым образом) портит стабильность потока.
 */
