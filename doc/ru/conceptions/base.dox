/*! \page ConBase Общие понятия
 *  
 *  \section ConBaseStandard Стандартные понятия
 *  
 *  В документации то тут, то там используются разнообразные стандартные понятия:
 *  - понятия, определяемые стандартом языка, в числе прочего - его синтаксисом и описанием стандартных библиотек;
 *  - понятия, которые не фигурируют явно в стандарте, но нередко используются программистами при общении между собой.
 *  Во избежание недоразумений и разночтений некоторые из этих понятий явно описаны в следующих подразделах.
 *  
 *  \subsection ConBaseStandardTypes Стандартные типы
 *  
 *  *Символ* - это объект типа `char`.
 *  
 *  *Строка* - это объект типа `std::string`.
 *  
 *  *Стандартный поток ввода* - это объект типа `std::istream`.
 *  
 *  *Строковый поток ввода* - это объект типа `std::stringstream`, который также может выступать в роли стандартного потока ввода (наследуется от `std::istream` и может преобразовываться соответствующим образом).
 *  
 *  *Флаг* - это объект типа `bool`.
 *  Флаг *поднят*, если значение этого объекта - `true`, и *опущен*, если значение этого объекта - `false`.
 *  *Поднять флаг* и *опустить флаг* - это записать в флаг значения `true` и `false` соответственно.
 *  
 *  \subsection ConBaseStandardNotions Стандартная терминология
 *  
 *  *cv-квалификаторы* - это ключевые слова `const` и `volatile` в определении типа.
 *  
 *  *lvalue-ссылка* - это ключевой символ `&` в определении типа.
 *  
 *  *rvalue-ссылка* - это ключевое сочетание символов `&&` в определении типа.
 *  
 *  *Ссылка* - это lvalue-ссылка или rvalue-ссылка.
 *  
 *  *Основа* (decay) типа `T` - это тип, получаемый из `T` удалением cv-квалификаторов и ссылок на внешнем уровне описания типа.
 *  
 *  Пример: `int` - это основа типов `int`, `const int &`, `int &&`.
 *  
 *  *Вызов функции* (или любого функционального объекта) `f` с аргументами `a1, ..., ak` - это выражение `f(a1, ..., ak)`.
 *  *Момент вызова* - это момент времени выполнения программы, такой что следующим выполняется вызов.
 *  
 *  *Инициализация* объекта `obj` типа `T` от аргументов `a1, ..., ak` - это выполнение вызова `T(a1, ..., ak)` при создании объекта `obj`.
 *  
 *  *Инициализация по умолчанию* - это инициализация от пустого набора аргументов: `T()`.
 *  
 *  *Копирование объекта* `obj` типа `T` - это инициализация нового объекта того же типа от выражения `obj` типа `const T &`: `new T(obj)`.
 *  *Копия объекта* `obj` - это объект, инициализируемый копированием от `obj`.
 *  
 *  *Перемещение объекта* `obj` типа `T` - это
 *  - (процесс) инициализация нового объекта того же типа от выражения `obj` типа `T &&`: `new T(obj)`;
 *  - (объект) объект, инициализируемый перемещением от `obj`.
 *  
 *  *Копирующее присваивание* для типа `T` - это присваивание (`=`), левая часть которого имеет тип `T &`, а правая - `const T &`.
 *  *Перемещающее присваивание* для типа `T` - это присваивание (`=`), левая часть которого имеет тип `T &`, а правая - `T &&`.
 *  
 *  *Уничтожение объекта* типа `T` - это выполнение вызова его деструктора: `~T()` - с освобождением памяти, занимаемой объектом.
 *  
 *  Тип `T` является
 *  - *инициализируемым по умолчанию*, если инициализация по умолчанию корректна;
 *  - *инициализируемым от заданных аргументов*, если инициализация от этих аргументов корректна;
 *  - *копируемым*, если инициализация копированием корректна;
 *  - *перемещаемым*, если инициализация перемещением корректна;
 *  - *копируемым через присваивание*, если выполнение копирующего присваивания корректно;
 *  - *перемещаемым через присваивание*, если выполнение перемещающего присваивания корректно;
 *  - *уничтожаем*, если уничтожение корректно.
 *  
 *  *Цикл по коллекции* - это выражение вида `for(T var : collection) {...}`, введённое в стандарте C++11.
 *  Тип *совместим с циклом по коллекции*, если объект этого типа можно использовать справа от двоеточия в цикле по коллекции.
 *  *Перебор элементов* в переменной `var` - это последовательное присваивание переменной `var` элементов коллекции согласно семантике цикла по коллекции.
 *  
 *  \section ConBaseValidState Корректное состояние объекта
 *  
 *  Использование объекта (согласно документации) допустимо только для объектов, находящихся *в корректном состоянии*.
 *  Это понятие аналогично одноимённому понятию (valid state) стандарта языка C++, но всё же отличается для некоторых классов, определённых в \ref index "этой библиотеке".
 *  
 *  *Стандартно-корректный* класс находится в корректном состоянии, если верно следующее:
 *  - он инициализирован;
 *  - он не уничтожен и не находится в процессе уничтожения;
 *  - ни один его метод не находится в процессе выполнения.
 *  При перемещении объекта стандартно-корректного класса этот объект переходит в неспецифицированное корректное состояние.
 *  
 *  *Нестандартно-корректный* класс находится в корректном состоянии, если верно следующее:
 *  - он инициализирован;
 *  - он не уничтожен и не находится в процессе уничтожения;
 *  - ни один его метод не находится в процессе выполнения;
 *  - он не перемещён и не находится в процессе перемещения, либо после последнего перемещения ему было присвоено значение объекта в корректном состоянии через копирование или перемещение.
 *  Перемещённый объект нестандартно-корректного класса корректно уничтожается, но использование этого объекта (вызов методов, подача в качестве аргумента функции, ...) запрещено.
 *  
 *  \section ConBaseDynamicWrapper Динамическая обёртка
 *  
 *  Многие классы \ref index "этой библиотеки" могут быть единообразно описаны следующим образом: это класс,
 *  - наследуемый от некоторого класса `Base`;
 *  - специальным образом указывающий на динамически созданный объект, наследованный от класса `Base`, - *подобъект*;
 *  - перегружающий виртуальные методы класса `Base`, кроме виртуального деструктора, следующим образом:
 *   - вызвать соответствующий метод подобъекта;
 *   - вернуть результат вызванного метода.
 *  
 *  Класс, устроенный таким образом, в документации называется *динамической обёрткой* над `Base`.
 *  
 *  Интерфейс работы с динамическими обёртками удовлетворяет следующим свойствам:
 *  - Копирование, перемещение, копирующее присваивание и перемещающее присваивание - это "легковесные" операции: подобъект никак не затрагивается, соответствующее действие производится над указателем обёртки.
 *  - При создании динамической обёртки, не инициализируемой от других динамических обёрток, динамически создаётся новый подобъект, и эта операция настолько же легковесна, насколько и копирование/перемещение данных, используемых при создании.
 *  - Класс динамической обёртки поддерживает сборку мусора: подобъект уничтожается, когда на него перестаёт кто-либо указывать.
 *  - Не рекомендуется при работе с динамическими обёртками создавать кольцевые ссылки, так как это может приводить к **утечкам памяти**.
 *   - Кольцевая ссылка выглядит так: подобъект, содержащий обёртку, содержащую подобъект, ... содержащий обёртку, указывающую на исходный подобъект.
 *  
 *  \section ConBaseComparisons Сравнение объектов
 *  
 *  \subsection ConBaseComparableType Сравнимый тип
 *  
 *  В некоторых шаблонных классах и функциях явно или косвенно накладывается следующее ограничение на тип `T` - аргумент шаблона:
 *  - <em>==-сравнимость</em>: любые корректные значения `x`, `y` типа `T` можно проверить на равенство: `x == y`;
 *  - <em><-сравнимость</em>: любые корректные значения `x`, `y` типа `T` можно проверить на строгое неравенство: `x < y`.
 *  
 *  *Сравнимый тип* - это ==-сравнимый или <-сравнимый тип.
 *  
 *  \subsection ConBaseEqualValues Равные значения
 *  
 *  Значения `x`, `y` ==-сравнимого типа *равны*, если проверка выражение `x == y` возвращает `true`.
 *  
 *  Значения `x`, `y` <-сравнимого типа *равны*, если проверка выражение `!(x < y) && !(y < x)` возвращает `true`.
 *  
 *  \subsection ConBaseSet Множество
 *  
 *  *Множество* в математическом понимании пояснений не требует.
 *  Стандартные обозначения для множеств:
 *  - \f$ \emptyset \f$ - пустое множество: множество, не содержащее ни одного элемента;
 *  - \f$ |s| \f$ - размер множества: количество элементов, содержащихся в \f$ s \f$
 *  - \f$ s_1 \cup s_2 \f$ - объединение множеств \f$ s_1 \f$, \f$ s_2 \f$: множество, содержащее в точности те элементы, которые содержатся хотя бы в одном из множеств \f$ s_1 \f$, \f$ s_2 \f$;
 *  - \f$ s_1 \cap s_2 \f$ - пересечение множеств \f$ s_1 \f$, \f$ s_2 \f$: множество, содержащее в точности те элементы, которые содержатся и в \f$ s_1 \f$, и в \f$ s_2 \f$;
 *  - \f$ s_1 \setminus s_2 \f$ - разность множеств \f$ s_1 \f$, \f$ s_2 \f$: множество, содержащее в точности те элементы, которые содержатся в \f$ s_1 \f$ и не содержатся в \f$ s_2 \f$.
 *  
 *  *Множество* в привязке к реализации - это содержащаяся в контейнере совокупность объектов заданного сравнимого типа, такая что значения любых двух различных содержащихся элементов неравны.
 */
