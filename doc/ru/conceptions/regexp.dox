/*! \page ConRegexp Регулярное выражение
 * 
 * Регулярные выражения - это довольно известное понятие, так что описание того, что это такое в целом, зачем применяется и каким бывает в других местах, здесь не приводится.
 * Здесь обсуждается то, как устроена вариация регулярных выражений, реализованная в \ref index "этой библиотеке".
 * 
 * Описание регулярных выражений \ref index "этой библиотеки" разделено на две части:
 * - *Абстрактная понятийная база*. В этой части рассказывается, что в принципе может называться регулярным выражением и как оно может работать в наиболее общем случае. Введение большинства понятий явно или неявно заканчивается тем, что с этим понятием можно творить всё что только вздумается, даже если это будет крайне неразумно. Это сделано намеренно: реализация этих понятий предоставляет большую свободу действий, и оценка разумности использования этих понятий вне рамок интерфейса второй части описания предоставляется пользователю.
 * - *Конкретная понятийная база*. Она включает в себя описание спектра готовых регулярных выражений, реализованных в библиотеке, и свод принципов работы этих выражений, позволяющих их "идейно просто" комбинировать и использовать с предсказуемым разумным результатом.
 * 
 * Абстрактная понятийная база
 * ==
 * 
 * Разбор потока
 * --
 * 
 * *Процедура разбора возвратного потока* (см. \ref ConUngettableStream) - это совокупность действий, включающих, в числе прочего:
 * - чтение \ref ConBaseStandardTypes "символов" и \ref ConBaseStandardTypes "строк" из потока;
 * - возврат символов и строк в поток;
 * - извлечение полезной информации из прочитанных символов и строк;
 * - обязательно в качестве последнего действия - выдачу *итога разбора*: \ref ConBaseStandardTypes "флага", поднятого при положительном итоге (*успехе*) опущенном при отрицательном итоге (*неуспехе*).
 * Процедура разбора возвратного потока в общем случае может как угодно сочетать эти действия (творить что хочет).
 * 
 * Интерфейс регулярных выражений
 * --
 * 
 * *Интерфейс регулярного выражения* включает в себя несколько *методов разбора* и один виртуальный *метод полного разбора*.
 * 
 * Метод полного разбора возвратного потока `s` в контексте `c` запускает процедуру разбора потока `s` с извлечением полезной информации, особенным образом прописанной в структуре данных `c`, называемой далее регулярным контекстом разбора и подробно описанной ниже в одноимённом подразделе.
 * Методом полного разбора возвращается итог разбора.
 * Принцип работы регулярного выражения полностью определяется тем, как именно переопределён (перегружен) этот метод.
 * 
 * Методов разбора всего три:
 * - Метод разбора возвратного потока `s` в контексте `c`:
 *  - вызывается (перегруженный) метод полного разбора возвратного потока `s` в контексте `c`;
 *  - возвращается итог, полученный вызванным методом.
 * - Метод разбора \ref ConBaseStandardTypes "станадртного потока ввода" `s` в контексте `c`:
 *  - создаётся возвратный поток, содержащий стандартный поток ввода `s`;
 *  - вызывается метод разбора созданного возвратного потока в контексте `c`;
 *  - возвращается итог, полученный вызванным методом.
 * - Метод разбора строки `s` в регулярном контексте `c`:
 *  - создаётся \ref ConBaseStandardTypes "строковый поток ввода", содержащий копию строки `s`;
 *  - вызывается метод разбора стандартного потока ввода созданного потока в контексте `c`;
 *  - возвращается итог, полученный вызванным методом.
 * Если в вызове метода контекст явно не указан, то подразумевается особый контекст по умолчанию, согласно которому никакая полезная информация процедурой разбора не извлекается.
 * 
 * Регулярный контекст разбора
 * --
 * 
 * В *регулярном контексте разбора* с учётом вложенности полей содержатся пять \ref ConTrickyPointers "хитрых указателей":
 * - стабильный указатель на строку;
 * - стабильный указатель на флаг активности строки;
 * - указатель на текущие данные;
 * - указатель на сохранённые данные;
 * - стабильный указатель на флаг активности данных.
 * Данные, хранящиеся в этих пяти указателях, называются также *данными контекста* и данными, *содержащимися в контексте*.
 * 
 * Указатель на строку и на флаг активности строки в совокупности образуют *строковый подконтекст*.
 * Указатель на текущие данные и указатель на сохранённые данные в совокупности образуют *регулярные данные*.
 * Регулярные данные и указатель на флаг активности данных в совокупности образуют *подконтекст регулярных данных*.
 * 
 * Подконтекст *активен*, если его флаг активности поднят, и *неактивен*, если флаг активности опущен.
 * *Активировать подконтекст* - это поднять флаг активности подконтекста.
 * *Деактивировать подконтекст* - это опустить флаг активности подконтекста.
 * 
 * До конца раздела регулярный контекст разбора называется просто *контекстом*.
 * 
 * При работе с контекстом следует иметь в виду, что:
 * - при копировании контекста разделяется владение данными, то есть оба контекста начинают указывать на одни и те же данные;
 * - указатели контекста можно явно перенаправлять на компоненты других контекстов и блоки указателей подходящих типов, не содержащихся в контекстах;
 * - данные контекста можно обменивать с данными других контекстов и указателей подходящих типов, не содержащихся в контекстах;
 * - перенаправление указателей контекста на новые динамически созданные данные производится явно при помощи соответствующих операций над хитрыми указателями, подконтекстами и самим контекстом.
 * 
 * Согласно устройству указателей на данные, как текущие, так и сохранённые данные могут быть пустыми, либо непустыми и иметь произвольный (уничтожаемый) тип, и пустота, тип и значение данных могут изменяться при выполнении программы.
 * 
 * Компоненты *контекста по умолчанию*, а также компоненты любого контекста и/или его составных частей инициализируются (по умолчанию) следующим образом:
 * - указатель на флаг активности: новым опущенным флагом;
 * - указатель на строку: новой пустой строкой;
 * - указатель на данные: новыми пустыми данными.
 * 
 * Конкретная понятийная база
 * ==
 * 
 * Этот раздел посвящён общему описанию того, как работают \ref ConPredefinedRegexps "готовые выражения": регулярные выражения, которые можно создавать в рамках *интерфейса создания регулярных выражений*, предоставляемого \ref index "этой библиотекой".
 * Готовые выражения по сравнению с тем, что позволяет абстрактная понятийная база, работают "естественно", "предсказуемо" и "разумно":
 * - следующие подразделы посвящены *видам* регулярных выражений: *безопасные*, *тривиальные*, *терминальные*, *функциональные*, *композициональные*;
 * - каждое готовое выражение принадлежит одному или нескольким видам;
 * - устройство выражения и выполнение его метода полного разбора удовлетворяет всем свойствам видов, к которым оно принадлежит.
 * 
 * Безопасное выражение
 * --
 * 
 * Выполнение метода полного разбора возвратного потока `s` в контексте `c` безопасным выражением удовлетворяет следующим свойствам:
 * - Последовательность операций чтения из потока `s` и возврата в поток `s` не зависит от наполнения контекста `c`.
 * - Все хитрые указатели контекста `c` по завершении вызова направлены на те же данные, что и до вызова.
 * - Значения флагов активности подконтекстов контекста `c` после вызова совпадают со значениями соответствующих флагов до вызова.
 * - Если вызов завершился неуспехом, то строка и регулярные данные контекста `c` не изменяются вызовом, и последовательность символов потока `s` по завершении вызова равна его последовательности символов до вызова.
 * - Если вызов завершился успехом, то:
 *  - Различие последовательностей символов потока `s` до вызова и после вызова равносильно различию, получаемому чтением некоторой строки из этого потока: строки, *принятой* этим вызовом и выражением, чей метод вызван.
 *  - Если строковый подконтекст контекста `c` активен, то по завершении разбора в конец строки контекста добавляется принятая строка, а если неактивен, то строка контекста не изменяется.
 *  - Если подконтекст данных контекста `c` активен, то регулярные данные контекста изменяются согласно устройству *активного изменения данных* регулярным выражением, метод которого вызван, а если неактивен, то регулярные данные не изменяются.
 * 
 * Метод полного разбора может прочитать из стандартного потока ввода, содержащегося в разбираемом возвратном потоке, больше символов, чем заявлено выше (ни одного символа при неуспехе, либо принятая строка при успехе). По завершении метода полного разбора символы, прочитанные из стандартного потока ввода сверх заявленного, располагаются в буфере возвратного потока. Если вызывался метод разбора стандартного потока ввода, то эти символы нигде не сохраняются.
 * 
 * Тривиальное выражение
 * --
 * 
 * - Тривиальное выражение является безопасным.
 * - Тривиальным выражением всегда принимается пустая строка.
 * - Активное изменение данных тривиальным выражением тривиально: данные не изменяются.
 * - Тривиальные выражения отличаются друг от друга только *критерием успешности разбора*: необходимыми и достаточными условиями, при которых вызов метода полного разбора завершается успехом.
 * 
 * Терминальное выражение
 * --
 * 
 * - Терминальное выражение является безопасным.
 * - Терминальным выражением определяются:
 *  - *принимаемая строка*: описание того, как в общем случае выглядит строка, принятая по итогам успешного разбора;
 *  - *тип данных*.
 * - Вызов метода полного разбора возвратного потока `s` успешен в том и только том случае, если последовательность символов потока `s` начинается со строки, принимаемой выражением.
 * - Активное изменение текущих данных терминальным выражением - это переустановка значения в тип, равный типу данных выражения.
 * - Активное изменение сохранённых данных терминальным выражением тривиально: сохранённые данные не изменяются.
 * 
 * Функциональные выражения
 * --
 * 
 * - Функциональное выражение является безопасным.
 * - Разбор потока функциональным выражением всегда успешен.
 * - Строка, принимаемая функциональным выражением, пуста, и более того, метод полного разбора функционального выражения не содержит ни одного чтения символа и ни одного возврата символа.
 * - Функциональное выражение *содержит* одноместную или двуместную \ref ConDataFunctions "функцию над данными".
 * - Функциональным выражением определяется *способ применения* содержащейся функции к указателям на текущие и/или сохранённые данные.
 * 
 * Композициональное выражение
 * --
 * 
 * - В композициональном выражении *содержатся* другие регулярные выражения - *подвыражения* этого выражения.
 * - Если все подвыражения, содержащиеся в композициональном выражении, безопасны, то и само выражение безопасно.
 * - Композициональным выражением определяются:
 *  - *схема разбора*: то, как в вызове метода полного разбора выражения комбинируются вызовы методов полного разбора подвыражений;
 *  - *критерий успешности разбора*: то, как итоги разборов потока подвыраженями согласно схеме разбора комбинируются в итог разбора потока выражением;
 *  - *принимаемая строка*: то, как стрОки, принятые подвыражениями согласно схеме разбора, комбинируются в строку, принятую выражением;
 *  - *активное изменение данных*: то, как активные изменения данных подвыражениями согласно схеме разбора комбинируются в активное изменение данных выражением.
 * 
 * Реализация
 * ==
 * 
 * *Интерфейс регулярного выражения* предоставляется классом pm::regexp::RegexpInterface.
 * Этот класс содержит виртуальный деструктор, не содержит полей и предназначен для наследования его другими классами - *регулярными выражениями в широком смысле*.
 * 
 * *Регулярное выражение* - это объект класса pm::regexp::Regexp, наследующий интерфейс регулярного выражения.
 * 
 * *Регулярный контекст разбора* - это объект класса pm::regexp::Context.
 * 
 * *Регулярный контекст по умолчанию* - это объект pm::regexp::default_context.
 * В момент начала работы функции `main` контекст по умолчанию считается инициализированным.
 * Желающим использовать этот контекст до начала работы функции `main` (например, для запуска методов разбора с одним аргументом или с этим контекстом в рамках инициализации глобальных переменных) рекомендовано посмотреть в определение этого объекта и свериться со стандартным порядком инициализации объектов перед началом выполнения функции `main`.
 * Компоненты контекста по умолчанию могут произвольно изменяться программой, однако делать это **не рекомендуется**, так как может приводить к непредсказуемым и ошибочным результатам.
 * 
 * Подключение файла pm/regexp/expressions.hpp добавляет все определения функций и операторов создания регулярных выражений, предоставляемые \ref index "этой библиотекой".
 * 
 * В файле pm/regexp/expressions/terminals.hpp опеределены все тривиальные выражения.
 * 
 * В файле pm/regexp/expressions/terminals.hpp определены функции создания *основной части* терминальных выражений.
 * 
 * В файле pm/regexp/expressions/typical.hpp определены функции создания *типичных* терминальных выражений:
 * терминальных выражений, которые могут быть легко созданы при помощи других функций, но тем не менее настолько естественны и полезны, что их создание вынесено в отдельные функции.
 * 
 * В файле pm/regexp/expressions/functions.hpp определены функции создания функциональных регулярных выражений по одноместным и двуместным чистым функциям над данными.
 * 
 * В файле pm/regexp/expressions/lazy_functions.hpp определены функции создания функциональных выражений по одноместным и двуместным нечистым (ссылочным, устанавливающим, переустанавливающим) функциям над данными - *ленивые функции*.
 * 
 * В файле pm/regexp/expressions/composition.hpp определены функции создания *основной части* композициональных выражений.
 * 
 * В файле pm/regexp/expressions/operators.hpp определены более наглядные, но в некоторых случаях чуть менее эффективные операторы - аналоги функций создания основной части композициональных выражений.
 * 
 * В файле pm/regexp/expressions/lazy_composition.hpp определены операторы, позволяющие немного сократить операторную запись создания композициональных выражений основной части (*ленивые операторы*):
 * - трактующие символ как терминальное выражение, принимающее этот символ;
 * - трактующие множество символов как терминальное выражение, принимающее любой символ этого множества;
 * - трактующие строку как терминальное выражение, принимающее эту строку.
 * 
 * В файле pm/regexp/expressions/typical.hpp определены функции создания *типичных* композициональных выражений:
 * выражений, которые могут быть легко созданы при помощи других функций, но тем не менее настолько естественны и полезны, что их создание вынесено в отдельные функции.
 * 
 * В файле pm/regexp/expressions/typical.hpp определены функции создания *типичных* функциональных выражений:
 * выражений, которые могут быть легко созданы при помощи других функций, но тем не менее настолько естественны и полезны, что их создание вынесено в отдельные функции.
 * 
 * Список всех готовых регулярных выражений располагается \ref ConPredefinedRegexps "здесь".
 */
