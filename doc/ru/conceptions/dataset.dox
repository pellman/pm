/*! \page ConDataset Совокупность данных
 * 
 * Семантическая часть
 * ==
 * 
 * Совокупность данных
 * --
 * 
 * *Совокупность данных* `ds` (для краткости - просто *совокупность*) - это бесконечный набор \ref ConTrickyPointers "указателей на данные", индексированных неотрицательными целыми числами: `ds[0], ds[1], ds[2], ...` (`ds[i]` - это указатель на данные).
 * 
 * При создании совокупности *по умолчанию* каждый указатель этой совокупности связывается со своими новыми данными (эти данные связываются только с одним указателем - создаваемым).
 * 
 * Каждый указатель на данные совокупности (и сами данные, связанные с этим указателем) могут быть легко получены индексацией и подходящими методами.
 * При этом есть и более "мощный" способ выполнения операций над данными совокупности: применение функций над совокупностью.
 * 
 * Функции над совокупностью
 * --
 * 
 * *Интерфейс функции над совокупностью* включает в себя единственный виртуальный метод:
 * метод *применения* функции к совокупности.
 * Этот метод принимает совокупность в качестве аргумента и ничего не возвращает.
 * 
 * *Интерфейс создания функций над совокупностью*, предоставляемый \ref index "этой библиотекой", позволяет создавать следующие *готовые функции над совокупностью*:
 * - *Тривиальная функция*:
 *  - При применении к совокупности данных не изменяет эту совокупность.
 * - *Композиция* над {f1, ..., fk}:
 *  - *Содержит* список функций над совокупностью {f1, ..., fk}.
 *  - Применение композиции к совокупности данных - это последовательное применение к ней функций f1, ..., fk от 1-й к k-й.
 * - *Конкретная функция над совокупностью*:
 *  - Имеет вид \f$ (f, [i_1, \dots, i_n]) \f$, где \f$ f \f$ - n-местная \ref ConDataFunctions "функция над данными", и \f$ [i_1, \dots, i_n] \f$ - упорядоченный набор целых неотрицательных чисел.
 *  - Применение конкретной функции к совокупности \f$ ds \f$ - это применение функции \f$ f \f$ к указателям \f$ (ds[i_1], \dots, ds[i_n]) \f$.
 *  - Применение *корректно*, если применение функции над данными к требуемым указателям корректно.
 *  - *Вид* конкретной функции над совокупностью определяется видом содержащейся в ней функции над данными: чистая, ссылочная, переустанавливающая, устанавливающая.
 * 
 * Синтаксическая часть
 * ==
 * 
 * *Определение совокупности* - это \ref ConNumeration "нумерация" \ref ConBaseStandardTypes "строк".
 * Область определения этой нумерации содержит *имена данных*.
 * Образ имени данных - это индекс совокупности данных, соответствующий этому имени.
 * 
 * *Интерфейс определения функции над совокупностью* включает в себя единственный виртуальный метод:
 * метод *интерпретации* функции на определении совокупности.
 * Этот метод принимает определение совокупности и возвращает функцию над совокупностью.
 * 
 * *Интерфейс создания функций над совокупностью*, предоставляемый \ref index "этой библиотекой", позволяет создавать *готовые определения*, при интерпретации возвращающие готовые функции над совокупностью.
 * 
 * *Рекомендованный способ интерпретации функций*, которые предполагается применять к одной и той же совокупности данных, выглядит так:
 * - Создать определение совокупности.
 * - Последовательно интерпретировать на созданном определении совокупности все определения функций, которые предполагается применять к одной и той же совокупности.
 * - Между вызовами методов интерпретации не удалять имена данных из определения совокупности.
 * 
 * По итогам выполнения рекомендованного способа интерпретации в определении совокупности содержится некоторая нумерация \f$ \varphi_d \f$ имён данных.
 * 
 * Собственно готовые определения:
 * - *Определение тривиальной функции*:
 *  - При интерпретации возвращается тривиальная функция.
 * - *Определение композиции* над {d1, ..., dk}:
 *  - *Содержит* список определений функций над совокупностью данных {d1, ..., dk}.
 *  - При интерпретации возвращается композиция над {f1, ..., fk}, где fi - функция, возвращаемая при интерпретации определения di.
 * - *Определение конкретной функции над совокупностью*:
 *  - Имеет вид \f$ (f, [s_1, \dots, s_n]) \f$, где \f$ f \f$ - n-местная функция над данными и \f$ [s_1, \dots, s_n] \f$ - упорядоченный набор строк (имён данных).
 *  - При интерпретации возвращается конкретная функция над совокупностью вида \f$ (f, [\varphi_d(s_1), \dots, \varphi_d(s_n)]) \f$.
 * 
 * Реализация и её документация
 * ==
 * 
 * Классы и методы
 * --
 * 
 * *Совокупность данных* - это объект класса pm::dataset::Set.
 * Само собой, бесконечности не существует: указатели на данные индексируются (стандартным образом) числами типа `size_t`, и совокупность может содержать столько указателей, сколько позволяет индексация.
 * Каждый содержащийся указатель имеет тип pm::type_abuse::DPtr.
 * 
 * *Интерфейс функции над совокупностью* предоставляется классом pm::dataset::FunctionInterface.
 * Этот класс содержит виртуальный деструктор, не содержит полей и предназначен для наследования его другими классами - *функциями над совокупностью в широком смысле*.
 * Метод применения функции к совокупности имеет название pm::dataset::FucntionInterface::apply.
 * 
 * *Функция над совокупностью* - это объект класса pm::dataset::Function.
 * С точки зрения того, кто использует интерфейс создания готовых функций над совокупностью, предоставляемый \ref index "этой библиотекой", единственное, что важно знать про этот класс, - это то, что он наследуется от класса интерфейса функции над совокупностью.
 * 
 * *Определение совокупности* - это объект класса pm::dataset::syntax::Set - синонима класса нумерации pm::utils::Numeration<std::string>.
 * 
 * *Интерфейс определения функции над совокупностью* предоставляется классом pm::dataset::syntax::FunctionInterface.
 * Этот класс содержит виртуальный деструктор, не содержит полей и предназначен для наследования его другими классами - *определениями функций над совокупностью в широком смысле*.
 * 
 * *Определение функции над совокупностью* - это объект класса pm::dataset::syntax::Function.
 * С точки зрения того, кто использует интерфейс создания готовых синтаксических определений, предоставляемый \ref index "этой библиотекой", единственное, что важно знать про этот класс, - это то, что он наследуется от класса интерфейса определения функции над совокупностью.
 * 
 * Интерфейс создания
 * --
 * 
 * Интерфейс создания конкретных функций над совокупностью целиком подключается файлом pm/dataset/functions.hpp.
 * 
 * Интерфейс создания определений конкретных функций над совокупностью целиком подключается файлом pm/dataset/syntax.hpp.
 * 
 * Интерфейс создания как функций над совокупностью, так и их определений условно разделён на четыре части:
 * - Базовый интерфейс: позволяет создавать конкретные функции, содержащие чистые функции над данными, композицию функций и тривиальную функцию и их определения.
 *  - Для функций: подключается файлом pm/dataset/functions/base.hpp
 *  - Для определений: подключается файлом pm/dataset/syntax/functions/base.hpp
 * - Ленивый интерфейс: позволяет создавать конкретные функции, содержащие нечистые (ссылочные, устанавливающие, переустанавливающие) функции над данными, и их определения.
 *  - Для функций: подключается файлом pm/dataset/functions/lazy.hpp
 *  - Для определений: подключается файлом pm/dataset/syntax/functions/lazy.hpp
 * - Операторный интерфейс: подключает операторный способ создания композиции (последовательного применения) функций и её определения.
 *  - Для функций: подключается файлом pm/dataset/functions/operators.hpp
 *  - Для определений: подключается файлом pm/dataset/syntax/functions/operators.hpp
 * - Типичный интерфейс: подключает интерфейс создания функций над данными, которые при желании и некоторых усилиях можно создать и другими способами, но настолько естественны и полезны, что для удобства вынесены отдельно, и их определений.
 *  - Для функций: подключается файлом pm/dataset/functions/typical.hpp
 *  - Для определений: подключается файлом pm/dataset/syntax/functions/typical.hpp
 */
