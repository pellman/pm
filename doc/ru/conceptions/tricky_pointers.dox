/*! \page ConTrickyPointers Хитрые указатели
 * 
 * \section ConTrickyPointersIntro Введение
 * 
 * Понятие "указателя" в целом общеизвестно и кратко может быть описано так:
 * - это объект, который может быть *связан* не более чем с одним (другим) объектом (т.е. может *указывать* на связанный объект);
 * - указатель может быть *пуст*: иметь специальное значение, явно и однозначно утверждающее, что указатель не связан ни с одним объектом;
 * - несколько указателей могут быть связаны с одним и тем же объектом;
 * - если указатель связан с каким-либо объектом, то он *разыменовываем*;
 * - *разыменование* указателя - это получение ссылки на связанный объект;
 * - непустой неразыменовываемый указатель *некорректен*.
 * 
 * Общеизвестными (и стандартными) являются два вида указателей:
 * - чистые указатели (plain pointers) на объект типа `T`: `T *`;
 * - умные указатели (smart pointers) на объект типа `T`: `std::shared_ptr<T>`, `std::uinque_ptr<T>`, ... .
 * 
 * Умные указатели всем хороши, кроме того, что они имеют фиксированную семантику общего плана:
 * интерфейс работы с умными указателями позволяет делать много всего и не задумываться о "низкоуровневых" вещах наподобие освобождения памяти, но, как обычно это бывает, если хочется использовать подобный интерфейс в реализации более высокоуровневых понятий, приходится в целях удобства вводить новые надстройки.
 * *Хитрые указатели* - это такого рода надстройки над умными указателями, используемые в \ref index "этой библиотеке".
 * 
 * \section ConTrickyPointersSpecifics Понятийная база
 * 
 * На данный момент реализованы и документированы два вида хитрых указателей:
 * - *стабильные указатели*;
 * - *указатели на данные*.
 * 
 * \subsection ConTrickyPointersBase Данные указателей
 * 
 * *Опциональный тип* - это либо тип в обычном понимании, либо *пустой тип*, отличный от всех типов в обычном понимании.
 * *Данные* - это либо *непустые данные*, либо *пустые данные*.
 * Непустые данные - это синоним термина "объект" в обычном понимании.
 * Пустые данные имеют пустой тип.
 * Содержательно, пустые данные означают "объекта нет", и понятие непустых данных позволяет рассуждать о том, связаны ли хитрые указатели на данные с одинаковыми или с разными "отсутствующими объектами".
 * 
 * *Копия пустых данных* - это также пустые данные.
 * Содержательно, копия пустых данных - это пустые данные, отличные от копируемых данных как "объект в абстрактном понимании", также как копия объекта отлична от копируемого объекта (по расположению в памяти).
 * 
 * Хитрый указатель в каждый момент времени *связан* ровно с одними данными (*указывает* на эти данные; *направлен* на эти данные; *владеет* этими данными).
 * Данные *связаны* с хитрым указателем (являются *данными указателя*), если указатель связан с этими данными.
 * Данные могут быть связаны с любым числом хитрых указателей одинакового типа (то есть на любые данные может указывать любое число хитрых указателей).
 * Для данных, связанных с хитрым указателем, в каждый момент времени однозначно определён их *базовый тип* - опциональный тип, зависящий от того, как и с каким хитрым указателем связаны эти данные.
 * 
 * Базовый тип данных, связываемых со стабильным указателем, **непуст** и однозначно определяется типом этого указателя и называется *базовым типом указателя*.
 * Базовый тип указателя имеет примерно тот же смысл, что и тип `T` в составе типа чистого указателя `T *`:
 * фактический тип объекта, связанного с указателем, может отличаться от базового типа, но почти во всех операциях над указателем полагается, что фактический тип объекта
 * - либо в точности совпадает с базовым типом (см. ниже: открепление, перезапись, установка значения, обмен содержимым, сброс, клонирование),
 * - либо подходящим образом наследуется в иерархии типов от базового типа (см. ниже: разыменование, сборка мусора).
 * 
 * Базовый тип данных, связываемых с указателем на данные, может произвольно изменяться в процессе работы программы и всегда совпадает с (фактическим) опциональным типом данных, связанных с указателем.
 * 
 * \subsection ConTrickyPointersInterface Операции над указателями
 * 
 * *Данные по умолчанию* - это:
 * - для стабильного указателя: объект базового типа указателя, инициализированный значением по умолчанию, то есть объект `T()`, где `T` - базовый тип указателя;
 * - для указателя на данные: пустые данные.
 * 
 * В результате *инициализации по умолчанию* хитрый указатель связывается с новыми данными по умолчанию, то есть:
 * - для стабильного указателя: выполняется выражение `new T()`, где `T` - базовый тип указателя, и указатель связывается с объектом, адрес которого возвращается этим выражением;
 * - для указателя на данные: он связывается с новыми пустыми данными.
 * Новые данные по умолчанию, появляющиеся в результате инициализации по умолчанию, связываются только с инициализируемым указателем.
 * 
 * В результате *перенаправления указателя* на данные `d2` он перестаёт быть связанным с текущими своими данными и становится связанным с данными `d2`.
 * 
 * *Разыменование указателя*, указывающего на непустые данные базового типа `T` - это получение ссылки типа `T &` на эти данные.
 * Также *разыменование указателя* - это сама ссылка указанного выше вида.
 * Термин "разыменование" часто используется двояко (и как процесс, и как результат), и настолько же двояко он используется в этой документации.
 * Разыменование хитрого указателя, указывающего на пустые данные, не определено.
 * 
 * Разыменование хитрого указателя `ptr`, связанного с непустыми данными, в документации обозначется стандартным образом: `*ptr`.
 * 
 * *Открепление указателя* - это перенаправление указателя на копию его данных до открепления как данных базового типа.
 * Новые данные, появляющиеся в результате открепления, связываются только с открепляемым указателем.
 * 
 * В результате *сброса данных* эти данные приобретают значение по умолчанию, и это делается так:
 * - для стабильного указателя: выполняется перемещающее присваивание этим данным как объекту базового типа значения `T()`, где `T` - базовый тип указателя;
 * - для указателя на данные: связанные данные становятся пустыми.
 * Данные после сброса остаются связанными со всеми указателями, с которыми они были связаны до сброса.
 * 
 * *Сброс указателя* - это сброс связанных с ним данных.
 * 
 * *Перезапись данных* `d1` данными `d2` устроена так:
 * - для стабильного указателя: выполняется копирующее присваивание данным `d1` как объекту базового типа значения данных `d2`;
 * - для указателя на данные: данными `d1` становится новая копия данных `d2`.
 * Данные после перезаписи остаются связанными со всеми указателями, с которыми они были связаны до перезаписи.
 * 
 * *Перезапись указателя* `ptr1` хитрым указателем `ptr2` того же типа - это перезапись данных, связанных с `ptr1`, данными, связанными с `ptr2`.
 * 
 * *Переустановка данных* в тип `T` от аргументов `a1, a2, ..., ak` - это:
 * - для стабильного указателя: тип `T` должен совпадать с базовым типом указателя, и выполненяется перемещающее присваивание данным как объекту базового типа значения `T(a1, a2, ..., ak)`; в связи с ограничением на тип `T` упоминание этого типа для стабильных указателей будет опускаться;
 * - для указателя на данные: данными становится новый объект типа `T`, инициализированный от аргументов `a1, a2, ..., ak`: `T(a1, a2, ..., ak)`.
 * Данные после переустановки остаются связанными со всеми указателями, с которыми они были связаны до переустановки.
 * 
 * *Переустановка указателя* в тип `T` от аргументов `a1, a2, ..., ak` - это переустановка связанных с ним данных в этот тип от этих аргументов.
 * 
 * *Обмен содержимого* указателей `ptr1` и `ptr2` происходит так:
 * - для стабильного указателя: выполняется выражение `std::swap(*ptr1, *ptr2)`;
 * - для указателя на данные:
 *  - данные указателя `ptr1` приобретают опциональный тип и значение исходных данных указателя `ptr2`;
 *  - данные указателя `ptr2` приобретают опциональный тип и значение исходных данных указателя `ptr1`;
 *  - никакие операции над непустыми данными не производятся.
 * Связи данных, на которые указывают `ptr1` и `ptr2`, со всеми указателями сохраняются при обмене, но типы и значения этих данных меняются местами.
 * 
 * *Клонирование указателя* - это создание *клона указателя*, то есть указателя, связанного с новой копией данных, связанных с клонируемым указателем, как данных базового типа.
 * Новые данные, появляющиеся в результате клонирования, связываются только с создаваемым клоном указателя.
 * 
 * \subsection ConTrickyPointersGarbageCollection Сборка мусора
 * 
 * В хитрые указатели встроена автоматическая *сборка мусора*, аналогичная сборке мусора при работе с умными указателями типа `std::shared_ptr` (с поправкой на понятие "опциональный тип"):
 * - данные, которые перестают быть связанными хотя бы с одним указателем, уничтожаются:
 *  - если данные непусты, то уничтожение данных - это вызов деструктора этих данных как объекта базового типа;
 *  - если данные пусты, то никаких особых действий для этого не производится (и утечек памяти не возникает);
 * - для указателя на данные: если текущие данные указателя непусты, то при выполнении сброса, перезаписи или переустановки указателя эти данные уничтожаются вызовом деструктора этих данных как объекта (непустого) базового типа.
 * 
 * \section ConTrickyPointersImplementation Реализация и её документация
 * 
 * Стабильный указатель - это объект шаблонного класса pm::type_abuse::SPtr.
 * Параметр шаблона - это базовый класс стабильного указателя.
 * 
 * Указатель на данные - это объект класса pm::type_abuse::DPtr.
 */
