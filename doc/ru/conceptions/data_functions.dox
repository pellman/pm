/*! \page ConDataFunctions Функции над данными
 * 
 * Общее устройство и назначение функций над данными выглядят так.
 * *Функция над данными* - это функциональный объект, который может быть *применён* к упорядоченному набору \ref ConTrickyPointers "указателей на данные".
 * В результате такого применения данные указателей могут измениться согласно последовательности *действий*, описанных в функции.
 * Применение функции над данными к совокупности указателей *корректно*, если в момент выполнения каждого действия, предполагающего, что данные указателя непусты и имеют тип `T`, эти данные действительно непусты и имеют тип `T`.
 * 
 * В \ref index "этой библиотеке" используются четыре вида функций над данными:
 * - чистые функции;
 * - ссылочные функции;
 * - устанавливающие функции;
 * - переустанавливающие функции.
 * 
 * Чистые функции - это наиболее общий, но при этом наименее удобный способ описания действий, производимых над данными, хранящимися указателях на данные.
 * Функции остальных трёх видов в сигнатуре своего вызова содержат типы не указателей на данные, а собственно данных, над которыми должны быть произведены действия, и имеют более специальное устройство действий.
 * 
 * Чистые функции
 * --
 * 
 * *n-местная чистая функция* (над данными) - это функциональный объект `f`, вызов которого имеет n аргументов и сигнатуру `void f(const pm::type_abuse::DPtr &, ... const pm::type_abuse::DPtr &)`.
 * 
 * *Применение n-местной чистой функции* `f` к указателям на данные `(ptr_1, ..., ptr_n)` - это выполнение вызова `f(ptr_1, ..., ptr_n)`.
 * 
 * Применение чистой функции к указателям на данные *корректно*, если в момент выполнения каждой операции над указателем в теле вызова, предполагающей (согласно документации), что данные, связанные с указателем, непусты и имеют тип `T`, эти данные действительно непусты и имеют тип `T`.
 * 
 * Ссылочные функции
 * --
 * 
 * *n-местная ссылочная функция* (над данными) - это функциональный объект `f`, вызов которого имеет n аргументов и заданную сигнатуру `void f(T_1, ..., T_n)`, где `T_i` - произвольный тип.
 * 
 * *Применение n-местной ссылочной функции* `f` к указателям на данные `(ptr_1, ..., ptr_n)` - это выполнение вызова `f(*ptr_1, ..., *ptr_n)`.
 * 
 * Применение ссылочной функции *корректно*, если в момент выполнения вызова данные указателей `ptr_1, ..., ptr_n` непусты и имеют типы, равные основам типов `T_1, ..., T_n` соответственно.
 * 
 * Устанавливающие функции
 * --
 * 
 * *n-местная устанавливающая функция* (над данными) - это функциональный объект `f`, вызов которого имеет n аргументов и заданную сигнатуру `R f(T_2, ..., T_n)`, где `T_i` - произвольный тип, и `R` - произвольный тип, отличный от `void`.
 * Если `n == 1`, то сигнатура вызова не содержит ни одного параметра.
 * 
 * *Применение n-местной устанавливающей функции* `f` к указателям на данные `(ptr_1, ..., ptr_n)` - это последовательное выполнение двух действий:
 * - выполнение вызова `f(*ptr_2, ..., *ptr_n)`;
 * - переустановка указателя `ptr_1` в тип, равный основе типа `R`, от значения, возвращаемого выполненным вызовом.
 * 
 * Применение устанавливающей функции *корректно*, если в момент выполнения вызова `f(*ptr_2, ..., *ptr_n)` данные указателей `ptr_2, ..., ptr_n` непусты и имеют типы, равные основам типов `T_2, ..., T_n` соответственно.
 * 
 * Переустанавливающие функции
 * --
 * 
 * *n-местная переустанавливающая функция* (над данными) - это функциональный объект `f`, вызов которого имеет n аргументов и заданную сигнатуру `R f(T_1, ..., T_n)`, где `T_i` - произвольный тип, и `R` - произвольный тип, отличный от `void`.
 * 
 * *Применение n-местной устанавливающей функции* `f` к указателям на данные `(ptr_1, ..., ptr_n)` - это последовательное выполнение двух действий:
 * - выполнение вызова `f(*ptr_1, ..., *ptr_n)`;
 * - переустановка указателя `ptr_1` в тип, равный основе типа `R`, от значения, возвращаемого выполненным вызовом.
 * 
 * Применение переустанавливающей функции *корректно*, если в момент выполнения вызова `f(*ptr_1, ..., *ptr_n)` данные указателей `ptr_1, ..., ptr_n` непусты и имеют типы, равные основам типов `T_1, ..., T_n` соответственно.
 */
