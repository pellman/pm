/*! \page ConPredefinedRegexps Готовые регулярные выражения
 * 
 * Здесь перечисляются все \ref ConRegexp "готовые регулярные выражения", реализованные на данный момент в \ref index "этой библиотеке".
 * 
 * Тривиальные выражения
 * ==
 * 
 * Успех
 * --
 * 
 * - Критерий успешности разбора: разбор всегда успешен.
 * 
 * Неуспех
 * --
 * 
 * - Критерий успешности разбора: разбор всегда неуспешен.
 * 
 * Конец потока
 * --
 * 
 * - Критерий успешности разбора: чтение следующего символа из потока неуспешно.
 * 
 * Терминальные выражения
 * ==
 * 
 * Любой символ
 * --
 * 
 * - Принимаемая строка: любая строка длины 1.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Символ `c`
 * --
 * 
 * - Принимаемая строка: строка "c".
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от значения `c`.
 * 
 * Любой символ множества `s`
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ которой принадлежит множеству `s`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Любой символ, кроме символа `c`
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ которой неравен `c`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Любой символ, кроме символов множества `s`
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ которой не принадлежит множеству `s`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Символ от `a` до `b`
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой удовлетворяет неравенствам `a <= c` и `c <= b`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Строка `s`
 * --
 * 
 * - Принимаемая строка: строка `s`.
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от строки `s`.
 * 
 * Строка длины `n`
 * --
 * 
 * - Принимаемая строка: любая строка длины `n`.
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от принятой строки.
 * 
 * Строка, обрамлённая подстроками `s1` и `s2`
 * --
 * 
 * - Принимаемая строка: любая строка, удовлетворяющая следующим свойствам:
 *  - её можно разбить на три подстроки: сначала `s1`, затем любая строка (в том числе пустая), затем `s2`;
 *  - никакой собственный префикс этой строки нельзя разбить на три подстроки указанным образом (собственный префикс - это строка, которую можно получить из исходной удалением символов с конца, при этом удалив хотя бы один символ).
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от принятой строки.
 * 
 * Маленькая латинская буква
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является маленькой латинской буквой: `'a' <= c` и `c <= 'z'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Большая латинская буква
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является большой латинской буквой: `'A' <= c` и `c <= 'Z'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Латинская буква
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является латинской буквой: либо `'a' <= c` и `c <= 'z'`, либо `'A' <= c` и `c <= 'Z'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Символ нижнего подчёркивания
 * --
 * 
 * - Принимаемая строка: строка "_".
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от значения '_'.
 * 
 * Символ десятичной цифры
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является символом десятичной цифры: `'0' <= c` и `c <= '9'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Десятичная цифра типа `Int`
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является символом десятичной цифры: `'0' <= c` и `c <= '9'`.
 * - Тип данных: `Int`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от значения `c - '0'`.
 * 
 * Десятичное число типа `Int`
 * --
 * 
 * - Принимаемая строка: любая непустая строка, состоящая только из символов десятичных цифр; символ десятичной цифры - это любой символ `c`, удовлетворяющий неравенствам `'0' <= c` и `c <= '9'`.
 * - Тип данных: `Int`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются следующим (стандартным) образом:
 *  - символы принятой строки просматриваются от первого к последнему;
 *  - текущие данные переустанавливаются в тип `Int` от значения `c - '0'`, где `c` - первый просмотренный символ;
 *  - при просмотре каждого следующего символа последовательно производятся три действия (`i` в описании действий - текущие данные):
 *   - инициализируется объект `j` типа `Int` от значения `c - '0'`;
 *   - выполняется присваивание `i *= 10`;
 *   - выполняется присваивание `i += j`.
 * 
 * Строковая запись десятичного числа
 * --
 * 
 * - Принимаемая строка: любая непустая строка, состоящая только из символов десятичных цифр; символ десятичной цифры - это любой символ `c`, удовлетворяющий неравенствам `'0' <= c` и `c <= '9'`.
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от принятой строки.
 * 
 * Головной символ идентификатора языка C
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является головным символом идентификатора языка `c`: либо `c == '_'`, либо `'a' <= c` и `c <= 'z'`, либо `'A' <= c` и `c <= 'Z'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Хвостовой символ идентификатора языка C
 * --
 * 
 * - Принимаемая строка: любая строка длины 1, единственный символ `c` которой является хвостовым символом идентификатора языка `c`: либо `c == '_'`, либо `'a' <= c` и `c <= 'z'`, либо `'A' <= c` и `c <= 'Z'`, либо `'0' <= c` и `c <= '9'`.
 * - Тип данных: `char`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от (единственного) символа принятой строки.
 * 
 * Идентификатор языка C
 * --
 * 
 * - Принимаемая строка: любая непустая строка, являющаяся идентификатором языка C:
 *  - для первого символа `c` верно либо `c == '_'`, либо `'a' <= c` и `c <= 'z'`, либо `'A' <= c` и `c <= 'Z'`;
 *  - для остальных символов `d` верно  либо `d == '_'`, либо `'a' <= d` и `d <= 'z'`, либо `'A' <= d` и `d <= 'Z'`, либо `'0' <= d` и `d <= '9'`.
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от принятой строки.
 * 
 * Функциональные выражения
 * ==
 * 
 * В описании этих выражений используются следующие обозначения:
 * - `cptr` - указатель на текущие данные контекста, с которым вызван метод полного разбора
 * - `sptr` - указатель на сохранённые данные контекста, с которым вызван метод полного разбора
 * 
 * Одноместная чистая функция `f` над текущими данными
 * --
 * 
 * - Содержит одноместную чистую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `cptr`.
 * 
 * Двуместная чистая функция `f` над текущими данными
 * --
 * 
 * - Содержит двуместную чистую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(cptr, sptr)`.
 * 
 * Одноместная чистая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит одноместную чистую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `sptr`.
 * 
 * Двуместная чистая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит двуместную чистую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(sptr, cptr)`.
 * 
 * Одноместная ссылочная функция `f` над текущими данными
 * --
 * 
 * - Содержит одноместную ссылочную функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `cptr`.
 * 
 * Двуместная ссылочная функция `f` над текущими данными
 * --
 * 
 * - Содержит двуместную ссылочную функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(cptr, sptr)`.
 * 
 * Одноместная ссылочная функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит одноместную ссылочную функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `sptr`.
 * 
 * Двуместная ссылочная функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит двуместную ссылочную функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(sptr, cptr)`.
 * 
 * Одноместная устанавливающая функция `f` над текущими данными
 * --
 * 
 * - Содержит одноместную устанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `cptr`.
 * 
 * Двуместная устанавливающая функция `f` над текущими данными
 * --
 * 
 * - Содержит двуместную устанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(cptr, sptr)`.
 * 
 * Одноместная устанавливающая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит одноместную устанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `sptr`.
 * 
 * Двуместная устанавливающая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит двуместную переустанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(sptr, cptr)`.
 * 
 * Одноместная переустанавливающая функция `f` над текущими данными
 * --
 * 
 * - Содержит одноместную переустанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `cptr`.
 * 
 * Двуместная переустанавливающая функция `f` над текущими данными
 * --
 * 
 * - Содержит двуместную переустанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(cptr, sptr)`.
 * 
 * Одноместная переустанавливающая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит одноместную переустанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателю `sptr`.
 * 
 * Двуместная переустанавливающая функция `f` над сохранёнными данными
 * --
 * 
 * - Содержит двуместную переустанавливающую функцию `f` над данными.
 * - Способ применения: функция `f` применяется к указателям `(sptr, cptr)`.
 * 
 * Композициональные выражения
 * ==
 * 
 * При работе с композициональными выражениями предполагается, что данные и их копия имеют одинаковое значение:
 * в некоторых случаях происходит копирование данных, активное изменение копии вместо исходных данных и подмена данных их копией, и явно на этом внимание не акцентируется.
 * 
 * Альтернатива над последовательностью выражений `(r1, ..., rk)`
 * --
 * 
 * - Содержит подвыражения `r1, ..., rk` в том же порядке.
 * - Схема разбора: последовательно по порядку запускается полный разбор потока подвыражениями `r1, ..., rk`, пока не будет достигнуто одно из двух:
 *  - разбор потока очередным подвыражением успешен (это подвыражение далее называется *успешным*);
 *  - поток неуспешно разборан всеми подвыражениями.
 * - Критерий успешности разбора: поток успешно разобран каким-либо подвыражением.
 * - Принимаемая строка: равна строке, принимаемой успешным подвыражением.
 * - Активное изменение данных: совпадает с активным изменением данных успешным подвыражением.
 * 
 * Разность выражений `r1` и `r2`
 * --
 * 
 * - Содержит *положительное подвыражение* `r1` и *отрицательное подвыражение* `r2`.
 * - Схема разбора:
 *  - запускается полный разбор потока положительным подвыражением;
 *  - в случае успеха запускается разбор строки, принятой положительным подвыражением, с контекстом по умолчанию отрицательным подвыражением.
 * - Критерий успешности разбора: разбор положительного подвыражения успешен, и разбор отрицательного подвыражения
 *  - либо неуспешен,
 *  - либо успешен, но принята не вся строка.
 * - Принимаемая строка: равна строке, принимаемой положительным подвыражением.
 * - Активное изменение данных: совпадает с активным изменением данных положительным подвыражением.
 * 
 * Конкатенация над последовательностью выражений `(r1, ..., rk)`
 * --
 * 
 * - Содержит подвыражения `r1, ..., rk` в том же порядке.
 * - Схема разбора: последовательно по порядку запускается полный разбор потока подвыражениями `r1, ..., rk` (поток в начале запуска следующего подвыражения изменён разборами всех предыдущих), пока не будет достигнуто одно из двух:
 *  - разбор потока очередным подвыражением неуспешен;
 *  - поток успешно разборан всеми подвыражениями.
 * - Критерий успешности разбора: поток успешно разобран всеми подвыражениями.
 * - Принимаемая строка: \f$ s_1 s_2 \dots s_k \f$, где \f$ s_i \f$ - строка, принятая i-м подвыражением.
 * - Активное изменение данных: последовательное активное изменение данных подвыражениями в порядке их вызова.
 * 
 * Опционал над `r`
 * --
 * 
 * - Содержит единственное подвыражение `r`.
 * - Схема разбора: однократно запускается полный разбор потока подвыражением.
 * - Критерий успешности разбора: разбор всегда успешен.
 * - Принимаемая строка:
 *  - если разбор потока подвыражением успешен, то равна строке, принятой подвыражением;
 *  - если разбор потока подвыражением неуспешен, то пуста.
 * - Активное изменение данных:
 *  - если разбор потока подвыражением успешен, то совпадает с активным изменением данных подвыражением;
 *  - если разбор потока подвыражением неуспешен, то данные не изменяются.
 * 
 * Звезда Клини над `r`
 * --
 * 
 * - Содержит единственное подвыражение `r`.
 * - Схема разбора: раз за разом до первого неуспеха запускается полный разбор потока подвыражением.
 * - Критерий успешности разбора: разбор всегда успешен.
 * - Принимаемая строка: \f$ s_1 s_2 \dots s_k \f$, где \f$ s_i \f$ - строка, принятая i-м вызовом полного разбора подвыражением, и k - количество успешных разборов подвыражением.
 * - Активное изменение данных: последовательное активное изменение данных успешными разборами подвыражением в порядке их запуска.
 * 
 * Сокрытие данных над `r`
 * --
 * 
 * - Содержит единственное подвыражение `r`.
 * - Схема разбора: однократно запускается разбор потока подвыражением.
 * - Критерий успешности разбора: поток успешно разобран подвыражением.
 * - Принимаемая строка: равна строке, принятой подвыражением.
 * - Активное изменение данных:
 *  - текущие данные изменяются так, как они изменились бы при разборе потока подвыражением с контекстом, отличающимся от контекста разбора выражения в точности тем, что сохранённые данные пусты;
 *  - сохранённые данные не изменяются.
 * 
 * Заглушка данных над `r`
 * --
 * 
 * - Содержит единственное подвыражение `r`.
 * - Схема разбора: однократно запускается разбор потока подвыражением.
 * - Критерий успешности разбора: поток успешно разобран подвыражением.
 * - Принимаемая строка: равна строке, принятой подвыражением.
 * - Активное изменение данных: ни текущие, ни сохранённые данные не изменяются.
 * 
 * Сохранение данных над `r`
 * --
 * 
 * - Содержит единственное подвыражение `r`.
 * - Схема разбора: однократно запускается разбор потока подвыражением.
 * - Критерий успешности разбора: поток успешно разобран подвыражением.
 * - Принимаемая строка: равна строке, принятой подвыражением.
 * - Активное изменение данных:.
 *  - текущие данные изменяются так, как они изменились бы при разборе потока подвыражением с тем же контекстом, что и в разборе выражения;
 *  - сохранённые данные не изменяются.
 * 
 * Терминальные композициональные выражения
 * ==
 * 
 * Идентификатор над головным выражением `head` и хвостовым выражением `tail`
 * --
 * 
 * - Содержит подвыражения `head` и `tail`
 * - Корректно только в том случае, если выражения `head` и `tail` удовлетворяют всем свойствам терминалого выражения с типом данных `char`
 * - Схема разбора:
 *  - однократно запускается разбор потока подвыражением `head`;
 *  - в случае успеха раз за разом до первого неуспеха запускается разбор потока подвыражением `tail` (поток в начале следующего запуска подвыражения изменён разборами всех предыдущих).
 * - Принимаемая строка: \f$ s s_1 s_2 \dots s_k \f$, где \f$ s \f$ - строка, принятая подвыражением `head`, \f$ s_i \f$ - строка, принятая i-м разбором потока подвыражением `tail`, и k - количество успешных разборов потока подвыражением `tail`.
 * - Тип данных: `std::string`.
 * - Активное изменение текущих данных: текущие данные переустанавливаются от значения принятой строки.
 */
